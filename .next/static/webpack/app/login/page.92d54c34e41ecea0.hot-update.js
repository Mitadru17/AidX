"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./src/lib/firebase.ts":
/*!*****************************!*\
  !*** ./src/lib/firebase.ts ***!
  \*****************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   analytics: function() { return /* binding */ analytics; },\n/* harmony export */   app: function() { return /* binding */ app; },\n/* harmony export */   auth: function() { return /* binding */ auth; }\n/* harmony export */ });\n/* harmony import */ var firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! firebase/app */ \"(app-pages-browser)/./node_modules/firebase/app/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_auth__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! firebase/auth */ \"(app-pages-browser)/./node_modules/firebase/auth/dist/esm/index.esm.js\");\n/* harmony import */ var firebase_analytics__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! firebase/analytics */ \"(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js\");\n\n\n\nconst firebaseConfig = {\n    apiKey: \"AIzaSyC3umj98mP4xrlMStniCqPwgfsUnk2vtPA\",\n    authDomain: \"aidxhealth.firebaseapp.com\",\n    projectId: \"aidxhealth\",\n    storageBucket: \"aidxhealth.firebasestorage.app\",\n    messagingSenderId: \"101357297132\",\n    appId: \"1:101357297132:web:30a950f41243c5ead9bdd9\",\n    measurementId: \"G-MGC3XVEKLX\"\n};\n// Initialize Firebase\nconst app = (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)().length === 0 ? (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.initializeApp)(firebaseConfig) : (0,firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApps)()[0];\nconst auth = (0,firebase_auth__WEBPACK_IMPORTED_MODULE_1__.getAuth)(app);\n// Initialize Analytics only on client side\nlet analytics = null;\nif (true) {\n    analytics = (0,firebase_analytics__WEBPACK_IMPORTED_MODULE_2__.getAnalytics)(app);\n}\n\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy9saWIvZmlyZWJhc2UudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXNEO0FBQ2Q7QUFDVTtBQUVsRCxNQUFNSSxpQkFBaUI7SUFDckJDLFFBQVFDLHlDQUF3QztJQUNoREcsWUFBWUgsNEJBQTRDO0lBQ3hESyxXQUFXTCxZQUEyQztJQUN0RE8sZUFBZVAsZ0NBQStDO0lBQzlEUyxtQkFBbUJULGNBQW9EO0lBQ3ZFVyxPQUFPWCwyQ0FBdUM7SUFDOUNhLGVBQWViLGNBQStDO0FBQ2hFO0FBRUEsc0JBQXNCO0FBQ3RCLE1BQU1lLE1BQU1wQixxREFBT0EsR0FBR3FCLE1BQU0sS0FBSyxJQUFJdEIsMkRBQWFBLENBQUNJLGtCQUFrQkgscURBQU9BLEVBQUUsQ0FBQyxFQUFFO0FBQ2pGLE1BQU1zQixPQUFPckIsc0RBQU9BLENBQUNtQjtBQUVyQiwyQ0FBMkM7QUFDM0MsSUFBSUcsWUFBWTtBQUNoQixJQUFJLElBQWtCLEVBQWE7SUFDakNBLFlBQVlyQixnRUFBWUEsQ0FBQ2tCO0FBQzNCO0FBRWdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL3NyYy9saWIvZmlyZWJhc2UudHM/MTU0MCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpbml0aWFsaXplQXBwLCBnZXRBcHBzIH0gZnJvbSAnZmlyZWJhc2UvYXBwJztcclxuaW1wb3J0IHsgZ2V0QXV0aCB9IGZyb20gJ2ZpcmViYXNlL2F1dGgnO1xyXG5pbXBvcnQgeyBnZXRBbmFseXRpY3MgfSBmcm9tICdmaXJlYmFzZS9hbmFseXRpY3MnO1xyXG5cclxuY29uc3QgZmlyZWJhc2VDb25maWcgPSB7XHJcbiAgYXBpS2V5OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9BUElfS0VZLFxyXG4gIGF1dGhEb21haW46IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FVVEhfRE9NQUlOLFxyXG4gIHByb2plY3RJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfUFJPSkVDVF9JRCxcclxuICBzdG9yYWdlQnVja2V0OiBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19GSVJFQkFTRV9TVE9SQUdFX0JVQ0tFVCxcclxuICBtZXNzYWdpbmdTZW5kZXJJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfTUVTU0FHSU5HX1NFTkRFUl9JRCxcclxuICBhcHBJZDogcHJvY2Vzcy5lbnYuTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBQX0lELFxyXG4gIG1lYXN1cmVtZW50SWQ6IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FQVNVUkVNRU5UX0lEXHJcbn07XHJcblxyXG4vLyBJbml0aWFsaXplIEZpcmViYXNlXHJcbmNvbnN0IGFwcCA9IGdldEFwcHMoKS5sZW5ndGggPT09IDAgPyBpbml0aWFsaXplQXBwKGZpcmViYXNlQ29uZmlnKSA6IGdldEFwcHMoKVswXTtcclxuY29uc3QgYXV0aCA9IGdldEF1dGgoYXBwKTtcclxuXHJcbi8vIEluaXRpYWxpemUgQW5hbHl0aWNzIG9ubHkgb24gY2xpZW50IHNpZGVcclxubGV0IGFuYWx5dGljcyA9IG51bGw7XHJcbmlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xyXG4gIGFuYWx5dGljcyA9IGdldEFuYWx5dGljcyhhcHApO1xyXG59XHJcblxyXG5leHBvcnQgeyBhcHAsIGF1dGgsIGFuYWx5dGljcyB9OyAiXSwibmFtZXMiOlsiaW5pdGlhbGl6ZUFwcCIsImdldEFwcHMiLCJnZXRBdXRoIiwiZ2V0QW5hbHl0aWNzIiwiZmlyZWJhc2VDb25maWciLCJhcGlLZXkiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfQVBJX0tFWSIsImF1dGhEb21haW4iLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9BVVRIX0RPTUFJTiIsInByb2plY3RJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX1BST0pFQ1RfSUQiLCJzdG9yYWdlQnVja2V0IiwiTkVYVF9QVUJMSUNfRklSRUJBU0VfU1RPUkFHRV9CVUNLRVQiLCJtZXNzYWdpbmdTZW5kZXJJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX01FU1NBR0lOR19TRU5ERVJfSUQiLCJhcHBJZCIsIk5FWFRfUFVCTElDX0ZJUkVCQVNFX0FQUF9JRCIsIm1lYXN1cmVtZW50SWQiLCJORVhUX1BVQkxJQ19GSVJFQkFTRV9NRUFTVVJFTUVOVF9JRCIsImFwcCIsImxlbmd0aCIsImF1dGgiLCJhbmFseXRpY3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/lib/firebase.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js":
/*!********************************************************************!*\
  !*** ./node_modules/@firebase/analytics/dist/esm/index.esm2017.js ***!
  \********************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalytics: function() { return /* binding */ getAnalytics; },\n/* harmony export */   getGoogleAnalyticsClientId: function() { return /* binding */ getGoogleAnalyticsClientId; },\n/* harmony export */   initializeAnalytics: function() { return /* binding */ initializeAnalytics; },\n/* harmony export */   isSupported: function() { return /* binding */ isSupported; },\n/* harmony export */   logEvent: function() { return /* binding */ logEvent; },\n/* harmony export */   setAnalyticsCollectionEnabled: function() { return /* binding */ setAnalyticsCollectionEnabled; },\n/* harmony export */   setConsent: function() { return /* binding */ setConsent; },\n/* harmony export */   setCurrentScreen: function() { return /* binding */ setCurrentScreen; },\n/* harmony export */   setDefaultEventParameters: function() { return /* binding */ setDefaultEventParameters; },\n/* harmony export */   setUserId: function() { return /* binding */ setUserId; },\n/* harmony export */   setUserProperties: function() { return /* binding */ setUserProperties; },\n/* harmony export */   settings: function() { return /* binding */ settings; }\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(app-pages-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/logger */ \"(app-pages-browser)/./node_modules/@firebase/logger/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(app-pages-browser)/./node_modules/@firebase/util/dist/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @firebase/component */ \"(app-pages-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_installations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @firebase/installations */ \"(app-pages-browser)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\");\n\n\n\n\n\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Type constant for Firebase Analytics.\n */ const ANALYTICS_TYPE = \"analytics\";\n// Key to attach FID to in gtag params.\nconst GA_FID_KEY = \"firebase_id\";\nconst ORIGIN_KEY = \"origin\";\nconst FETCH_TIMEOUT_MILLIS = 60 * 1000;\nconst DYNAMIC_CONFIG_URL = \"https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig\";\nconst GTAG_URL = \"https://www.googletagmanager.com/gtag/js\";\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const logger = new _firebase_logger__WEBPACK_IMPORTED_MODULE_1__.Logger(\"@firebase/analytics\");\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const ERRORS = {\n    [\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */ ]: \"A Firebase Analytics instance with the appId {$id} \" + \" already exists. \" + \"Only one Firebase Analytics instance can be created for each appId.\",\n    [\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */ ]: \"initializeAnalytics() cannot be called again with different options than those \" + \"it was initially called with. It can be called again with the same options to \" + \"return the existing instance, or getAnalytics() can be used \" + \"to get a reference to the already-initialized instance.\",\n    [\"already-initialized-settings\" /* AnalyticsError.ALREADY_INITIALIZED_SETTINGS */ ]: \"Firebase Analytics has already been initialized.\" + \"settings() must be called before initializing any Analytics instance\" + \"or it will have no effect.\",\n    [\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */ ]: \"Firebase Analytics Interop Component failed to instantiate: {$reason}\",\n    [\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */ ]: \"Firebase Analytics is not supported in this environment. \" + \"Wrap initialization of analytics in analytics.isSupported() \" + \"to prevent initialization in unsupported environments. Details: {$errorInfo}\",\n    [\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */ ]: \"IndexedDB unavailable or restricted in this environment. \" + \"Wrap initialization of analytics in analytics.isSupported() \" + \"to prevent initialization in unsupported environments. Details: {$errorInfo}\",\n    [\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */ ]: \"The config fetch request timed out while in an exponential backoff state.\" + \" Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.\",\n    [\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */ ]: \"Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}\",\n    [\"no-api-key\" /* AnalyticsError.NO_API_KEY */ ]: 'The \"apiKey\" field is empty in the local Firebase config. Firebase Analytics requires this field to' + \"contain a valid API key.\",\n    [\"no-app-id\" /* AnalyticsError.NO_APP_ID */ ]: 'The \"appId\" field is empty in the local Firebase config. Firebase Analytics requires this field to' + \"contain a valid app ID.\",\n    [\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */ ]: 'The \"client_id\" field is empty.',\n    [\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */ ]: \"Trusted Types detected an invalid gtag resource: {$gtagURL}.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(\"analytics\", \"Analytics\", ERRORS);\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Verifies and creates a TrustedScriptURL.\n */ function createGtagTrustedTypesScriptURL(url) {\n    if (!url.startsWith(GTAG_URL)) {\n        const err = ERROR_FACTORY.create(\"invalid-gtag-resource\" /* AnalyticsError.INVALID_GTAG_RESOURCE */ , {\n            gtagURL: url\n        });\n        logger.warn(err.message);\n        return \"\";\n    }\n    return url;\n}\n/**\n * Makeshift polyfill for Promise.allSettled(). Resolves when all promises\n * have either resolved or rejected.\n *\n * @param promises Array of promises to wait for.\n */ function promiseAllSettled(promises) {\n    return Promise.all(promises.map((promise)=>promise.catch((e)=>e)));\n}\n/**\n * Creates a TrustedTypePolicy object that implements the rules passed as policyOptions.\n *\n * @param policyName A string containing the name of the policy\n * @param policyOptions Object containing implementations of instance methods for TrustedTypesPolicy, see {@link https://developer.mozilla.org/en-US/docs/Web/API/TrustedTypePolicy#instance_methods\n * | the TrustedTypePolicy reference documentation}.\n */ function createTrustedTypesPolicy(policyName, policyOptions) {\n    // Create a TrustedTypes policy that we can use for updating src\n    // properties\n    let trustedTypesPolicy;\n    if (window.trustedTypes) {\n        trustedTypesPolicy = window.trustedTypes.createPolicy(policyName, policyOptions);\n    }\n    return trustedTypesPolicy;\n}\n/**\n * Inserts gtag script tag into the page to asynchronously download gtag.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */ function insertScriptTag(dataLayerName, measurementId) {\n    const trustedTypesPolicy = createTrustedTypesPolicy(\"firebase-js-sdk-policy\", {\n        createScriptURL: createGtagTrustedTypesScriptURL\n    });\n    const script = document.createElement(\"script\");\n    // We are not providing an analyticsId in the URL because it would trigger a `page_view`\n    // without fid. We will initialize ga-id using gtag (config) command together with fid.\n    const gtagScriptURL = \"\".concat(GTAG_URL, \"?l=\").concat(dataLayerName, \"&id=\").concat(measurementId);\n    script.src = trustedTypesPolicy ? trustedTypesPolicy === null || trustedTypesPolicy === void 0 ? void 0 : trustedTypesPolicy.createScriptURL(gtagScriptURL) : gtagScriptURL;\n    script.async = true;\n    document.head.appendChild(script);\n}\n/**\n * Get reference to, or create, global datalayer.\n * @param dataLayerName Name of datalayer (most often the default, \"_dataLayer\").\n */ function getOrCreateDataLayer(dataLayerName) {\n    // Check for existing dataLayer and create if needed.\n    let dataLayer = [];\n    if (Array.isArray(window[dataLayerName])) {\n        dataLayer = window[dataLayerName];\n    } else {\n        window[dataLayerName] = dataLayer;\n    }\n    return dataLayer;\n}\n/**\n * Wrapped gtag logic when gtag is called with 'config' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param measurementId GA Measurement ID to set config for.\n * @param gtagParams Gtag config params to set.\n */ async function gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams) {\n    // If config is already fetched, we know the appId and can use it to look up what FID promise we\n    /// are waiting for, and wait only on that one.\n    const correspondingAppId = measurementIdToAppId[measurementId];\n    try {\n        if (correspondingAppId) {\n            await initializationPromisesMap[correspondingAppId];\n        } else {\n            // If config is not fetched yet, wait for all configs (we don't know which one we need) and\n            // find the appId (if any) corresponding to this measurementId. If there is one, wait on\n            // that appId's initialization promise. If there is none, promise resolves and gtag\n            // call goes through.\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\n            const foundConfig = dynamicConfigResults.find((config)=>config.measurementId === measurementId);\n            if (foundConfig) {\n                await initializationPromisesMap[foundConfig.appId];\n            }\n        }\n    } catch (e) {\n        logger.error(e);\n    }\n    gtagCore(\"config\" /* GtagCommand.CONFIG */ , measurementId, gtagParams);\n}\n/**\n * Wrapped gtag logic when gtag is called with 'event' command.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementId GA Measurement ID to log event to.\n * @param gtagParams Params to log with this event.\n */ async function gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams) {\n    try {\n        let initializationPromisesToWaitFor = [];\n        // If there's a 'send_to' param, check if any ID specified matches\n        // an initializeIds() promise we are waiting for.\n        if (gtagParams && gtagParams[\"send_to\"]) {\n            let gaSendToList = gtagParams[\"send_to\"];\n            // Make it an array if is isn't, so it can be dealt with the same way.\n            if (!Array.isArray(gaSendToList)) {\n                gaSendToList = [\n                    gaSendToList\n                ];\n            }\n            // Checking 'send_to' fields requires having all measurement ID results back from\n            // the dynamic config fetch.\n            const dynamicConfigResults = await promiseAllSettled(dynamicConfigPromisesList);\n            for (const sendToId of gaSendToList){\n                // Any fetched dynamic measurement ID that matches this 'send_to' ID\n                const foundConfig = dynamicConfigResults.find((config)=>config.measurementId === sendToId);\n                const initializationPromise = foundConfig && initializationPromisesMap[foundConfig.appId];\n                if (initializationPromise) {\n                    initializationPromisesToWaitFor.push(initializationPromise);\n                } else {\n                    // Found an item in 'send_to' that is not associated\n                    // directly with an FID, possibly a group.  Empty this array,\n                    // exit the loop early, and let it get populated below.\n                    initializationPromisesToWaitFor = [];\n                    break;\n                }\n            }\n        }\n        // This will be unpopulated if there was no 'send_to' field , or\n        // if not all entries in the 'send_to' field could be mapped to\n        // a FID. In these cases, wait on all pending initialization promises.\n        if (initializationPromisesToWaitFor.length === 0) {\n            /* eslint-disable-next-line @typescript-eslint/no-floating-promises */ initializationPromisesToWaitFor = Object.values(initializationPromisesMap);\n        }\n        // Run core gtag function with args after all relevant initialization\n        // promises have been resolved.\n        await Promise.all(initializationPromisesToWaitFor);\n        // Workaround for http://b/141370449 - third argument cannot be undefined.\n        gtagCore(\"event\" /* GtagCommand.EVENT */ , measurementId, gtagParams || {});\n    } catch (e) {\n        logger.error(e);\n    }\n}\n/**\n * Wraps a standard gtag function with extra code to wait for completion of\n * relevant initialization promises before sending requests.\n *\n * @param gtagCore Basic gtag function that just appends to dataLayer.\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n */ function wrapGtag(gtagCore, /**\n * Allows wrapped gtag calls to wait on whichever initialization promises are required,\n * depending on the contents of the gtag params' `send_to` field, if any.\n */ initializationPromisesMap, /**\n * Wrapped gtag calls sometimes require all dynamic config fetches to have returned\n * before determining what initialization promises (which include FIDs) to wait for.\n */ dynamicConfigPromisesList, /**\n * Wrapped gtag config calls can narrow down which initialization promise (with FID)\n * to wait for if the measurementId is already fetched, by getting the corresponding appId,\n * which is the key for the initialization promises map.\n */ measurementIdToAppId) {\n    /**\n     * Wrapper around gtag that ensures FID is sent with gtag calls.\n     * @param command Gtag command type.\n     * @param idOrNameOrParams Measurement ID if command is EVENT/CONFIG, params if command is SET.\n     * @param gtagParams Params if event is EVENT/CONFIG.\n     */ async function gtagWrapper(command) {\n        for(var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){\n            args[_key - 1] = arguments[_key];\n        }\n        try {\n            // If event, check that relevant initialization promises have completed.\n            if (command === \"event\" /* GtagCommand.EVENT */ ) {\n                const [measurementId, gtagParams] = args;\n                // If EVENT, second arg must be measurementId.\n                await gtagOnEvent(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementId, gtagParams);\n            } else if (command === \"config\" /* GtagCommand.CONFIG */ ) {\n                const [measurementId, gtagParams] = args;\n                // If CONFIG, second arg must be measurementId.\n                await gtagOnConfig(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, measurementId, gtagParams);\n            } else if (command === \"consent\" /* GtagCommand.CONSENT */ ) {\n                const [consentAction, gtagParams] = args;\n                // consentAction can be one of 'default' or 'update'.\n                gtagCore(\"consent\" /* GtagCommand.CONSENT */ , consentAction, gtagParams);\n            } else if (command === \"get\" /* GtagCommand.GET */ ) {\n                const [measurementId, fieldName, callback] = args;\n                gtagCore(\"get\" /* GtagCommand.GET */ , measurementId, fieldName, callback);\n            } else if (command === \"set\" /* GtagCommand.SET */ ) {\n                const [customParams] = args;\n                // If SET, second arg must be params.\n                gtagCore(\"set\" /* GtagCommand.SET */ , customParams);\n            } else {\n                gtagCore(command, ...args);\n            }\n        } catch (e) {\n            logger.error(e);\n        }\n    }\n    return gtagWrapper;\n}\n/**\n * Creates global gtag function or wraps existing one if found.\n * This wrapped function attaches Firebase instance ID (FID) to gtag 'config' and\n * 'event' calls that belong to the GAID associated with this Firebase instance.\n *\n * @param initializationPromisesMap Map of appIds to their initialization promises.\n * @param dynamicConfigPromisesList Array of dynamic config fetch promises.\n * @param measurementIdToAppId Map of GA measurementIDs to corresponding Firebase appId.\n * @param dataLayerName Name of global GA datalayer array.\n * @param gtagFunctionName Name of global gtag function (\"gtag\" if not user-specified).\n */ function wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagFunctionName) {\n    // Create a basic core gtag function\n    let gtagCore = function() {\n        for(var _len = arguments.length, _args = new Array(_len), _key = 0; _key < _len; _key++){\n            _args[_key] = arguments[_key];\n        }\n        // Must push IArguments object, not an array.\n        window[dataLayerName].push(arguments);\n    };\n    // Replace it with existing one if found\n    if (window[gtagFunctionName] && typeof window[gtagFunctionName] === \"function\") {\n        // @ts-ignore\n        gtagCore = window[gtagFunctionName];\n    }\n    window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId);\n    return {\n        gtagCore,\n        wrappedGtag: window[gtagFunctionName]\n    };\n}\n/**\n * Returns the script tag in the DOM matching both the gtag url pattern\n * and the provided data layer name.\n */ function findGtagScriptOnPage(dataLayerName) {\n    const scriptTags = window.document.getElementsByTagName(\"script\");\n    for (const tag of Object.values(scriptTags)){\n        if (tag.src && tag.src.includes(GTAG_URL) && tag.src.includes(dataLayerName)) {\n            return tag;\n        }\n    }\n    return null;\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Backoff factor for 503 errors, which we want to be conservative about\n * to avoid overloading servers. Each retry interval will be\n * BASE_INTERVAL_MILLIS * LONG_RETRY_FACTOR ^ retryCount, so the second one\n * will be ~30 seconds (with fuzzing).\n */ const LONG_RETRY_FACTOR = 30;\n/**\n * Base wait interval to multiplied by backoffFactor^backoffCount.\n */ const BASE_INTERVAL_MILLIS = 1000;\n/**\n * Stubbable retry data storage class.\n */ class RetryData {\n    getThrottleMetadata(appId) {\n        return this.throttleMetadata[appId];\n    }\n    setThrottleMetadata(appId, metadata) {\n        this.throttleMetadata[appId] = metadata;\n    }\n    deleteThrottleMetadata(appId) {\n        delete this.throttleMetadata[appId];\n    }\n    constructor(throttleMetadata = {}, intervalMillis = BASE_INTERVAL_MILLIS){\n        this.throttleMetadata = throttleMetadata;\n        this.intervalMillis = intervalMillis;\n    }\n}\nconst defaultRetryData = new RetryData();\n/**\n * Set GET request headers.\n * @param apiKey App API key.\n */ function getHeaders(apiKey) {\n    return new Headers({\n        Accept: \"application/json\",\n        \"x-goog-api-key\": apiKey\n    });\n}\n/**\n * Fetches dynamic config from backend.\n * @param app Firebase app to fetch config for.\n */ async function fetchDynamicConfig(appFields) {\n    var _a;\n    const { appId, apiKey } = appFields;\n    const request = {\n        method: \"GET\",\n        headers: getHeaders(apiKey)\n    };\n    const appUrl = DYNAMIC_CONFIG_URL.replace(\"{app-id}\", appId);\n    const response = await fetch(appUrl, request);\n    if (response.status !== 200 && response.status !== 304) {\n        let errorMessage = \"\";\n        try {\n            // Try to get any error message text from server response.\n            const jsonResponse = await response.json();\n            if ((_a = jsonResponse.error) === null || _a === void 0 ? void 0 : _a.message) {\n                errorMessage = jsonResponse.error.message;\n            }\n        } catch (_ignored) {}\n        throw ERROR_FACTORY.create(\"config-fetch-failed\" /* AnalyticsError.CONFIG_FETCH_FAILED */ , {\n            httpStatus: response.status,\n            responseMessage: errorMessage\n        });\n    }\n    return response.json();\n}\n/**\n * Fetches dynamic config from backend, retrying if failed.\n * @param app Firebase app to fetch config for.\n */ async function fetchDynamicConfigWithRetry(app) {\n    let // retryData and timeoutMillis are parameterized to allow passing a different value for testing.\n    retryData = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultRetryData, timeoutMillis = arguments.length > 2 ? arguments[2] : void 0;\n    const { appId, apiKey, measurementId } = app.options;\n    if (!appId) {\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */ );\n    }\n    if (!apiKey) {\n        if (measurementId) {\n            return {\n                measurementId,\n                appId\n            };\n        }\n        throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */ );\n    }\n    const throttleMetadata = retryData.getThrottleMetadata(appId) || {\n        backoffCount: 0,\n        throttleEndTimeMillis: Date.now()\n    };\n    const signal = new AnalyticsAbortSignal();\n    setTimeout(async ()=>{\n        // Note a very low delay, eg < 10ms, can elapse before listeners are initialized.\n        signal.abort();\n    }, timeoutMillis !== undefined ? timeoutMillis : FETCH_TIMEOUT_MILLIS);\n    return attemptFetchDynamicConfigWithRetry({\n        appId,\n        apiKey,\n        measurementId\n    }, throttleMetadata, signal, retryData);\n}\n/**\n * Runs one retry attempt.\n * @param appFields Necessary app config fields.\n * @param throttleMetadata Ongoing metadata to determine throttling times.\n * @param signal Abort signal.\n */ async function attemptFetchDynamicConfigWithRetry(appFields, param, signal) {\n    let { throttleEndTimeMillis, backoffCount } = param, retryData = arguments.length > 3 && arguments[3] !== void 0 // for testing\n     ? arguments[3] : defaultRetryData;\n    var _a;\n    const { appId, measurementId } = appFields;\n    // Starts with a (potentially zero) timeout to support resumption from stored state.\n    // Ensures the throttle end time is honored if the last attempt timed out.\n    // Note the SDK will never make a request if the fetch timeout expires at this point.\n    try {\n        await setAbortableTimeout(signal, throttleEndTimeMillis);\n    } catch (e) {\n        if (measurementId) {\n            logger.warn(\"Timed out fetching this Firebase app's measurement ID from the server.\" + \" Falling back to the measurement ID \".concat(measurementId) + ' provided in the \"measurementId\" field in the local Firebase config. ['.concat(e === null || e === void 0 ? void 0 : e.message, \"]\"));\n            return {\n                appId,\n                measurementId\n            };\n        }\n        throw e;\n    }\n    try {\n        const response = await fetchDynamicConfig(appFields);\n        // Note the SDK only clears throttle state if response is success or non-retriable.\n        retryData.deleteThrottleMetadata(appId);\n        return response;\n    } catch (e) {\n        const error = e;\n        if (!isRetriableError(error)) {\n            retryData.deleteThrottleMetadata(appId);\n            if (measurementId) {\n                logger.warn(\"Failed to fetch this Firebase app's measurement ID from the server.\" + \" Falling back to the measurement ID \".concat(measurementId) + ' provided in the \"measurementId\" field in the local Firebase config. ['.concat(error === null || error === void 0 ? void 0 : error.message, \"]\"));\n                return {\n                    appId,\n                    measurementId\n                };\n            } else {\n                throw e;\n            }\n        }\n        const backoffMillis = Number((_a = error === null || error === void 0 ? void 0 : error.customData) === null || _a === void 0 ? void 0 : _a.httpStatus) === 503 ? (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.calculateBackoffMillis)(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.calculateBackoffMillis)(backoffCount, retryData.intervalMillis);\n        // Increments backoff state.\n        const throttleMetadata = {\n            throttleEndTimeMillis: Date.now() + backoffMillis,\n            backoffCount: backoffCount + 1\n        };\n        // Persists state.\n        retryData.setThrottleMetadata(appId, throttleMetadata);\n        logger.debug(\"Calling attemptFetch again in \".concat(backoffMillis, \" millis\"));\n        return attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData);\n    }\n}\n/**\n * Supports waiting on a backoff by:\n *\n * <ul>\n *   <li>Promisifying setTimeout, so we can set a timeout in our Promise chain</li>\n *   <li>Listening on a signal bus for abort events, just like the Fetch API</li>\n *   <li>Failing in the same way the Fetch API fails, so timing out a live request and a throttled\n *       request appear the same.</li>\n * </ul>\n *\n * <p>Visible for testing.\n */ function setAbortableTimeout(signal, throttleEndTimeMillis) {\n    return new Promise((resolve, reject)=>{\n        // Derives backoff from given end time, normalizing negative numbers to zero.\n        const backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);\n        const timeout = setTimeout(resolve, backoffMillis);\n        // Adds listener, rather than sets onabort, because signal is a shared object.\n        signal.addEventListener(()=>{\n            clearTimeout(timeout);\n            // If the request completes before this timeout, the rejection has no effect.\n            reject(ERROR_FACTORY.create(\"fetch-throttle\" /* AnalyticsError.FETCH_THROTTLE */ , {\n                throttleEndTimeMillis\n            }));\n        });\n    });\n}\n/**\n * Returns true if the {@link Error} indicates a fetch request may succeed later.\n */ function isRetriableError(e) {\n    if (!(e instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError) || !e.customData) {\n        return false;\n    }\n    // Uses string index defined by ErrorData, which FirebaseError implements.\n    const httpStatus = Number(e.customData[\"httpStatus\"]);\n    return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;\n}\n/**\n * Shims a minimal AbortSignal (copied from Remote Config).\n *\n * <p>AbortController's AbortSignal conveniently decouples fetch timeout logic from other aspects\n * of networking, such as retries. Firebase doesn't use AbortController enough to justify a\n * polyfill recommendation, like we do with the Fetch API, but this minimal shim can easily be\n * swapped out if/when we do.\n */ class AnalyticsAbortSignal {\n    addEventListener(listener) {\n        this.listeners.push(listener);\n    }\n    abort() {\n        this.listeners.forEach((listener)=>listener());\n    }\n    constructor(){\n        this.listeners = [];\n    }\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Event parameters to set on 'gtag' during initialization.\n */ let defaultEventParametersForInit;\n/**\n * Logs an analytics event through the Firebase SDK.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param eventName Google Analytics event name, choose from standard list or use a custom string.\n * @param eventParams Analytics event parameters.\n */ async function logEvent$1(gtagFunction, initializationPromise, eventName, eventParams, options) {\n    if (options && options.global) {\n        gtagFunction(\"event\" /* GtagCommand.EVENT */ , eventName, eventParams);\n        return;\n    } else {\n        const measurementId = await initializationPromise;\n        const params = Object.assign(Object.assign({}, eventParams), {\n            \"send_to\": measurementId\n        });\n        gtagFunction(\"event\" /* GtagCommand.EVENT */ , eventName, params);\n    }\n}\n/**\n * Set screen_name parameter for this Google Analytics ID.\n *\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param screenName Screen name string to set.\n */ async function setCurrentScreen$1(gtagFunction, initializationPromise, screenName, options) {\n    if (options && options.global) {\n        gtagFunction(\"set\" /* GtagCommand.SET */ , {\n            \"screen_name\": screenName\n        });\n        return Promise.resolve();\n    } else {\n        const measurementId = await initializationPromise;\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */ , measurementId, {\n            update: true,\n            \"screen_name\": screenName\n        });\n    }\n}\n/**\n * Set user_id parameter for this Google Analytics ID.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param id User ID string to set\n */ async function setUserId$1(gtagFunction, initializationPromise, id, options) {\n    if (options && options.global) {\n        gtagFunction(\"set\" /* GtagCommand.SET */ , {\n            \"user_id\": id\n        });\n        return Promise.resolve();\n    } else {\n        const measurementId = await initializationPromise;\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */ , measurementId, {\n            update: true,\n            \"user_id\": id\n        });\n    }\n}\n/**\n * Set all other user properties other than user_id and screen_name.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n * @param properties Map of user properties to set\n */ async function setUserProperties$1(gtagFunction, initializationPromise, properties, options) {\n    if (options && options.global) {\n        const flatProperties = {};\n        for (const key of Object.keys(properties)){\n            // use dot notation for merge behavior in gtag.js\n            flatProperties[\"user_properties.\".concat(key)] = properties[key];\n        }\n        gtagFunction(\"set\" /* GtagCommand.SET */ , flatProperties);\n        return Promise.resolve();\n    } else {\n        const measurementId = await initializationPromise;\n        gtagFunction(\"config\" /* GtagCommand.CONFIG */ , measurementId, {\n            update: true,\n            \"user_properties\": properties\n        });\n    }\n}\n/**\n * Retrieves a unique Google Analytics identifier for the web client.\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\n *\n * @param gtagFunction Wrapped gtag function that waits for fid to be set before sending an event\n */ async function internalGetGoogleAnalyticsClientId(gtagFunction, initializationPromise) {\n    const measurementId = await initializationPromise;\n    return new Promise((resolve, reject)=>{\n        gtagFunction(\"get\" /* GtagCommand.GET */ , measurementId, \"client_id\", (clientId)=>{\n            if (!clientId) {\n                reject(ERROR_FACTORY.create(\"no-client-id\" /* AnalyticsError.NO_CLIENT_ID */ ));\n            }\n            resolve(clientId);\n        });\n    });\n}\n/**\n * Set whether collection is enabled for this ID.\n *\n * @param enabled If true, collection is enabled for this ID.\n */ async function setAnalyticsCollectionEnabled$1(initializationPromise, enabled) {\n    const measurementId = await initializationPromise;\n    window[\"ga-disable-\".concat(measurementId)] = !enabled;\n}\n/**\n * Consent parameters to default to during 'gtag' initialization.\n */ let defaultConsentSettingsForInit;\n/**\n * Sets the variable {@link defaultConsentSettingsForInit} for use in the initialization of\n * analytics.\n *\n * @param consentSettings Maps the applicable end user consent state for gtag.js.\n */ function _setConsentDefaultForInit(consentSettings) {\n    defaultConsentSettingsForInit = consentSettings;\n}\n/**\n * Sets the variable `defaultEventParametersForInit` for use in the initialization of\n * analytics.\n *\n * @param customParams Any custom params the user may pass to gtag.js.\n */ function _setDefaultEventParametersForInit(customParams) {\n    defaultEventParametersForInit = customParams;\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ async function validateIndexedDB() {\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n        logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */ , {\n            errorInfo: \"IndexedDB is not available in this environment.\"\n        }).message);\n        return false;\n    } else {\n        try {\n            await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)();\n        } catch (e) {\n            logger.warn(ERROR_FACTORY.create(\"indexeddb-unavailable\" /* AnalyticsError.INDEXEDDB_UNAVAILABLE */ , {\n                errorInfo: e === null || e === void 0 ? void 0 : e.toString()\n            }).message);\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Initialize the analytics instance in gtag.js by calling config command with fid.\n *\n * NOTE: We combine analytics initialization and setting fid together because we want fid to be\n * part of the `page_view` event that's sent during the initialization\n * @param app Firebase app\n * @param gtagCore The gtag function that's not wrapped.\n * @param dynamicConfigPromisesList Array of all dynamic config promises.\n * @param measurementIdToAppId Maps measurementID to appID.\n * @param installations _FirebaseInstallationsInternal instance.\n *\n * @returns Measurement ID.\n */ async function _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCore, dataLayerName, options) {\n    var _a;\n    const dynamicConfigPromise = fetchDynamicConfigWithRetry(app);\n    // Once fetched, map measurementIds to appId, for ease of lookup in wrapped gtag function.\n    dynamicConfigPromise.then((config)=>{\n        measurementIdToAppId[config.measurementId] = config.appId;\n        if (app.options.measurementId && config.measurementId !== app.options.measurementId) {\n            logger.warn(\"The measurement ID in the local Firebase config (\".concat(app.options.measurementId, \")\") + \" does not match the measurement ID fetched from the server (\".concat(config.measurementId, \").\") + \" To ensure analytics events are always sent to the correct Analytics property,\" + \" update the\" + \" measurement ID field in the local config or remove it from the local config.\");\n        }\n    }).catch((e)=>logger.error(e));\n    // Add to list to track state of all dynamic config promises.\n    dynamicConfigPromisesList.push(dynamicConfigPromise);\n    const fidPromise = validateIndexedDB().then((envIsValid)=>{\n        if (envIsValid) {\n            return installations.getId();\n        } else {\n            return undefined;\n        }\n    });\n    const [dynamicConfig, fid] = await Promise.all([\n        dynamicConfigPromise,\n        fidPromise\n    ]);\n    // Detect if user has already put the gtag <script> tag on this page with the passed in\n    // data layer name.\n    if (!findGtagScriptOnPage(dataLayerName)) {\n        insertScriptTag(dataLayerName, dynamicConfig.measurementId);\n    }\n    // Detects if there are consent settings that need to be configured.\n    if (defaultConsentSettingsForInit) {\n        gtagCore(\"consent\" /* GtagCommand.CONSENT */ , \"default\", defaultConsentSettingsForInit);\n        _setConsentDefaultForInit(undefined);\n    }\n    // This command initializes gtag.js and only needs to be called once for the entire web app,\n    // but since it is idempotent, we can call it multiple times.\n    // We keep it together with other initialization logic for better code structure.\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    gtagCore(\"js\", new Date());\n    // User config added first. We don't want users to accidentally overwrite\n    // base Firebase config properties.\n    const configProperties = (_a = options === null || options === void 0 ? void 0 : options.config) !== null && _a !== void 0 ? _a : {};\n    // guard against developers accidentally setting properties with prefix `firebase_`\n    configProperties[ORIGIN_KEY] = \"firebase\";\n    configProperties.update = true;\n    if (fid != null) {\n        configProperties[GA_FID_KEY] = fid;\n    }\n    // It should be the first config command called on this GA-ID\n    // Initialize this GA-ID and set FID on it using the gtag config API.\n    // Note: This will trigger a page_view event unless 'send_page_view' is set to false in\n    // `configProperties`.\n    gtagCore(\"config\" /* GtagCommand.CONFIG */ , dynamicConfig.measurementId, configProperties);\n    // Detects if there is data that will be set on every event logged from the SDK.\n    if (defaultEventParametersForInit) {\n        gtagCore(\"set\" /* GtagCommand.SET */ , defaultEventParametersForInit);\n        _setDefaultEventParametersForInit(undefined);\n    }\n    return dynamicConfig.measurementId;\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Analytics Service class.\n */ class AnalyticsService {\n    _delete() {\n        delete initializationPromisesMap[this.app.options.appId];\n        return Promise.resolve();\n    }\n    constructor(app){\n        this.app = app;\n    }\n}\n/**\n * Maps appId to full initialization promise. Wrapped gtag calls must wait on\n * all or some of these, depending on the call's `send_to` param and the status\n * of the dynamic config fetches (see below).\n */ let initializationPromisesMap = {};\n/**\n * List of dynamic config fetch promises. In certain cases, wrapped gtag calls\n * wait on all these to be complete in order to determine if it can selectively\n * wait for only certain initialization (FID) promises or if it must wait for all.\n */ let dynamicConfigPromisesList = [];\n/**\n * Maps fetched measurementIds to appId. Populated when the app's dynamic config\n * fetch completes. If already populated, gtag config calls can use this to\n * selectively wait for only this app's initialization promise (FID) instead of all\n * initialization promises.\n */ const measurementIdToAppId = {};\n/**\n * Name for window global data layer array used by GA: defaults to 'dataLayer'.\n */ let dataLayerName = \"dataLayer\";\n/**\n * Name for window global gtag function used by GA: defaults to 'gtag'.\n */ let gtagName = \"gtag\";\n/**\n * Reproduction of standard gtag function or reference to existing\n * gtag function on window object.\n */ let gtagCoreFunction;\n/**\n * Wrapper around gtag function that ensures FID is sent with all\n * relevant event and config calls.\n */ let wrappedGtagFunction;\n/**\n * Flag to ensure page initialization steps (creation or wrapping of\n * dataLayer and gtag script) are only run once per page load.\n */ let globalInitDone = false;\n/**\n * Configures Firebase Analytics to use custom `gtag` or `dataLayer` names.\n * Intended to be used if `gtag.js` script has been installed on\n * this page independently of Firebase Analytics, and is using non-default\n * names for either the `gtag` function or for `dataLayer`.\n * Must be called before calling `getAnalytics()` or it won't\n * have any effect.\n *\n * @public\n *\n * @param options - Custom gtag and dataLayer names.\n */ function settings(options) {\n    if (globalInitDone) {\n        throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */ );\n    }\n    if (options.dataLayerName) {\n        dataLayerName = options.dataLayerName;\n    }\n    if (options.gtagName) {\n        gtagName = options.gtagName;\n    }\n}\n/**\n * Returns true if no environment mismatch is found.\n * If environment mismatches are found, throws an INVALID_ANALYTICS_CONTEXT\n * error that also lists details for each mismatch found.\n */ function warnOnBrowserContextMismatch() {\n    const mismatchedEnvMessages = [];\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowserExtension)()) {\n        mismatchedEnvMessages.push(\"This is a browser extension environment.\");\n    }\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.areCookiesEnabled)()) {\n        mismatchedEnvMessages.push(\"Cookies are not available.\");\n    }\n    if (mismatchedEnvMessages.length > 0) {\n        const details = mismatchedEnvMessages.map((message, index)=>\"(\".concat(index + 1, \") \").concat(message)).join(\" \");\n        const err = ERROR_FACTORY.create(\"invalid-analytics-context\" /* AnalyticsError.INVALID_ANALYTICS_CONTEXT */ , {\n            errorInfo: details\n        });\n        logger.warn(err.message);\n    }\n}\n/**\n * Analytics instance factory.\n * @internal\n */ function factory(app, installations, options) {\n    warnOnBrowserContextMismatch();\n    const appId = app.options.appId;\n    if (!appId) {\n        throw ERROR_FACTORY.create(\"no-app-id\" /* AnalyticsError.NO_APP_ID */ );\n    }\n    if (!app.options.apiKey) {\n        if (app.options.measurementId) {\n            logger.warn('The \"apiKey\" field is empty in the local Firebase config. This is needed to fetch the latest' + \" measurement ID for this Firebase app. Falling back to the measurement ID \".concat(app.options.measurementId) + ' provided in the \"measurementId\" field in the local Firebase config.');\n        } else {\n            throw ERROR_FACTORY.create(\"no-api-key\" /* AnalyticsError.NO_API_KEY */ );\n        }\n    }\n    if (initializationPromisesMap[appId] != null) {\n        throw ERROR_FACTORY.create(\"already-exists\" /* AnalyticsError.ALREADY_EXISTS */ , {\n            id: appId\n        });\n    }\n    if (!globalInitDone) {\n        // Steps here should only be done once per page: creation or wrapping\n        // of dataLayer and global gtag function.\n        getOrCreateDataLayer(dataLayerName);\n        const { wrappedGtag, gtagCore } = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName);\n        wrappedGtagFunction = wrappedGtag;\n        gtagCoreFunction = gtagCore;\n        globalInitDone = true;\n    }\n    // Async but non-blocking.\n    // This map reflects the completion state of all promises for each appId.\n    initializationPromisesMap[appId] = _initializeAnalytics(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName, options);\n    const analyticsInstance = new AnalyticsService(app);\n    return analyticsInstance;\n}\n/* eslint-disable @typescript-eslint/no-explicit-any */ /**\n * Returns an {@link Analytics} instance for the given app.\n *\n * @public\n *\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\n */ function getAnalytics() {\n    let app = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    app = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(app);\n    // Dependencies\n    const analyticsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, ANALYTICS_TYPE);\n    if (analyticsProvider.isInitialized()) {\n        return analyticsProvider.getImmediate();\n    }\n    return initializeAnalytics(app);\n}\n/**\n * Returns an {@link Analytics} instance for the given app.\n *\n * @public\n *\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\n */ function initializeAnalytics(app) {\n    let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    // Dependencies\n    const analyticsProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, ANALYTICS_TYPE);\n    if (analyticsProvider.isInitialized()) {\n        const existingInstance = analyticsProvider.getImmediate();\n        if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.deepEqual)(options, analyticsProvider.getOptions())) {\n            return existingInstance;\n        } else {\n            throw ERROR_FACTORY.create(\"already-initialized\" /* AnalyticsError.ALREADY_INITIALIZED */ );\n        }\n    }\n    const analyticsInstance = analyticsProvider.initialize({\n        options\n    });\n    return analyticsInstance;\n}\n/**\n * This is a public static method provided to users that wraps four different checks:\n *\n * 1. Check if it's not a browser extension environment.\n * 2. Check if cookies are enabled in current browser.\n * 3. Check if IndexedDB is supported by the browser environment.\n * 4. Check if the current browser context is valid for using `IndexedDB.open()`.\n *\n * @public\n *\n */ async function isSupported() {\n    if ((0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isBrowserExtension)()) {\n        return false;\n    }\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.areCookiesEnabled)()) {\n        return false;\n    }\n    if (!(0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.isIndexedDBAvailable)()) {\n        return false;\n    }\n    try {\n        const isDBOpenable = await (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.validateIndexedDBOpenable)();\n        return isDBOpenable;\n    } catch (error) {\n        return false;\n    }\n}\n/**\n * Use gtag `config` command to set `screen_name`.\n *\n * @public\n *\n * @deprecated Use {@link logEvent} with `eventName` as 'screen_view' and add relevant `eventParams`.\n * See {@link https://firebase.google.com/docs/analytics/screenviews | Track Screenviews}.\n *\n * @param analyticsInstance - The {@link Analytics} instance.\n * @param screenName - Screen name to set.\n */ function setCurrentScreen(analyticsInstance, screenName, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setCurrentScreen$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], screenName, options).catch((e)=>logger.error(e));\n}\n/**\n * Retrieves a unique Google Analytics identifier for the web client.\n * See {@link https://developers.google.com/analytics/devguides/collection/ga4/reference/config#client_id | client_id}.\n *\n * @public\n *\n * @param app - The {@link @firebase/app#FirebaseApp} to use.\n */ async function getGoogleAnalyticsClientId(analyticsInstance) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    return internalGetGoogleAnalyticsClientId(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId]);\n}\n/**\n * Use gtag `config` command to set `user_id`.\n *\n * @public\n *\n * @param analyticsInstance - The {@link Analytics} instance.\n * @param id - User ID to set.\n */ function setUserId(analyticsInstance, id, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setUserId$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], id, options).catch((e)=>logger.error(e));\n}\n/**\n * Use gtag `config` command to set all params specified.\n *\n * @public\n */ function setUserProperties(analyticsInstance, properties, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setUserProperties$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], properties, options).catch((e)=>logger.error(e));\n}\n/**\n * Sets whether Google Analytics collection is enabled for this app on this device.\n * Sets global `window['ga-disable-analyticsId'] = true;`\n *\n * @public\n *\n * @param analyticsInstance - The {@link Analytics} instance.\n * @param enabled - If true, enables collection, if false, disables it.\n */ function setAnalyticsCollectionEnabled(analyticsInstance, enabled) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    setAnalyticsCollectionEnabled$1(initializationPromisesMap[analyticsInstance.app.options.appId], enabled).catch((e)=>logger.error(e));\n}\n/**\n * Adds data that will be set on every event logged from the SDK, including automatic ones.\n * With gtag's \"set\" command, the values passed persist on the current page and are passed with\n * all subsequent events.\n * @public\n * @param customParams - Any custom params the user may pass to gtag.js.\n */ function setDefaultEventParameters(customParams) {\n    // Check if reference to existing gtag function on window object exists\n    if (wrappedGtagFunction) {\n        wrappedGtagFunction(\"set\" /* GtagCommand.SET */ , customParams);\n    } else {\n        _setDefaultEventParametersForInit(customParams);\n    }\n}\n/**\n * Sends a Google Analytics event with given `eventParams`. This method\n * automatically associates this logged event with this Firebase web\n * app instance on this device.\n * List of official event parameters can be found in the gtag.js\n * reference documentation:\n * {@link https://developers.google.com/gtagjs/reference/ga4-events\n * | the GA4 reference documentation}.\n *\n * @public\n */ function logEvent(analyticsInstance, eventName, eventParams, options) {\n    analyticsInstance = (0,_firebase_util__WEBPACK_IMPORTED_MODULE_2__.getModularInstance)(analyticsInstance);\n    logEvent$1(wrappedGtagFunction, initializationPromisesMap[analyticsInstance.app.options.appId], eventName, eventParams, options).catch((e)=>logger.error(e));\n}\n/**\n * Sets the applicable end user consent state for this web app across all gtag references once\n * Firebase Analytics is initialized.\n *\n * Use the {@link ConsentSettings} to specify individual consent type values. By default consent\n * types are set to \"granted\".\n * @public\n * @param consentSettings - Maps the applicable end user consent state for gtag.js.\n */ function setConsent(consentSettings) {\n    // Check if reference to existing gtag function on window object exists\n    if (wrappedGtagFunction) {\n        wrappedGtagFunction(\"consent\" /* GtagCommand.CONSENT */ , \"update\", consentSettings);\n    } else {\n        _setConsentDefaultForInit(consentSettings);\n    }\n}\nconst name = \"@firebase/analytics\";\nconst version = \"0.10.12\";\n/**\n * The Firebase Analytics Web SDK.\n * This SDK does not work in a Node.js environment.\n *\n * @packageDocumentation\n */ function registerAnalytics() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component(ANALYTICS_TYPE, (container, param)=>{\n        let { options: analyticsOptions } = param;\n        // getImmediate for FirebaseApp will always succeed\n        const app = container.getProvider(\"app\").getImmediate();\n        const installations = container.getProvider(\"installations-internal\").getImmediate();\n        return factory(app, installations, analyticsOptions);\n    }, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_3__.Component(\"analytics-internal\", internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n    // BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, \"esm2017\");\n    function internalFactory(container) {\n        try {\n            const analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();\n            return {\n                logEvent: (eventName, eventParams, options)=>logEvent(analytics, eventName, eventParams, options)\n            };\n        } catch (e) {\n            throw ERROR_FACTORY.create(\"interop-component-reg-failed\" /* AnalyticsError.INTEROP_COMPONENT_REG_FAILED */ , {\n                reason: e\n            });\n        }\n    }\n}\nregisterAnalytics();\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvYW5hbHl0aWNzL2Rpc3QvZXNtL2luZGV4LmVzbTIwMTcuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBMEY7QUFDaEQ7QUFDa0s7QUFDNUo7QUFDZjtBQUVqQzs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRDs7Q0FFQyxHQUNELE1BQU1lLGlCQUFpQjtBQUN2Qix1Q0FBdUM7QUFDdkMsTUFBTUMsYUFBYTtBQUNuQixNQUFNQyxhQUFhO0FBQ25CLE1BQU1DLHVCQUF1QixLQUFLO0FBQ2xDLE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxXQUFXO0FBRWpCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1DLFNBQVMsSUFBSWpCLG9EQUFNQSxDQUFDO0FBRTFCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1rQixTQUFTO0lBQ1gsQ0FBQyxpQkFBaUIsaUNBQWlDLElBQUcsRUFBRSx3REFDcEQsc0JBQ0E7SUFDSixDQUFDLHNCQUFzQixzQ0FBc0MsSUFBRyxFQUFFLG9GQUM5RCxtRkFDQSxpRUFDQTtJQUNKLENBQUMsK0JBQStCLCtDQUErQyxJQUFHLEVBQUUscURBQ2hGLHlFQUNBO0lBQ0osQ0FBQywrQkFBK0IsK0NBQStDLElBQUcsRUFBRTtJQUNwRixDQUFDLDRCQUE0Qiw0Q0FBNEMsSUFBRyxFQUFFLDhEQUMxRSxpRUFDQTtJQUNKLENBQUMsd0JBQXdCLHdDQUF3QyxJQUFHLEVBQUUsOERBQ2xFLGlFQUNBO0lBQ0osQ0FBQyxpQkFBaUIsaUNBQWlDLElBQUcsRUFBRSw4RUFDcEQ7SUFDSixDQUFDLHNCQUFzQixzQ0FBc0MsSUFBRyxFQUFFO0lBQ2xFLENBQUMsYUFBYSw2QkFBNkIsSUFBRyxFQUFFLHdHQUM1QztJQUNKLENBQUMsWUFBWSw0QkFBNEIsSUFBRyxFQUFFLHVHQUMxQztJQUNKLENBQUMsZUFBZSwrQkFBK0IsSUFBRyxFQUFFO0lBQ3BELENBQUMs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UUFDdEYsbURBQW1EO1FBQ25ELE1BQU16RyxNQUFNd0csVUFBVUUsV0FBVyxDQUFDLE9BQU9wQixZQUFZO1FBQ3JELE1BQU0xQixnQkFBZ0I0QyxVQUNqQkUsV0FBVyxDQUFDLDBCQUNacEIsWUFBWTtRQUNqQixPQUFPTCxRQUFRakYsS0FBSzRELGVBQWU2QztJQUN2QyxHQUFHLFNBQVMsd0JBQXdCO0lBQ3BDL08saUVBQWtCQSxDQUFDLElBQUlZLDBEQUFTQSxDQUFDLHNCQUFzQnFPLGlCQUFpQixVQUFVLHlCQUF5QjtJQUMzR2hQLDhEQUFlQSxDQUFDME8sTUFBTUM7SUFDdEIsNEZBQTRGO0lBQzVGM08sOERBQWVBLENBQUMwTyxNQUFNQyxTQUFTO0lBQy9CLFNBQVNLLGdCQUFnQkgsU0FBUztRQUM5QixJQUFJO1lBQ0EsTUFBTUksWUFBWUosVUFBVUUsV0FBVyxDQUFDbk8sZ0JBQWdCK00sWUFBWTtZQUNwRSxPQUFPO2dCQUNIYSxVQUFVLENBQUNsRSxXQUFXQyxhQUFhL0IsVUFBWWdHLFNBQVNTLFdBQVczRSxXQUFXQyxhQUFhL0I7WUFDL0Y7UUFDSixFQUNBLE9BQU9wRyxHQUFHO1lBQ04sTUFBTWhCLGNBQWNLLE1BQU0sQ0FBQywrQkFBK0IsK0NBQStDLEtBQUk7Z0JBQ3pHeU4sUUFBUTlNO1lBQ1o7UUFDSjtJQUNKO0FBQ0o7QUFDQXdNO0FBRWdPLENBQ2hPLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2FuYWx5dGljcy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzPzVlZmQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgX2dldFByb3ZpZGVyLCBnZXRBcHAsIF9yZWdpc3RlckNvbXBvbmVudCwgcmVnaXN0ZXJWZXJzaW9uIH0gZnJvbSAnQGZpcmViYXNlL2FwcCc7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tICdAZmlyZWJhc2UvbG9nZ2VyJztcbmltcG9ydCB7IEVycm9yRmFjdG9yeSwgY2FsY3VsYXRlQmFja29mZk1pbGxpcywgRmlyZWJhc2VFcnJvciwgaXNJbmRleGVkREJBdmFpbGFibGUsIHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUsIGlzQnJvd3NlckV4dGVuc2lvbiwgYXJlQ29va2llc0VuYWJsZWQsIGdldE1vZHVsYXJJbnN0YW5jZSwgZGVlcEVxdWFsIH0gZnJvbSAnQGZpcmViYXNlL3V0aWwnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgJ0BmaXJlYmFzZS9pbnN0YWxsYXRpb25zJztcblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogVHlwZSBjb25zdGFudCBmb3IgRmlyZWJhc2UgQW5hbHl0aWNzLlxuICovXG5jb25zdCBBTkFMWVRJQ1NfVFlQRSA9ICdhbmFseXRpY3MnO1xuLy8gS2V5IHRvIGF0dGFjaCBGSUQgdG8gaW4gZ3RhZyBwYXJhbXMuXG5jb25zdCBHQV9GSURfS0VZID0gJ2ZpcmViYXNlX2lkJztcbmNvbnN0IE9SSUdJTl9LRVkgPSAnb3JpZ2luJztcbmNvbnN0IEZFVENIX1RJTUVPVVRfTUlMTElTID0gNjAgKiAxMDAwO1xuY29uc3QgRFlOQU1JQ19DT05GSUdfVVJMID0gJ2h0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlYXBpcy5jb20vdjFhbHBoYS9wcm9qZWN0cy8tL2FwcHMve2FwcC1pZH0vd2ViQ29uZmlnJztcbmNvbnN0IEdUQUdfVVJMID0gJ2h0dHBzOi8vd3d3Lmdvb2dsZXRhZ21hbmFnZXIuY29tL2d0YWcvanMnO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignQGZpcmViYXNlL2FuYWx5dGljcycpO1xuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuY29uc3QgRVJST1JTID0ge1xuICAgIFtcImFscmVhZHktZXhpc3RzXCIgLyogQW5hbHl0aWNzRXJyb3IuQUxSRUFEWV9FWElTVFMgKi9dOiAnQSBGaXJlYmFzZSBBbmFseXRpY3MgaW5zdGFuY2Ugd2l0aCB0aGUgYXBwSWQgeyRpZH0gJyArXG4gICAgICAgICcgYWxyZWFkeSBleGlzdHMuICcgK1xuICAgICAgICAnT25seSBvbmUgRmlyZWJhc2UgQW5hbHl0aWNzIGluc3RhbmNlIGNhbiBiZSBjcmVhdGVkIGZvciBlYWNoIGFwcElkLicsXG4gICAgW1wiYWxyZWFkeS1pbml0aWFsaXplZFwiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfSU5JVElBTElaRUQgKi9dOiAnaW5pdGlhbGl6ZUFuYWx5dGljcygpIGNhbm5vdCBiZSBjYWxsZWQgYWdhaW4gd2l0aCBkaWZmZXJlbnQgb3B0aW9ucyB0aGFuIHRob3NlICcgK1xuICAgICAgICAnaXQgd2FzIGluaXRpYWxseSBjYWxsZWQgd2l0aC4gSXQgY2FuIGJlIGNhbGxlZCBhZ2FpbiB3aXRoIHRoZSBzYW1lIG9wdGlvbnMgdG8gJyArXG4gICAgICAgICdyZXR1cm4gdGhlIGV4aXN0aW5nIGluc3RhbmNlLCBvciBnZXRBbmFseXRpY3MoKSBjYW4gYmUgdXNlZCAnICtcbiAgICAgICAgJ3RvIGdldCBhIHJlZmVyZW5jZSB0byB0aGUgYWxyZWFkeS1pbml0aWFsaXplZCBpbnN0YW5jZS4nLFxuICAgIFtcImFscmVhZHktaW5pdGlhbGl6ZWQtc2V0dGluZ3NcIiAvKiBBbmFseXRpY3NFcnJvci5BTFJFQURZX0lOSVRJQUxJWkVEX1NFVFRJTkdTICovXTogJ0ZpcmViYXNlIEFuYWx5dGljcyBoYXMgYWxyZWFkeSBiZWVuIGluaXRpYWxpemVkLicgK1xuICAgICAgICAnc2V0dGluZ3MoKSBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgaW5pdGlhbGl6aW5nIGFueSBBbmFseXRpY3MgaW5zdGFuY2UnICtcbiAgICAgICAgJ29yIGl0IHdpbGwgaGF2ZSBubyBlZmZlY3QuJyxcbiAgICBbXCJpbnRlcm9wLWNvbXBvbmVudC1yZWctZmFpbGVkXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5URVJPUF9DT01QT05FTlRfUkVHX0ZBSUxFRCAqL106ICdGaXJlYmFzZSBBbmFseXRpY3MgSW50ZXJvcCBDb21wb25lbnQgZmFpbGVkIHRvIGluc3RhbnRpYXRlOiB7JHJlYXNvbn0nLFxuICAgIFtcImludmFsaWQtYW5hbHl0aWNzLWNvbnRleHRcIiAvKiBBbmFseXRpY3NFcnJvci5JTlZBTElEX0FOQUxZVElDU19DT05URVhUICovXTogJ0ZpcmViYXNlIEFuYWx5dGljcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuICcgK1xuICAgICAgICAnV3JhcCBpbml0aWFsaXphdGlvbiBvZiBhbmFseXRpY3MgaW4gYW5hbHl0aWNzLmlzU3VwcG9ydGVkKCkgJyArXG4gICAgICAgICd0byBwcmV2ZW50IGluaXRpYWxpemF0aW9uIGluIHVuc3VwcG9ydGVkIGVudmlyb25tZW50cy4gRGV0YWlsczogeyRlcnJvckluZm99JyxcbiAgICBbXCJpbmRleGVkZGItdW5hdmFpbGFibGVcIiAvKiBBbmFseXRpY3NFcnJvci5JTkRFWEVEREJfVU5BVkFJTEFCTEUgKi9dOiAnSW5kZXhlZERCIHVuYXZhaWxhYmxlIG9yIHJlc3RyaWN0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC4gJyArXG4gICAgICAgICdXcmFwIGluaXRpYWxpemF0aW9uIG9mIGFuYWx5dGljcyBpbiBhbmFseXRpY3MuaXNTdXBwb3J0ZWQoKSAnICtcbiAgICAgICAgJ3RvIHByZXZlbnQgaW5pdGlhbGl6YXRpb24gaW4gdW5zdXBwb3J0ZWQgZW52aXJvbm1lbnRzLiBEZXRhaWxzOiB7JGVycm9ySW5mb30nLFxuICAgIFtcImZldGNoLXRocm90dGxlXCIgLyogQW5hbHl0aWNzRXJyb3IuRkVUQ0hfVEhST1RUTEUgKi9dOiAnVGhlIGNvbmZpZyBmZXRjaCByZXF1ZXN0IHRpbWVkIG91dCB3aGlsZSBpbiBhbiBleHBvbmVudGlhbCBiYWNrb2ZmIHN0YXRlLicgK1xuICAgICAgICAnIFVuaXggdGltZXN0YW1wIGluIG1pbGxpc2Vjb25kcyB3aGVuIGZldGNoIHJlcXVlc3QgdGhyb3R0bGluZyBlbmRzOiB7JHRocm90dGxlRW5kVGltZU1pbGxpc30uJyxcbiAgICBbXCJjb25maWctZmV0Y2gtZmFpbGVkXCIgLyogQW5hbHl0aWNzRXJyb3IuQ09ORklHX0ZFVENIX0ZBSUxFRCAqL106ICdEeW5hbWljIGNvbmZpZyBmZXRjaCBmYWlsZWQ6IFt7JGh0dHBTdGF0dXN9XSB7JHJlc3BvbnNlTWVzc2FnZX0nLFxuICAgIFtcIm5vLWFwaS1rZXlcIiAvKiBBbmFseXRpY3NFcnJvci5OT19BUElfS0VZICovXTogJ1RoZSBcImFwaUtleVwiIGZpZWxkIGlzIGVtcHR5IGluIHRoZSBsb2NhbCBGaXJlYmFzZSBjb25maWcuIEZpcmViYXNlIEFuYWx5dGljcyByZXF1aXJlcyB0aGlzIGZpZWxkIHRvJyArXG4gICAgICAgICdjb250YWluIGEgdmFsaWQgQVBJIGtleS4nLFxuICAgIFtcIm5vLWFwcC1pZFwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0FQUF9JRCAqL106ICdUaGUgXCJhcHBJZFwiIGZpZWxkIGlzIGVtcHR5IGluIHRoZSBsb2NhbCBGaXJlYmFzZSBjb25maWcuIEZpcmViYXNlIEFuYWx5dGljcyByZXF1aXJlcyB0aGlzIGZpZWxkIHRvJyArXG4gICAgICAgICdjb250YWluIGEgdmFsaWQgYXBwIElELicsXG4gICAgW1wibm8tY2xpZW50LWlkXCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQ0xJRU5UX0lEICovXTogJ1RoZSBcImNsaWVudF9pZFwiIGZpZWxkIGlzIGVtcHR5LicsXG4gICAgW1wiaW52YWxpZC1ndGFnLXJlc291cmNlXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5WQUxJRF9HVEFHX1JFU09VUkNFICovXTogJ1RydXN0ZWQgVHlwZXMgZGV0ZWN0ZWQgYW4gaW52YWxpZCBndGFnIHJlc291cmNlOiB7JGd0YWdVUkx9Lidcbn07XG5jb25zdCBFUlJPUl9GQUNUT1JZID0gbmV3IEVycm9yRmFjdG9yeSgnYW5hbHl0aWNzJywgJ0FuYWx5dGljcycsIEVSUk9SUyk7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFZlcmlmaWVzIGFuZCBjcmVhdGVzIGEgVHJ1c3RlZFNjcmlwdFVSTC5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlR3RhZ1RydXN0ZWRUeXBlc1NjcmlwdFVSTCh1cmwpIHtcbiAgICBpZiAoIXVybC5zdGFydHNXaXRoKEdUQUdfVVJMKSkge1xuICAgICAgICBjb25zdCBlcnIgPSBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludmFsaWQtZ3RhZy1yZXNvdXJjZVwiIC8qIEFuYWx5dGljc0Vycm9yLklOVkFMSURfR1RBR19SRVNPVVJDRSAqLywge1xuICAgICAgICAgICAgZ3RhZ1VSTDogdXJsXG4gICAgICAgIH0pO1xuICAgICAgICBsb2dnZXIud2FybihlcnIubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9XG4gICAgcmV0dXJuIHVybDtcbn1cbi8qKlxuICogTWFrZXNoaWZ0IHBvbHlmaWxsIGZvciBQcm9taXNlLmFsbFNldHRsZWQoKS4gUmVzb2x2ZXMgd2hlbiBhbGwgcHJvbWlzZXNcbiAqIGhhdmUgZWl0aGVyIHJlc29sdmVkIG9yIHJlamVjdGVkLlxuICpcbiAqIEBwYXJhbSBwcm9taXNlcyBBcnJheSBvZiBwcm9taXNlcyB0byB3YWl0IGZvci5cbiAqL1xuZnVuY3Rpb24gcHJvbWlzZUFsbFNldHRsZWQocHJvbWlzZXMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMubWFwKHByb21pc2UgPT4gcHJvbWlzZS5jYXRjaChlID0+IGUpKSk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBUcnVzdGVkVHlwZVBvbGljeSBvYmplY3QgdGhhdCBpbXBsZW1lbnRzIHRoZSBydWxlcyBwYXNzZWQgYXMgcG9saWN5T3B0aW9ucy5cbiAqXG4gKiBAcGFyYW0gcG9saWN5TmFtZSBBIHN0cmluZyBjb250YWluaW5nIHRoZSBuYW1lIG9mIHRoZSBwb2xpY3lcbiAqIEBwYXJhbSBwb2xpY3lPcHRpb25zIE9iamVjdCBjb250YWluaW5nIGltcGxlbWVudGF0aW9ucyBvZiBpbnN0YW5jZSBtZXRob2RzIGZvciBUcnVzdGVkVHlwZXNQb2xpY3ksIHNlZSB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL1RydXN0ZWRUeXBlUG9saWN5I2luc3RhbmNlX21ldGhvZHNcbiAqIHwgdGhlIFRydXN0ZWRUeXBlUG9saWN5IHJlZmVyZW5jZSBkb2N1bWVudGF0aW9ufS5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KHBvbGljeU5hbWUsIHBvbGljeU9wdGlvbnMpIHtcbiAgICAvLyBDcmVhdGUgYSBUcnVzdGVkVHlwZXMgcG9saWN5IHRoYXQgd2UgY2FuIHVzZSBmb3IgdXBkYXRpbmcgc3JjXG4gICAgLy8gcHJvcGVydGllc1xuICAgIGxldCB0cnVzdGVkVHlwZXNQb2xpY3k7XG4gICAgaWYgKHdpbmRvdy50cnVzdGVkVHlwZXMpIHtcbiAgICAgICAgdHJ1c3RlZFR5cGVzUG9saWN5ID0gd2luZG93LnRydXN0ZWRUeXBlcy5jcmVhdGVQb2xpY3kocG9saWN5TmFtZSwgcG9saWN5T3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB0cnVzdGVkVHlwZXNQb2xpY3k7XG59XG4vKipcbiAqIEluc2VydHMgZ3RhZyBzY3JpcHQgdGFnIGludG8gdGhlIHBhZ2UgdG8gYXN5bmNocm9ub3VzbHkgZG93bmxvYWQgZ3RhZy5cbiAqIEBwYXJhbSBkYXRhTGF5ZXJOYW1lIE5hbWUgb2YgZGF0YWxheWVyIChtb3N0IG9mdGVuIHRoZSBkZWZhdWx0LCBcIl9kYXRhTGF5ZXJcIikuXG4gKi9cbmZ1bmN0aW9uIGluc2VydFNjcmlwdFRhZyhkYXRhTGF5ZXJOYW1lLCBtZWFzdXJlbWVudElkKSB7XG4gICAgY29uc3QgdHJ1c3RlZFR5cGVzUG9saWN5ID0gY3JlYXRlVHJ1c3RlZFR5cGVzUG9saWN5KCdmaXJlYmFzZS1qcy1zZGstcG9saWN5Jywge1xuICAgICAgICBjcmVhdGVTY3JpcHRVUkw6IGNyZWF0ZUd0YWdUcnVzdGVkVHlwZXNTY3JpcHRVUkxcbiAgICB9KTtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICAvLyBXZSBhcmUgbm90IHByb3ZpZGluZyBhbiBhbmFseXRpY3NJZCBpbiB0aGUgVVJMIGJlY2F1c2UgaXQgd291bGQgdHJpZ2dlciBhIGBwYWdlX3ZpZXdgXG4gICAgLy8gd2l0aG91dCBmaWQuIFdlIHdpbGwgaW5pdGlhbGl6ZSBnYS1pZCB1c2luZyBndGFnIChjb25maWcpIGNvbW1hbmQgdG9nZXRoZXIgd2l0aCBmaWQuXG4gICAgY29uc3QgZ3RhZ1NjcmlwdFVSTCA9IGAke0dUQUdfVVJMfT9sPSR7ZGF0YUxheWVyTmFtZX0maWQ9JHttZWFzdXJlbWVudElkfWA7XG4gICAgc2NyaXB0LnNyYyA9IHRydXN0ZWRUeXBlc1BvbGljeVxuICAgICAgICA/IHRydXN0ZWRUeXBlc1BvbGljeSA9PT0gbnVsbCB8fCB0cnVzdGVkVHlwZXNQb2xpY3kgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHRydXN0ZWRUeXBlc1BvbGljeS5jcmVhdGVTY3JpcHRVUkwoZ3RhZ1NjcmlwdFVSTClcbiAgICAgICAgOiBndGFnU2NyaXB0VVJMO1xuICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xufVxuLyoqXG4gKiBHZXQgcmVmZXJlbmNlIHRvLCBvciBjcmVhdGUsIGdsb2JhbCBkYXRhbGF5ZXIuXG4gKiBAcGFyYW0gZGF0YUxheWVyTmFtZSBOYW1lIG9mIGRhdGFsYXllciAobW9zdCBvZnRlbiB0aGUgZGVmYXVsdCwgXCJfZGF0YUxheWVyXCIpLlxuICovXG5mdW5jdGlvbiBnZXRPckNyZWF0ZURhdGFMYXllcihkYXRhTGF5ZXJOYW1lKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGV4aXN0aW5nIGRhdGFMYXllciBhbmQgY3JlYXRlIGlmIG5lZWRlZC5cbiAgICBsZXQgZGF0YUxheWVyID0gW107XG4gICAgaWYgKEFycmF5LmlzQXJyYXkod2luZG93W2RhdGFMYXllck5hbWVdKSkge1xuICAgICAgICBkYXRhTGF5ZXIgPSB3aW5kb3dbZGF0YUxheWVyTmFtZV07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB3aW5kb3dbZGF0YUxheWVyTmFtZV0gPSBkYXRhTGF5ZXI7XG4gICAgfVxuICAgIHJldHVybiBkYXRhTGF5ZXI7XG59XG4vKipcbiAqIFdyYXBwZWQgZ3RhZyBsb2dpYyB3aGVuIGd0YWcgaXMgY2FsbGVkIHdpdGggJ2NvbmZpZycgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0NvcmUgQmFzaWMgZ3RhZyBmdW5jdGlvbiB0aGF0IGp1c3QgYXBwZW5kcyB0byBkYXRhTGF5ZXIuXG4gKiBAcGFyYW0gaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCBNYXAgb2YgYXBwSWRzIHRvIHRoZWlyIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxuICogQHBhcmFtIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgQXJyYXkgb2YgZHluYW1pYyBjb25maWcgZmV0Y2ggcHJvbWlzZXMuXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZFRvQXBwSWQgTWFwIG9mIEdBIG1lYXN1cmVtZW50SURzIHRvIGNvcnJlc3BvbmRpbmcgRmlyZWJhc2UgYXBwSWQuXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZCBHQSBNZWFzdXJlbWVudCBJRCB0byBzZXQgY29uZmlnIGZvci5cbiAqIEBwYXJhbSBndGFnUGFyYW1zIEd0YWcgY29uZmlnIHBhcmFtcyB0byBzZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGd0YWdPbkNvbmZpZyhndGFnQ29yZSwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpIHtcbiAgICAvLyBJZiBjb25maWcgaXMgYWxyZWFkeSBmZXRjaGVkLCB3ZSBrbm93IHRoZSBhcHBJZCBhbmQgY2FuIHVzZSBpdCB0byBsb29rIHVwIHdoYXQgRklEIHByb21pc2Ugd2VcbiAgICAvLy8gYXJlIHdhaXRpbmcgZm9yLCBhbmQgd2FpdCBvbmx5IG9uIHRoYXQgb25lLlxuICAgIGNvbnN0IGNvcnJlc3BvbmRpbmdBcHBJZCA9IG1lYXN1cmVtZW50SWRUb0FwcElkW21lYXN1cmVtZW50SWRdO1xuICAgIHRyeSB7XG4gICAgICAgIGlmIChjb3JyZXNwb25kaW5nQXBwSWQpIHtcbiAgICAgICAgICAgIGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbY29ycmVzcG9uZGluZ0FwcElkXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIElmIGNvbmZpZyBpcyBub3QgZmV0Y2hlZCB5ZXQsIHdhaXQgZm9yIGFsbCBjb25maWdzICh3ZSBkb24ndCBrbm93IHdoaWNoIG9uZSB3ZSBuZWVkKSBhbmRcbiAgICAgICAgICAgIC8vIGZpbmQgdGhlIGFwcElkIChpZiBhbnkpIGNvcnJlc3BvbmRpbmcgdG8gdGhpcyBtZWFzdXJlbWVudElkLiBJZiB0aGVyZSBpcyBvbmUsIHdhaXQgb25cbiAgICAgICAgICAgIC8vIHRoYXQgYXBwSWQncyBpbml0aWFsaXphdGlvbiBwcm9taXNlLiBJZiB0aGVyZSBpcyBub25lLCBwcm9taXNlIHJlc29sdmVzIGFuZCBndGFnXG4gICAgICAgICAgICAvLyBjYWxsIGdvZXMgdGhyb3VnaC5cbiAgICAgICAgICAgIGNvbnN0IGR5bmFtaWNDb25maWdSZXN1bHRzID0gYXdhaXQgcHJvbWlzZUFsbFNldHRsZWQoZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCk7XG4gICAgICAgICAgICBjb25zdCBmb3VuZENvbmZpZyA9IGR5bmFtaWNDb25maWdSZXN1bHRzLmZpbmQoY29uZmlnID0+IGNvbmZpZy5tZWFzdXJlbWVudElkID09PSBtZWFzdXJlbWVudElkKTtcbiAgICAgICAgICAgIGlmIChmb3VuZENvbmZpZykge1xuICAgICAgICAgICAgICAgIGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbZm91bmRDb25maWcuYXBwSWRdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGxvZ2dlci5lcnJvcihlKTtcbiAgICB9XG4gICAgZ3RhZ0NvcmUoXCJjb25maWdcIiAvKiBHdGFnQ29tbWFuZC5DT05GSUcgKi8sIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpO1xufVxuLyoqXG4gKiBXcmFwcGVkIGd0YWcgbG9naWMgd2hlbiBndGFnIGlzIGNhbGxlZCB3aXRoICdldmVudCcgY29tbWFuZC5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0NvcmUgQmFzaWMgZ3RhZyBmdW5jdGlvbiB0aGF0IGp1c3QgYXBwZW5kcyB0byBkYXRhTGF5ZXIuXG4gKiBAcGFyYW0gaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCBNYXAgb2YgYXBwSWRzIHRvIHRoZWlyIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxuICogQHBhcmFtIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgQXJyYXkgb2YgZHluYW1pYyBjb25maWcgZmV0Y2ggcHJvbWlzZXMuXG4gKiBAcGFyYW0gbWVhc3VyZW1lbnRJZCBHQSBNZWFzdXJlbWVudCBJRCB0byBsb2cgZXZlbnQgdG8uXG4gKiBAcGFyYW0gZ3RhZ1BhcmFtcyBQYXJhbXMgdG8gbG9nIHdpdGggdGhpcyBldmVudC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ3RhZ09uRXZlbnQoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpIHtcbiAgICB0cnkge1xuICAgICAgICBsZXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlc1RvV2FpdEZvciA9IFtdO1xuICAgICAgICAvLyBJZiB0aGVyZSdzIGEgJ3NlbmRfdG8nIHBhcmFtLCBjaGVjayBpZiBhbnkgSUQgc3BlY2lmaWVkIG1hdGNoZXNcbiAgICAgICAgLy8gYW4gaW5pdGlhbGl6ZUlkcygpIHByb21pc2Ugd2UgYXJlIHdhaXRpbmcgZm9yLlxuICAgICAgICBpZiAoZ3RhZ1BhcmFtcyAmJiBndGFnUGFyYW1zWydzZW5kX3RvJ10pIHtcbiAgICAgICAgICAgIGxldCBnYVNlbmRUb0xpc3QgPSBndGFnUGFyYW1zWydzZW5kX3RvJ107XG4gICAgICAgICAgICAvLyBNYWtlIGl0IGFuIGFycmF5IGlmIGlzIGlzbid0LCBzbyBpdCBjYW4gYmUgZGVhbHQgd2l0aCB0aGUgc2FtZSB3YXkuXG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoZ2FTZW5kVG9MaXN0KSkge1xuICAgICAgICAgICAgICAgIGdhU2VuZFRvTGlzdCA9IFtnYVNlbmRUb0xpc3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2hlY2tpbmcgJ3NlbmRfdG8nIGZpZWxkcyByZXF1aXJlcyBoYXZpbmcgYWxsIG1lYXN1cmVtZW50IElEIHJlc3VsdHMgYmFjayBmcm9tXG4gICAgICAgICAgICAvLyB0aGUgZHluYW1pYyBjb25maWcgZmV0Y2guXG4gICAgICAgICAgICBjb25zdCBkeW5hbWljQ29uZmlnUmVzdWx0cyA9IGF3YWl0IHByb21pc2VBbGxTZXR0bGVkKGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBzZW5kVG9JZCBvZiBnYVNlbmRUb0xpc3QpIHtcbiAgICAgICAgICAgICAgICAvLyBBbnkgZmV0Y2hlZCBkeW5hbWljIG1lYXN1cmVtZW50IElEIHRoYXQgbWF0Y2hlcyB0aGlzICdzZW5kX3RvJyBJRFxuICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kQ29uZmlnID0gZHluYW1pY0NvbmZpZ1Jlc3VsdHMuZmluZChjb25maWcgPT4gY29uZmlnLm1lYXN1cmVtZW50SWQgPT09IHNlbmRUb0lkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpbml0aWFsaXphdGlvblByb21pc2UgPSBmb3VuZENvbmZpZyAmJiBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2ZvdW5kQ29uZmlnLmFwcElkXTtcbiAgICAgICAgICAgICAgICBpZiAoaW5pdGlhbGl6YXRpb25Qcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IucHVzaChpbml0aWFsaXphdGlvblByb21pc2UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRm91bmQgYW4gaXRlbSBpbiAnc2VuZF90bycgdGhhdCBpcyBub3QgYXNzb2NpYXRlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkaXJlY3RseSB3aXRoIGFuIEZJRCwgcG9zc2libHkgYSBncm91cC4gIEVtcHR5IHRoaXMgYXJyYXksXG4gICAgICAgICAgICAgICAgICAgIC8vIGV4aXQgdGhlIGxvb3AgZWFybHksIGFuZCBsZXQgaXQgZ2V0IHBvcHVsYXRlZCBiZWxvdy5cbiAgICAgICAgICAgICAgICAgICAgaW5pdGlhbGl6YXRpb25Qcm9taXNlc1RvV2FpdEZvciA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhpcyB3aWxsIGJlIHVucG9wdWxhdGVkIGlmIHRoZXJlIHdhcyBubyAnc2VuZF90bycgZmllbGQgLCBvclxuICAgICAgICAvLyBpZiBub3QgYWxsIGVudHJpZXMgaW4gdGhlICdzZW5kX3RvJyBmaWVsZCBjb3VsZCBiZSBtYXBwZWQgdG9cbiAgICAgICAgLy8gYSBGSUQuIEluIHRoZXNlIGNhc2VzLCB3YWl0IG9uIGFsbCBwZW5kaW5nIGluaXRpYWxpemF0aW9uIHByb21pc2VzLlxuICAgICAgICBpZiAoaW5pdGlhbGl6YXRpb25Qcm9taXNlc1RvV2FpdEZvci5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIC8qIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZmxvYXRpbmctcHJvbWlzZXMgKi9cbiAgICAgICAgICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IgPSBPYmplY3QudmFsdWVzKGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJ1biBjb3JlIGd0YWcgZnVuY3Rpb24gd2l0aCBhcmdzIGFmdGVyIGFsbCByZWxldmFudCBpbml0aWFsaXphdGlvblxuICAgICAgICAvLyBwcm9taXNlcyBoYXZlIGJlZW4gcmVzb2x2ZWQuXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKGluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IpO1xuICAgICAgICAvLyBXb3JrYXJvdW5kIGZvciBodHRwOi8vYi8xNDEzNzA0NDkgLSB0aGlyZCBhcmd1bWVudCBjYW5ub3QgYmUgdW5kZWZpbmVkLlxuICAgICAgICBndGFnQ29yZShcImV2ZW50XCIgLyogR3RhZ0NvbW1hbmQuRVZFTlQgKi8sIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMgfHwge30pO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBsb2dnZXIuZXJyb3IoZSk7XG4gICAgfVxufVxuLyoqXG4gKiBXcmFwcyBhIHN0YW5kYXJkIGd0YWcgZnVuY3Rpb24gd2l0aCBleHRyYSBjb2RlIHRvIHdhaXQgZm9yIGNvbXBsZXRpb24gb2ZcbiAqIHJlbGV2YW50IGluaXRpYWxpemF0aW9uIHByb21pc2VzIGJlZm9yZSBzZW5kaW5nIHJlcXVlc3RzLlxuICpcbiAqIEBwYXJhbSBndGFnQ29yZSBCYXNpYyBndGFnIGZ1bmN0aW9uIHRoYXQganVzdCBhcHBlbmRzIHRvIGRhdGFMYXllci5cbiAqIEBwYXJhbSBpbml0aWFsaXphdGlvblByb21pc2VzTWFwIE1hcCBvZiBhcHBJZHMgdG8gdGhlaXIgaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMuXG4gKiBAcGFyYW0gZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCBBcnJheSBvZiBkeW5hbWljIGNvbmZpZyBmZXRjaCBwcm9taXNlcy5cbiAqIEBwYXJhbSBtZWFzdXJlbWVudElkVG9BcHBJZCBNYXAgb2YgR0EgbWVhc3VyZW1lbnRJRHMgdG8gY29ycmVzcG9uZGluZyBGaXJlYmFzZSBhcHBJZC5cbiAqL1xuZnVuY3Rpb24gd3JhcEd0YWcoZ3RhZ0NvcmUsIFxuLyoqXG4gKiBBbGxvd3Mgd3JhcHBlZCBndGFnIGNhbGxzIHRvIHdhaXQgb24gd2hpY2hldmVyIGluaXRpYWxpemF0aW9uIHByb21pc2VzIGFyZSByZXF1aXJlZCxcbiAqIGRlcGVuZGluZyBvbiB0aGUgY29udGVudHMgb2YgdGhlIGd0YWcgcGFyYW1zJyBgc2VuZF90b2AgZmllbGQsIGlmIGFueS5cbiAqL1xuaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgXG4vKipcbiAqIFdyYXBwZWQgZ3RhZyBjYWxscyBzb21ldGltZXMgcmVxdWlyZSBhbGwgZHluYW1pYyBjb25maWcgZmV0Y2hlcyB0byBoYXZlIHJldHVybmVkXG4gKiBiZWZvcmUgZGV0ZXJtaW5pbmcgd2hhdCBpbml0aWFsaXphdGlvbiBwcm9taXNlcyAod2hpY2ggaW5jbHVkZSBGSURzKSB0byB3YWl0IGZvci5cbiAqL1xuZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgXG4vKipcbiAqIFdyYXBwZWQgZ3RhZyBjb25maWcgY2FsbHMgY2FuIG5hcnJvdyBkb3duIHdoaWNoIGluaXRpYWxpemF0aW9uIHByb21pc2UgKHdpdGggRklEKVxuICogdG8gd2FpdCBmb3IgaWYgdGhlIG1lYXN1cmVtZW50SWQgaXMgYWxyZWFkeSBmZXRjaGVkLCBieSBnZXR0aW5nIHRoZSBjb3JyZXNwb25kaW5nIGFwcElkLFxuICogd2hpY2ggaXMgdGhlIGtleSBmb3IgdGhlIGluaXRpYWxpemF0aW9uIHByb21pc2VzIG1hcC5cbiAqL1xubWVhc3VyZW1lbnRJZFRvQXBwSWQpIHtcbiAgICAvKipcbiAgICAgKiBXcmFwcGVyIGFyb3VuZCBndGFnIHRoYXQgZW5zdXJlcyBGSUQgaXMgc2VudCB3aXRoIGd0YWcgY2FsbHMuXG4gICAgICogQHBhcmFtIGNvbW1hbmQgR3RhZyBjb21tYW5kIHR5cGUuXG4gICAgICogQHBhcmFtIGlkT3JOYW1lT3JQYXJhbXMgTWVhc3VyZW1lbnQgSUQgaWYgY29tbWFuZCBpcyBFVkVOVC9DT05GSUcsIHBhcmFtcyBpZiBjb21tYW5kIGlzIFNFVC5cbiAgICAgKiBAcGFyYW0gZ3RhZ1BhcmFtcyBQYXJhbXMgaWYgZXZlbnQgaXMgRVZFTlQvQ09ORklHLlxuICAgICAqL1xuICAgIGFzeW5jIGZ1bmN0aW9uIGd0YWdXcmFwcGVyKGNvbW1hbmQsIC4uLmFyZ3MpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIElmIGV2ZW50LCBjaGVjayB0aGF0IHJlbGV2YW50IGluaXRpYWxpemF0aW9uIHByb21pc2VzIGhhdmUgY29tcGxldGVkLlxuICAgICAgICAgICAgaWYgKGNvbW1hbmQgPT09IFwiZXZlbnRcIiAvKiBHdGFnQ29tbWFuZC5FVkVOVCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFttZWFzdXJlbWVudElkLCBndGFnUGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgLy8gSWYgRVZFTlQsIHNlY29uZCBhcmcgbXVzdCBiZSBtZWFzdXJlbWVudElkLlxuICAgICAgICAgICAgICAgIGF3YWl0IGd0YWdPbkV2ZW50KGd0YWdDb3JlLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkLCBndGFnUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW21lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXNdID0gYXJncztcbiAgICAgICAgICAgICAgICAvLyBJZiBDT05GSUcsIHNlY29uZCBhcmcgbXVzdCBiZSBtZWFzdXJlbWVudElkLlxuICAgICAgICAgICAgICAgIGF3YWl0IGd0YWdPbkNvbmZpZyhndGFnQ29yZSwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCwgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCwgbWVhc3VyZW1lbnRJZFRvQXBwSWQsIG1lYXN1cmVtZW50SWQsIGd0YWdQYXJhbXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWFuZCA9PT0gXCJjb25zZW50XCIgLyogR3RhZ0NvbW1hbmQuQ09OU0VOVCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjb25zZW50QWN0aW9uLCBndGFnUGFyYW1zXSA9IGFyZ3M7XG4gICAgICAgICAgICAgICAgLy8gY29uc2VudEFjdGlvbiBjYW4gYmUgb25lIG9mICdkZWZhdWx0JyBvciAndXBkYXRlJy5cbiAgICAgICAgICAgICAgICBndGFnQ29yZShcImNvbnNlbnRcIiAvKiBHdGFnQ29tbWFuZC5DT05TRU5UICovLCBjb25zZW50QWN0aW9uLCBndGFnUGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNvbW1hbmQgPT09IFwiZ2V0XCIgLyogR3RhZ0NvbW1hbmQuR0VUICovKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW21lYXN1cmVtZW50SWQsIGZpZWxkTmFtZSwgY2FsbGJhY2tdID0gYXJncztcbiAgICAgICAgICAgICAgICBndGFnQ29yZShcImdldFwiIC8qIEd0YWdDb21tYW5kLkdFVCAqLywgbWVhc3VyZW1lbnRJZCwgZmllbGROYW1lLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChjb21tYW5kID09PSBcInNldFwiIC8qIEd0YWdDb21tYW5kLlNFVCAqLykge1xuICAgICAgICAgICAgICAgIGNvbnN0IFtjdXN0b21QYXJhbXNdID0gYXJncztcbiAgICAgICAgICAgICAgICAvLyBJZiBTRVQsIHNlY29uZCBhcmcgbXVzdCBiZSBwYXJhbXMuXG4gICAgICAgICAgICAgICAgZ3RhZ0NvcmUoXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIGN1c3RvbVBhcmFtcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBndGFnQ29yZShjb21tYW5kLCAuLi5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBndGFnV3JhcHBlcjtcbn1cbi8qKlxuICogQ3JlYXRlcyBnbG9iYWwgZ3RhZyBmdW5jdGlvbiBvciB3cmFwcyBleGlzdGluZyBvbmUgaWYgZm91bmQuXG4gKiBUaGlzIHdyYXBwZWQgZnVuY3Rpb24gYXR0YWNoZXMgRmlyZWJhc2UgaW5zdGFuY2UgSUQgKEZJRCkgdG8gZ3RhZyAnY29uZmlnJyBhbmRcbiAqICdldmVudCcgY2FsbHMgdGhhdCBiZWxvbmcgdG8gdGhlIEdBSUQgYXNzb2NpYXRlZCB3aXRoIHRoaXMgRmlyZWJhc2UgaW5zdGFuY2UuXG4gKlxuICogQHBhcmFtIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAgTWFwIG9mIGFwcElkcyB0byB0aGVpciBpbml0aWFsaXphdGlvbiBwcm9taXNlcy5cbiAqIEBwYXJhbSBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0IEFycmF5IG9mIGR5bmFtaWMgY29uZmlnIGZldGNoIHByb21pc2VzLlxuICogQHBhcmFtIG1lYXN1cmVtZW50SWRUb0FwcElkIE1hcCBvZiBHQSBtZWFzdXJlbWVudElEcyB0byBjb3JyZXNwb25kaW5nIEZpcmViYXNlIGFwcElkLlxuICogQHBhcmFtIGRhdGFMYXllck5hbWUgTmFtZSBvZiBnbG9iYWwgR0EgZGF0YWxheWVyIGFycmF5LlxuICogQHBhcmFtIGd0YWdGdW5jdGlvbk5hbWUgTmFtZSBvZiBnbG9iYWwgZ3RhZyBmdW5jdGlvbiAoXCJndGFnXCIgaWYgbm90IHVzZXItc3BlY2lmaWVkKS5cbiAqL1xuZnVuY3Rpb24gd3JhcE9yQ3JlYXRlR3RhZyhpbml0aWFsaXphdGlvblByb21pc2VzTWFwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkVG9BcHBJZCwgZGF0YUxheWVyTmFtZSwgZ3RhZ0Z1bmN0aW9uTmFtZSkge1xuICAgIC8vIENyZWF0ZSBhIGJhc2ljIGNvcmUgZ3RhZyBmdW5jdGlvblxuICAgIGxldCBndGFnQ29yZSA9IGZ1bmN0aW9uICguLi5fYXJncykge1xuICAgICAgICAvLyBNdXN0IHB1c2ggSUFyZ3VtZW50cyBvYmplY3QsIG5vdCBhbiBhcnJheS5cbiAgICAgICAgd2luZG93W2RhdGFMYXllck5hbWVdLnB1c2goYXJndW1lbnRzKTtcbiAgICB9O1xuICAgIC8vIFJlcGxhY2UgaXQgd2l0aCBleGlzdGluZyBvbmUgaWYgZm91bmRcbiAgICBpZiAod2luZG93W2d0YWdGdW5jdGlvbk5hbWVdICYmXG4gICAgICAgIHR5cGVvZiB3aW5kb3dbZ3RhZ0Z1bmN0aW9uTmFtZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBndGFnQ29yZSA9IHdpbmRvd1tndGFnRnVuY3Rpb25OYW1lXTtcbiAgICB9XG4gICAgd2luZG93W2d0YWdGdW5jdGlvbk5hbWVdID0gd3JhcEd0YWcoZ3RhZ0NvcmUsIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWRUb0FwcElkKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBndGFnQ29yZSxcbiAgICAgICAgd3JhcHBlZEd0YWc6IHdpbmRvd1tndGFnRnVuY3Rpb25OYW1lXVxuICAgIH07XG59XG4vKipcbiAqIFJldHVybnMgdGhlIHNjcmlwdCB0YWcgaW4gdGhlIERPTSBtYXRjaGluZyBib3RoIHRoZSBndGFnIHVybCBwYXR0ZXJuXG4gKiBhbmQgdGhlIHByb3ZpZGVkIGRhdGEgbGF5ZXIgbmFtZS5cbiAqL1xuZnVuY3Rpb24gZmluZEd0YWdTY3JpcHRPblBhZ2UoZGF0YUxheWVyTmFtZSkge1xuICAgIGNvbnN0IHNjcmlwdFRhZ3MgPSB3aW5kb3cuZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpO1xuICAgIGZvciAoY29uc3QgdGFnIG9mIE9iamVjdC52YWx1ZXMoc2NyaXB0VGFncykpIHtcbiAgICAgICAgaWYgKHRhZy5zcmMgJiZcbiAgICAgICAgICAgIHRhZy5zcmMuaW5jbHVkZXMoR1RBR19VUkwpICYmXG4gICAgICAgICAgICB0YWcuc3JjLmluY2x1ZGVzKGRhdGFMYXllck5hbWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdGFnO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBCYWNrb2ZmIGZhY3RvciBmb3IgNTAzIGVycm9ycywgd2hpY2ggd2Ugd2FudCB0byBiZSBjb25zZXJ2YXRpdmUgYWJvdXRcbiAqIHRvIGF2b2lkIG92ZXJsb2FkaW5nIHNlcnZlcnMuIEVhY2ggcmV0cnkgaW50ZXJ2YWwgd2lsbCBiZVxuICogQkFTRV9JTlRFUlZBTF9NSUxMSVMgKiBMT05HX1JFVFJZX0ZBQ1RPUiBeIHJldHJ5Q291bnQsIHNvIHRoZSBzZWNvbmQgb25lXG4gKiB3aWxsIGJlIH4zMCBzZWNvbmRzICh3aXRoIGZ1enppbmcpLlxuICovXG5jb25zdCBMT05HX1JFVFJZX0ZBQ1RPUiA9IDMwO1xuLyoqXG4gKiBCYXNlIHdhaXQgaW50ZXJ2YWwgdG8gbXVsdGlwbGllZCBieSBiYWNrb2ZmRmFjdG9yXmJhY2tvZmZDb3VudC5cbiAqL1xuY29uc3QgQkFTRV9JTlRFUlZBTF9NSUxMSVMgPSAxMDAwO1xuLyoqXG4gKiBTdHViYmFibGUgcmV0cnkgZGF0YSBzdG9yYWdlIGNsYXNzLlxuICovXG5jbGFzcyBSZXRyeURhdGEge1xuICAgIGNvbnN0cnVjdG9yKHRocm90dGxlTWV0YWRhdGEgPSB7fSwgaW50ZXJ2YWxNaWxsaXMgPSBCQVNFX0lOVEVSVkFMX01JTExJUykge1xuICAgICAgICB0aGlzLnRocm90dGxlTWV0YWRhdGEgPSB0aHJvdHRsZU1ldGFkYXRhO1xuICAgICAgICB0aGlzLmludGVydmFsTWlsbGlzID0gaW50ZXJ2YWxNaWxsaXM7XG4gICAgfVxuICAgIGdldFRocm90dGxlTWV0YWRhdGEoYXBwSWQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3R0bGVNZXRhZGF0YVthcHBJZF07XG4gICAgfVxuICAgIHNldFRocm90dGxlTWV0YWRhdGEoYXBwSWQsIG1ldGFkYXRhKSB7XG4gICAgICAgIHRoaXMudGhyb3R0bGVNZXRhZGF0YVthcHBJZF0gPSBtZXRhZGF0YTtcbiAgICB9XG4gICAgZGVsZXRlVGhyb3R0bGVNZXRhZGF0YShhcHBJZCkge1xuICAgICAgICBkZWxldGUgdGhpcy50aHJvdHRsZU1ldGFkYXRhW2FwcElkXTtcbiAgICB9XG59XG5jb25zdCBkZWZhdWx0UmV0cnlEYXRhID0gbmV3IFJldHJ5RGF0YSgpO1xuLyoqXG4gKiBTZXQgR0VUIHJlcXVlc3QgaGVhZGVycy5cbiAqIEBwYXJhbSBhcGlLZXkgQXBwIEFQSSBrZXkuXG4gKi9cbmZ1bmN0aW9uIGdldEhlYWRlcnMoYXBpS2V5KSB7XG4gICAgcmV0dXJuIG5ldyBIZWFkZXJzKHtcbiAgICAgICAgQWNjZXB0OiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgICd4LWdvb2ctYXBpLWtleSc6IGFwaUtleVxuICAgIH0pO1xufVxuLyoqXG4gKiBGZXRjaGVzIGR5bmFtaWMgY29uZmlnIGZyb20gYmFja2VuZC5cbiAqIEBwYXJhbSBhcHAgRmlyZWJhc2UgYXBwIHRvIGZldGNoIGNvbmZpZyBmb3IuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGZldGNoRHluYW1pY0NvbmZpZyhhcHBGaWVsZHMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBhcHBJZCwgYXBpS2V5IH0gPSBhcHBGaWVsZHM7XG4gICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgbWV0aG9kOiAnR0VUJyxcbiAgICAgICAgaGVhZGVyczogZ2V0SGVhZGVycyhhcGlLZXkpXG4gICAgfTtcbiAgICBjb25zdCBhcHBVcmwgPSBEWU5BTUlDX0NPTkZJR19VUkwucmVwbGFjZSgne2FwcC1pZH0nLCBhcHBJZCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChhcHBVcmwsIHJlcXVlc3QpO1xuICAgIGlmIChyZXNwb25zZS5zdGF0dXMgIT09IDIwMCAmJiByZXNwb25zZS5zdGF0dXMgIT09IDMwNCkge1xuICAgICAgICBsZXQgZXJyb3JNZXNzYWdlID0gJyc7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBUcnkgdG8gZ2V0IGFueSBlcnJvciBtZXNzYWdlIHRleHQgZnJvbSBzZXJ2ZXIgcmVzcG9uc2UuXG4gICAgICAgICAgICBjb25zdCBqc29uUmVzcG9uc2UgPSAoYXdhaXQgcmVzcG9uc2UuanNvbigpKTtcbiAgICAgICAgICAgIGlmICgoX2EgPSBqc29uUmVzcG9uc2UuZXJyb3IpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5tZXNzYWdlKSB7XG4gICAgICAgICAgICAgICAgZXJyb3JNZXNzYWdlID0ganNvblJlc3BvbnNlLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKF9pZ25vcmVkKSB7IH1cbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJjb25maWctZmV0Y2gtZmFpbGVkXCIgLyogQW5hbHl0aWNzRXJyb3IuQ09ORklHX0ZFVENIX0ZBSUxFRCAqLywge1xuICAgICAgICAgICAgaHR0cFN0YXR1czogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlOiBlcnJvck1lc3NhZ2VcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG59XG4vKipcbiAqIEZldGNoZXMgZHluYW1pYyBjb25maWcgZnJvbSBiYWNrZW5kLCByZXRyeWluZyBpZiBmYWlsZWQuXG4gKiBAcGFyYW0gYXBwIEZpcmViYXNlIGFwcCB0byBmZXRjaCBjb25maWcgZm9yLlxuICovXG5hc3luYyBmdW5jdGlvbiBmZXRjaER5bmFtaWNDb25maWdXaXRoUmV0cnkoYXBwLCBcbi8vIHJldHJ5RGF0YSBhbmQgdGltZW91dE1pbGxpcyBhcmUgcGFyYW1ldGVyaXplZCB0byBhbGxvdyBwYXNzaW5nIGEgZGlmZmVyZW50IHZhbHVlIGZvciB0ZXN0aW5nLlxucmV0cnlEYXRhID0gZGVmYXVsdFJldHJ5RGF0YSwgdGltZW91dE1pbGxpcykge1xuICAgIGNvbnN0IHsgYXBwSWQsIGFwaUtleSwgbWVhc3VyZW1lbnRJZCB9ID0gYXBwLm9wdGlvbnM7XG4gICAgaWYgKCFhcHBJZCkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwcC1pZFwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0FQUF9JRCAqLyk7XG4gICAgfVxuICAgIGlmICghYXBpS2V5KSB7XG4gICAgICAgIGlmIChtZWFzdXJlbWVudElkKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIG1lYXN1cmVtZW50SWQsXG4gICAgICAgICAgICAgICAgYXBwSWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJuby1hcGkta2V5XCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBJX0tFWSAqLyk7XG4gICAgfVxuICAgIGNvbnN0IHRocm90dGxlTWV0YWRhdGEgPSByZXRyeURhdGEuZ2V0VGhyb3R0bGVNZXRhZGF0YShhcHBJZCkgfHwge1xuICAgICAgICBiYWNrb2ZmQ291bnQ6IDAsXG4gICAgICAgIHRocm90dGxlRW5kVGltZU1pbGxpczogRGF0ZS5ub3coKVxuICAgIH07XG4gICAgY29uc3Qgc2lnbmFsID0gbmV3IEFuYWx5dGljc0Fib3J0U2lnbmFsKCk7XG4gICAgc2V0VGltZW91dChhc3luYyAoKSA9PiB7XG4gICAgICAgIC8vIE5vdGUgYSB2ZXJ5IGxvdyBkZWxheSwgZWcgPCAxMG1zLCBjYW4gZWxhcHNlIGJlZm9yZSBsaXN0ZW5lcnMgYXJlIGluaXRpYWxpemVkLlxuICAgICAgICBzaWduYWwuYWJvcnQoKTtcbiAgICB9LCB0aW1lb3V0TWlsbGlzICE9PSB1bmRlZmluZWQgPyB0aW1lb3V0TWlsbGlzIDogRkVUQ0hfVElNRU9VVF9NSUxMSVMpO1xuICAgIHJldHVybiBhdHRlbXB0RmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5KHsgYXBwSWQsIGFwaUtleSwgbWVhc3VyZW1lbnRJZCB9LCB0aHJvdHRsZU1ldGFkYXRhLCBzaWduYWwsIHJldHJ5RGF0YSk7XG59XG4vKipcbiAqIFJ1bnMgb25lIHJldHJ5IGF0dGVtcHQuXG4gKiBAcGFyYW0gYXBwRmllbGRzIE5lY2Vzc2FyeSBhcHAgY29uZmlnIGZpZWxkcy5cbiAqIEBwYXJhbSB0aHJvdHRsZU1ldGFkYXRhIE9uZ29pbmcgbWV0YWRhdGEgdG8gZGV0ZXJtaW5lIHRocm90dGxpbmcgdGltZXMuXG4gKiBAcGFyYW0gc2lnbmFsIEFib3J0IHNpZ25hbC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gYXR0ZW1wdEZldGNoRHluYW1pY0NvbmZpZ1dpdGhSZXRyeShhcHBGaWVsZHMsIHsgdGhyb3R0bGVFbmRUaW1lTWlsbGlzLCBiYWNrb2ZmQ291bnQgfSwgc2lnbmFsLCByZXRyeURhdGEgPSBkZWZhdWx0UmV0cnlEYXRhIC8vIGZvciB0ZXN0aW5nXG4pIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgeyBhcHBJZCwgbWVhc3VyZW1lbnRJZCB9ID0gYXBwRmllbGRzO1xuICAgIC8vIFN0YXJ0cyB3aXRoIGEgKHBvdGVudGlhbGx5IHplcm8pIHRpbWVvdXQgdG8gc3VwcG9ydCByZXN1bXB0aW9uIGZyb20gc3RvcmVkIHN0YXRlLlxuICAgIC8vIEVuc3VyZXMgdGhlIHRocm90dGxlIGVuZCB0aW1lIGlzIGhvbm9yZWQgaWYgdGhlIGxhc3QgYXR0ZW1wdCB0aW1lZCBvdXQuXG4gICAgLy8gTm90ZSB0aGUgU0RLIHdpbGwgbmV2ZXIgbWFrZSBhIHJlcXVlc3QgaWYgdGhlIGZldGNoIHRpbWVvdXQgZXhwaXJlcyBhdCB0aGlzIHBvaW50LlxuICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IHNldEFib3J0YWJsZVRpbWVvdXQoc2lnbmFsLCB0aHJvdHRsZUVuZFRpbWVNaWxsaXMpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAobWVhc3VyZW1lbnRJZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRpbWVkIG91dCBmZXRjaGluZyB0aGlzIEZpcmViYXNlIGFwcCdzIG1lYXN1cmVtZW50IElEIGZyb20gdGhlIHNlcnZlci5gICtcbiAgICAgICAgICAgICAgICBgIEZhbGxpbmcgYmFjayB0byB0aGUgbWVhc3VyZW1lbnQgSUQgJHttZWFzdXJlbWVudElkfWAgK1xuICAgICAgICAgICAgICAgIGAgcHJvdmlkZWQgaW4gdGhlIFwibWVhc3VyZW1lbnRJZFwiIGZpZWxkIGluIHRoZSBsb2NhbCBGaXJlYmFzZSBjb25maWcuIFske2UgPT09IG51bGwgfHwgZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZS5tZXNzYWdlfV1gKTtcbiAgICAgICAgICAgIHJldHVybiB7IGFwcElkLCBtZWFzdXJlbWVudElkIH07XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaER5bmFtaWNDb25maWcoYXBwRmllbGRzKTtcbiAgICAgICAgLy8gTm90ZSB0aGUgU0RLIG9ubHkgY2xlYXJzIHRocm90dGxlIHN0YXRlIGlmIHJlc3BvbnNlIGlzIHN1Y2Nlc3Mgb3Igbm9uLXJldHJpYWJsZS5cbiAgICAgICAgcmV0cnlEYXRhLmRlbGV0ZVRocm90dGxlTWV0YWRhdGEoYXBwSWQpO1xuICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gZTtcbiAgICAgICAgaWYgKCFpc1JldHJpYWJsZUVycm9yKGVycm9yKSkge1xuICAgICAgICAgICAgcmV0cnlEYXRhLmRlbGV0ZVRocm90dGxlTWV0YWRhdGEoYXBwSWQpO1xuICAgICAgICAgICAgaWYgKG1lYXN1cmVtZW50SWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRmFpbGVkIHRvIGZldGNoIHRoaXMgRmlyZWJhc2UgYXBwJ3MgbWVhc3VyZW1lbnQgSUQgZnJvbSB0aGUgc2VydmVyLmAgK1xuICAgICAgICAgICAgICAgICAgICBgIEZhbGxpbmcgYmFjayB0byB0aGUgbWVhc3VyZW1lbnQgSUQgJHttZWFzdXJlbWVudElkfWAgK1xuICAgICAgICAgICAgICAgICAgICBgIHByb3ZpZGVkIGluIHRoZSBcIm1lYXN1cmVtZW50SWRcIiBmaWVsZCBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBbJHtlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IubWVzc2FnZX1dYCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYXBwSWQsIG1lYXN1cmVtZW50SWQgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IGU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYmFja29mZk1pbGxpcyA9IE51bWJlcigoX2EgPSBlcnJvciA9PT0gbnVsbCB8fCBlcnJvciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyb3IuY3VzdG9tRGF0YSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmh0dHBTdGF0dXMpID09PSA1MDNcbiAgICAgICAgICAgID8gY2FsY3VsYXRlQmFja29mZk1pbGxpcyhiYWNrb2ZmQ291bnQsIHJldHJ5RGF0YS5pbnRlcnZhbE1pbGxpcywgTE9OR19SRVRSWV9GQUNUT1IpXG4gICAgICAgICAgICA6IGNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMoYmFja29mZkNvdW50LCByZXRyeURhdGEuaW50ZXJ2YWxNaWxsaXMpO1xuICAgICAgICAvLyBJbmNyZW1lbnRzIGJhY2tvZmYgc3RhdGUuXG4gICAgICAgIGNvbnN0IHRocm90dGxlTWV0YWRhdGEgPSB7XG4gICAgICAgICAgICB0aHJvdHRsZUVuZFRpbWVNaWxsaXM6IERhdGUubm93KCkgKyBiYWNrb2ZmTWlsbGlzLFxuICAgICAgICAgICAgYmFja29mZkNvdW50OiBiYWNrb2ZmQ291bnQgKyAxXG4gICAgICAgIH07XG4gICAgICAgIC8vIFBlcnNpc3RzIHN0YXRlLlxuICAgICAgICByZXRyeURhdGEuc2V0VGhyb3R0bGVNZXRhZGF0YShhcHBJZCwgdGhyb3R0bGVNZXRhZGF0YSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgQ2FsbGluZyBhdHRlbXB0RmV0Y2ggYWdhaW4gaW4gJHtiYWNrb2ZmTWlsbGlzfSBtaWxsaXNgKTtcbiAgICAgICAgcmV0dXJuIGF0dGVtcHRGZXRjaER5bmFtaWNDb25maWdXaXRoUmV0cnkoYXBwRmllbGRzLCB0aHJvdHRsZU1ldGFkYXRhLCBzaWduYWwsIHJldHJ5RGF0YSk7XG4gICAgfVxufVxuLyoqXG4gKiBTdXBwb3J0cyB3YWl0aW5nIG9uIGEgYmFja29mZiBieTpcbiAqXG4gKiA8dWw+XG4gKiAgIDxsaT5Qcm9taXNpZnlpbmcgc2V0VGltZW91dCwgc28gd2UgY2FuIHNldCBhIHRpbWVvdXQgaW4gb3VyIFByb21pc2UgY2hhaW48L2xpPlxuICogICA8bGk+TGlzdGVuaW5nIG9uIGEgc2lnbmFsIGJ1cyBmb3IgYWJvcnQgZXZlbnRzLCBqdXN0IGxpa2UgdGhlIEZldGNoIEFQSTwvbGk+XG4gKiAgIDxsaT5GYWlsaW5nIGluIHRoZSBzYW1lIHdheSB0aGUgRmV0Y2ggQVBJIGZhaWxzLCBzbyB0aW1pbmcgb3V0IGEgbGl2ZSByZXF1ZXN0IGFuZCBhIHRocm90dGxlZFxuICogICAgICAgcmVxdWVzdCBhcHBlYXIgdGhlIHNhbWUuPC9saT5cbiAqIDwvdWw+XG4gKlxuICogPHA+VmlzaWJsZSBmb3IgdGVzdGluZy5cbiAqL1xuZnVuY3Rpb24gc2V0QWJvcnRhYmxlVGltZW91dChzaWduYWwsIHRocm90dGxlRW5kVGltZU1pbGxpcykge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIC8vIERlcml2ZXMgYmFja29mZiBmcm9tIGdpdmVuIGVuZCB0aW1lLCBub3JtYWxpemluZyBuZWdhdGl2ZSBudW1iZXJzIHRvIHplcm8uXG4gICAgICAgIGNvbnN0IGJhY2tvZmZNaWxsaXMgPSBNYXRoLm1heCh0aHJvdHRsZUVuZFRpbWVNaWxsaXMgLSBEYXRlLm5vdygpLCAwKTtcbiAgICAgICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQocmVzb2x2ZSwgYmFja29mZk1pbGxpcyk7XG4gICAgICAgIC8vIEFkZHMgbGlzdGVuZXIsIHJhdGhlciB0aGFuIHNldHMgb25hYm9ydCwgYmVjYXVzZSBzaWduYWwgaXMgYSBzaGFyZWQgb2JqZWN0LlxuICAgICAgICBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcigoKSA9PiB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZW91dCk7XG4gICAgICAgICAgICAvLyBJZiB0aGUgcmVxdWVzdCBjb21wbGV0ZXMgYmVmb3JlIHRoaXMgdGltZW91dCwgdGhlIHJlamVjdGlvbiBoYXMgbm8gZWZmZWN0LlxuICAgICAgICAgICAgcmVqZWN0KEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiZmV0Y2gtdGhyb3R0bGVcIiAvKiBBbmFseXRpY3NFcnJvci5GRVRDSF9USFJPVFRMRSAqLywge1xuICAgICAgICAgICAgICAgIHRocm90dGxlRW5kVGltZU1pbGxpc1xuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIHRoZSB7QGxpbmsgRXJyb3J9IGluZGljYXRlcyBhIGZldGNoIHJlcXVlc3QgbWF5IHN1Y2NlZWQgbGF0ZXIuXG4gKi9cbmZ1bmN0aW9uIGlzUmV0cmlhYmxlRXJyb3IoZSkge1xuICAgIGlmICghKGUgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yKSB8fCAhZS5jdXN0b21EYXRhKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLy8gVXNlcyBzdHJpbmcgaW5kZXggZGVmaW5lZCBieSBFcnJvckRhdGEsIHdoaWNoIEZpcmViYXNlRXJyb3IgaW1wbGVtZW50cy5cbiAgICBjb25zdCBodHRwU3RhdHVzID0gTnVtYmVyKGUuY3VzdG9tRGF0YVsnaHR0cFN0YXR1cyddKTtcbiAgICByZXR1cm4gKGh0dHBTdGF0dXMgPT09IDQyOSB8fFxuICAgICAgICBodHRwU3RhdHVzID09PSA1MDAgfHxcbiAgICAgICAgaHR0cFN0YXR1cyA9PT0gNTAzIHx8XG4gICAgICAgIGh0dHBTdGF0dXMgPT09IDUwNCk7XG59XG4vKipcbiAqIFNoaW1zIGEgbWluaW1hbCBBYm9ydFNpZ25hbCAoY29waWVkIGZyb20gUmVtb3RlIENvbmZpZykuXG4gKlxuICogPHA+QWJvcnRDb250cm9sbGVyJ3MgQWJvcnRTaWduYWwgY29udmVuaWVudGx5IGRlY291cGxlcyBmZXRjaCB0aW1lb3V0IGxvZ2ljIGZyb20gb3RoZXIgYXNwZWN0c1xuICogb2YgbmV0d29ya2luZywgc3VjaCBhcyByZXRyaWVzLiBGaXJlYmFzZSBkb2Vzbid0IHVzZSBBYm9ydENvbnRyb2xsZXIgZW5vdWdoIHRvIGp1c3RpZnkgYVxuICogcG9seWZpbGwgcmVjb21tZW5kYXRpb24sIGxpa2Ugd2UgZG8gd2l0aCB0aGUgRmV0Y2ggQVBJLCBidXQgdGhpcyBtaW5pbWFsIHNoaW0gY2FuIGVhc2lseSBiZVxuICogc3dhcHBlZCBvdXQgaWYvd2hlbiB3ZSBkby5cbiAqL1xuY2xhc3MgQW5hbHl0aWNzQWJvcnRTaWduYWwge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmxpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBhZGRFdmVudExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMubGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICAgIH1cbiAgICBhYm9ydCgpIHtcbiAgICAgICAgdGhpcy5saXN0ZW5lcnMuZm9yRWFjaChsaXN0ZW5lciA9PiBsaXN0ZW5lcigpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEV2ZW50IHBhcmFtZXRlcnMgdG8gc2V0IG9uICdndGFnJyBkdXJpbmcgaW5pdGlhbGl6YXRpb24uXG4gKi9cbmxldCBkZWZhdWx0RXZlbnRQYXJhbWV0ZXJzRm9ySW5pdDtcbi8qKlxuICogTG9ncyBhbiBhbmFseXRpY3MgZXZlbnQgdGhyb3VnaCB0aGUgRmlyZWJhc2UgU0RLLlxuICpcbiAqIEBwYXJhbSBndGFnRnVuY3Rpb24gV3JhcHBlZCBndGFnIGZ1bmN0aW9uIHRoYXQgd2FpdHMgZm9yIGZpZCB0byBiZSBzZXQgYmVmb3JlIHNlbmRpbmcgYW4gZXZlbnRcbiAqIEBwYXJhbSBldmVudE5hbWUgR29vZ2xlIEFuYWx5dGljcyBldmVudCBuYW1lLCBjaG9vc2UgZnJvbSBzdGFuZGFyZCBsaXN0IG9yIHVzZSBhIGN1c3RvbSBzdHJpbmcuXG4gKiBAcGFyYW0gZXZlbnRQYXJhbXMgQW5hbHl0aWNzIGV2ZW50IHBhcmFtZXRlcnMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGxvZ0V2ZW50JDEoZ3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2UsIGV2ZW50TmFtZSwgZXZlbnRQYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCkge1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJldmVudFwiIC8qIEd0YWdDb21tYW5kLkVWRU5UICovLCBldmVudE5hbWUsIGV2ZW50UGFyYW1zKTtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJZCA9IGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBldmVudFBhcmFtcyksIHsgJ3NlbmRfdG8nOiBtZWFzdXJlbWVudElkIH0pO1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJldmVudFwiIC8qIEd0YWdDb21tYW5kLkVWRU5UICovLCBldmVudE5hbWUsIHBhcmFtcyk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgc2NyZWVuX25hbWUgcGFyYW1ldGVyIGZvciB0aGlzIEdvb2dsZSBBbmFseXRpY3MgSUQuXG4gKlxuICogQGRlcHJlY2F0ZWQgVXNlIHtAbGluayBsb2dFdmVudH0gd2l0aCBgZXZlbnROYW1lYCBhcyAnc2NyZWVuX3ZpZXcnIGFuZCBhZGQgcmVsZXZhbnQgYGV2ZW50UGFyYW1zYC5cbiAqIFNlZSB7QGxpbmsgaHR0cHM6Ly9maXJlYmFzZS5nb29nbGUuY29tL2RvY3MvYW5hbHl0aWNzL3NjcmVlbnZpZXdzIHwgVHJhY2sgU2NyZWVudmlld3N9LlxuICpcbiAqIEBwYXJhbSBndGFnRnVuY3Rpb24gV3JhcHBlZCBndGFnIGZ1bmN0aW9uIHRoYXQgd2FpdHMgZm9yIGZpZCB0byBiZSBzZXQgYmVmb3JlIHNlbmRpbmcgYW4gZXZlbnRcbiAqIEBwYXJhbSBzY3JlZW5OYW1lIFNjcmVlbiBuYW1lIHN0cmluZyB0byBzZXQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldEN1cnJlbnRTY3JlZW4kMShndGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZSwgc2NyZWVuTmFtZSwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgICAgIGd0YWdGdW5jdGlvbihcInNldFwiIC8qIEd0YWdDb21tYW5kLlNFVCAqLywgeyAnc2NyZWVuX25hbWUnOiBzY3JlZW5OYW1lIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudElkID0gYXdhaXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJjb25maWdcIiAvKiBHdGFnQ29tbWFuZC5DT05GSUcgKi8sIG1lYXN1cmVtZW50SWQsIHtcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICdzY3JlZW5fbmFtZSc6IHNjcmVlbk5hbWVcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgdXNlcl9pZCBwYXJhbWV0ZXIgZm9yIHRoaXMgR29vZ2xlIEFuYWx5dGljcyBJRC5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0Z1bmN0aW9uIFdyYXBwZWQgZ3RhZyBmdW5jdGlvbiB0aGF0IHdhaXRzIGZvciBmaWQgdG8gYmUgc2V0IGJlZm9yZSBzZW5kaW5nIGFuIGV2ZW50XG4gKiBAcGFyYW0gaWQgVXNlciBJRCBzdHJpbmcgdG8gc2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldFVzZXJJZCQxKGd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlLCBpZCwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZ2xvYmFsKSB7XG4gICAgICAgIGd0YWdGdW5jdGlvbihcInNldFwiIC8qIEd0YWdDb21tYW5kLlNFVCAqLywgeyAndXNlcl9pZCc6IGlkIH0pO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBjb25zdCBtZWFzdXJlbWVudElkID0gYXdhaXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgICAgICBndGFnRnVuY3Rpb24oXCJjb25maWdcIiAvKiBHdGFnQ29tbWFuZC5DT05GSUcgKi8sIG1lYXN1cmVtZW50SWQsIHtcbiAgICAgICAgICAgIHVwZGF0ZTogdHJ1ZSxcbiAgICAgICAgICAgICd1c2VyX2lkJzogaWRcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBTZXQgYWxsIG90aGVyIHVzZXIgcHJvcGVydGllcyBvdGhlciB0aGFuIHVzZXJfaWQgYW5kIHNjcmVlbl9uYW1lLlxuICpcbiAqIEBwYXJhbSBndGFnRnVuY3Rpb24gV3JhcHBlZCBndGFnIGZ1bmN0aW9uIHRoYXQgd2FpdHMgZm9yIGZpZCB0byBiZSBzZXQgYmVmb3JlIHNlbmRpbmcgYW4gZXZlbnRcbiAqIEBwYXJhbSBwcm9wZXJ0aWVzIE1hcCBvZiB1c2VyIHByb3BlcnRpZXMgdG8gc2V0XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHNldFVzZXJQcm9wZXJ0aWVzJDEoZ3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2UsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdsb2JhbCkge1xuICAgICAgICBjb25zdCBmbGF0UHJvcGVydGllcyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwcm9wZXJ0aWVzKSkge1xuICAgICAgICAgICAgLy8gdXNlIGRvdCBub3RhdGlvbiBmb3IgbWVyZ2UgYmVoYXZpb3IgaW4gZ3RhZy5qc1xuICAgICAgICAgICAgZmxhdFByb3BlcnRpZXNbYHVzZXJfcHJvcGVydGllcy4ke2tleX1gXSA9IHByb3BlcnRpZXNba2V5XTtcbiAgICAgICAgfVxuICAgICAgICBndGFnRnVuY3Rpb24oXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIGZsYXRQcm9wZXJ0aWVzKTtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZSgpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc3QgbWVhc3VyZW1lbnRJZCA9IGF3YWl0IGluaXRpYWxpemF0aW9uUHJvbWlzZTtcbiAgICAgICAgZ3RhZ0Z1bmN0aW9uKFwiY29uZmlnXCIgLyogR3RhZ0NvbW1hbmQuQ09ORklHICovLCBtZWFzdXJlbWVudElkLCB7XG4gICAgICAgICAgICB1cGRhdGU6IHRydWUsXG4gICAgICAgICAgICAndXNlcl9wcm9wZXJ0aWVzJzogcHJvcGVydGllc1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIFJldHJpZXZlcyBhIHVuaXF1ZSBHb29nbGUgQW5hbHl0aWNzIGlkZW50aWZpZXIgZm9yIHRoZSB3ZWIgY2xpZW50LlxuICogU2VlIHtAbGluayBodHRwczovL2RldmVsb3BlcnMuZ29vZ2xlLmNvbS9hbmFseXRpY3MvZGV2Z3VpZGVzL2NvbGxlY3Rpb24vZ2E0L3JlZmVyZW5jZS9jb25maWcjY2xpZW50X2lkIHwgY2xpZW50X2lkfS5cbiAqXG4gKiBAcGFyYW0gZ3RhZ0Z1bmN0aW9uIFdyYXBwZWQgZ3RhZyBmdW5jdGlvbiB0aGF0IHdhaXRzIGZvciBmaWQgdG8gYmUgc2V0IGJlZm9yZSBzZW5kaW5nIGFuIGV2ZW50XG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGludGVybmFsR2V0R29vZ2xlQW5hbHl0aWNzQ2xpZW50SWQoZ3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2UpIHtcbiAgICBjb25zdCBtZWFzdXJlbWVudElkID0gYXdhaXQgaW5pdGlhbGl6YXRpb25Qcm9taXNlO1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgIGd0YWdGdW5jdGlvbihcImdldFwiIC8qIEd0YWdDb21tYW5kLkdFVCAqLywgbWVhc3VyZW1lbnRJZCwgJ2NsaWVudF9pZCcsIChjbGllbnRJZCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFjbGllbnRJZCkge1xuICAgICAgICAgICAgICAgIHJlamVjdChFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWNsaWVudC1pZFwiIC8qIEFuYWx5dGljc0Vycm9yLk5PX0NMSUVOVF9JRCAqLykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZShjbGllbnRJZCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuLyoqXG4gKiBTZXQgd2hldGhlciBjb2xsZWN0aW9uIGlzIGVuYWJsZWQgZm9yIHRoaXMgSUQuXG4gKlxuICogQHBhcmFtIGVuYWJsZWQgSWYgdHJ1ZSwgY29sbGVjdGlvbiBpcyBlbmFibGVkIGZvciB0aGlzIElELlxuICovXG5hc3luYyBmdW5jdGlvbiBzZXRBbmFseXRpY3NDb2xsZWN0aW9uRW5hYmxlZCQxKGluaXRpYWxpemF0aW9uUHJvbWlzZSwgZW5hYmxlZCkge1xuICAgIGNvbnN0IG1lYXN1cmVtZW50SWQgPSBhd2FpdCBpbml0aWFsaXphdGlvblByb21pc2U7XG4gICAgd2luZG93W2BnYS1kaXNhYmxlLSR7bWVhc3VyZW1lbnRJZH1gXSA9ICFlbmFibGVkO1xufVxuLyoqXG4gKiBDb25zZW50IHBhcmFtZXRlcnMgdG8gZGVmYXVsdCB0byBkdXJpbmcgJ2d0YWcnIGluaXRpYWxpemF0aW9uLlxuICovXG5sZXQgZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXQ7XG4vKipcbiAqIFNldHMgdGhlIHZhcmlhYmxlIHtAbGluayBkZWZhdWx0Q29uc2VudFNldHRpbmdzRm9ySW5pdH0gZm9yIHVzZSBpbiB0aGUgaW5pdGlhbGl6YXRpb24gb2ZcbiAqIGFuYWx5dGljcy5cbiAqXG4gKiBAcGFyYW0gY29uc2VudFNldHRpbmdzIE1hcHMgdGhlIGFwcGxpY2FibGUgZW5kIHVzZXIgY29uc2VudCBzdGF0ZSBmb3IgZ3RhZy5qcy5cbiAqL1xuZnVuY3Rpb24gX3NldENvbnNlbnREZWZhdWx0Rm9ySW5pdChjb25zZW50U2V0dGluZ3MpIHtcbiAgICBkZWZhdWx0Q29uc2VudFNldHRpbmdzRm9ySW5pdCA9IGNvbnNlbnRTZXR0aW5ncztcbn1cbi8qKlxuICogU2V0cyB0aGUgdmFyaWFibGUgYGRlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0YCBmb3IgdXNlIGluIHRoZSBpbml0aWFsaXphdGlvbiBvZlxuICogYW5hbHl0aWNzLlxuICpcbiAqIEBwYXJhbSBjdXN0b21QYXJhbXMgQW55IGN1c3RvbSBwYXJhbXMgdGhlIHVzZXIgbWF5IHBhc3MgdG8gZ3RhZy5qcy5cbiAqL1xuZnVuY3Rpb24gX3NldERlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KGN1c3RvbVBhcmFtcykge1xuICAgIGRlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0ID0gY3VzdG9tUGFyYW1zO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAyMCBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gdmFsaWRhdGVJbmRleGVkREIoKSB7XG4gICAgaWYgKCFpc0luZGV4ZWREQkF2YWlsYWJsZSgpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5kZXhlZGRiLXVuYXZhaWxhYmxlXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5ERVhFRERCX1VOQVZBSUxBQkxFICovLCB7XG4gICAgICAgICAgICBlcnJvckluZm86ICdJbmRleGVkREIgaXMgbm90IGF2YWlsYWJsZSBpbiB0aGlzIGVudmlyb25tZW50LidcbiAgICAgICAgfSkubWVzc2FnZSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5kZXhlZGRiLXVuYXZhaWxhYmxlXCIgLyogQW5hbHl0aWNzRXJyb3IuSU5ERVhFRERCX1VOQVZBSUxBQkxFICovLCB7XG4gICAgICAgICAgICAgICAgZXJyb3JJbmZvOiBlID09PSBudWxsIHx8IGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGUudG9TdHJpbmcoKVxuICAgICAgICAgICAgfSkubWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG4vKipcbiAqIEluaXRpYWxpemUgdGhlIGFuYWx5dGljcyBpbnN0YW5jZSBpbiBndGFnLmpzIGJ5IGNhbGxpbmcgY29uZmlnIGNvbW1hbmQgd2l0aCBmaWQuXG4gKlxuICogTk9URTogV2UgY29tYmluZSBhbmFseXRpY3MgaW5pdGlhbGl6YXRpb24gYW5kIHNldHRpbmcgZmlkIHRvZ2V0aGVyIGJlY2F1c2Ugd2Ugd2FudCBmaWQgdG8gYmVcbiAqIHBhcnQgb2YgdGhlIGBwYWdlX3ZpZXdgIGV2ZW50IHRoYXQncyBzZW50IGR1cmluZyB0aGUgaW5pdGlhbGl6YXRpb25cbiAqIEBwYXJhbSBhcHAgRmlyZWJhc2UgYXBwXG4gKiBAcGFyYW0gZ3RhZ0NvcmUgVGhlIGd0YWcgZnVuY3Rpb24gdGhhdCdzIG5vdCB3cmFwcGVkLlxuICogQHBhcmFtIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QgQXJyYXkgb2YgYWxsIGR5bmFtaWMgY29uZmlnIHByb21pc2VzLlxuICogQHBhcmFtIG1lYXN1cmVtZW50SWRUb0FwcElkIE1hcHMgbWVhc3VyZW1lbnRJRCB0byBhcHBJRC5cbiAqIEBwYXJhbSBpbnN0YWxsYXRpb25zIF9GaXJlYmFzZUluc3RhbGxhdGlvbnNJbnRlcm5hbCBpbnN0YW5jZS5cbiAqXG4gKiBAcmV0dXJucyBNZWFzdXJlbWVudCBJRC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gX2luaXRpYWxpemVBbmFseXRpY3MoYXBwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkVG9BcHBJZCwgaW5zdGFsbGF0aW9ucywgZ3RhZ0NvcmUsIGRhdGFMYXllck5hbWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX2E7XG4gICAgY29uc3QgZHluYW1pY0NvbmZpZ1Byb21pc2UgPSBmZXRjaER5bmFtaWNDb25maWdXaXRoUmV0cnkoYXBwKTtcbiAgICAvLyBPbmNlIGZldGNoZWQsIG1hcCBtZWFzdXJlbWVudElkcyB0byBhcHBJZCwgZm9yIGVhc2Ugb2YgbG9va3VwIGluIHdyYXBwZWQgZ3RhZyBmdW5jdGlvbi5cbiAgICBkeW5hbWljQ29uZmlnUHJvbWlzZVxuICAgICAgICAudGhlbihjb25maWcgPT4ge1xuICAgICAgICBtZWFzdXJlbWVudElkVG9BcHBJZFtjb25maWcubWVhc3VyZW1lbnRJZF0gPSBjb25maWcuYXBwSWQ7XG4gICAgICAgIGlmIChhcHAub3B0aW9ucy5tZWFzdXJlbWVudElkICYmXG4gICAgICAgICAgICBjb25maWcubWVhc3VyZW1lbnRJZCAhPT0gYXBwLm9wdGlvbnMubWVhc3VyZW1lbnRJZCkge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oYFRoZSBtZWFzdXJlbWVudCBJRCBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnICgke2FwcC5vcHRpb25zLm1lYXN1cmVtZW50SWR9KWAgK1xuICAgICAgICAgICAgICAgIGAgZG9lcyBub3QgbWF0Y2ggdGhlIG1lYXN1cmVtZW50IElEIGZldGNoZWQgZnJvbSB0aGUgc2VydmVyICgke2NvbmZpZy5tZWFzdXJlbWVudElkfSkuYCArXG4gICAgICAgICAgICAgICAgYCBUbyBlbnN1cmUgYW5hbHl0aWNzIGV2ZW50cyBhcmUgYWx3YXlzIHNlbnQgdG8gdGhlIGNvcnJlY3QgQW5hbHl0aWNzIHByb3BlcnR5LGAgK1xuICAgICAgICAgICAgICAgIGAgdXBkYXRlIHRoZWAgK1xuICAgICAgICAgICAgICAgIGAgbWVhc3VyZW1lbnQgSUQgZmllbGQgaW4gdGhlIGxvY2FsIGNvbmZpZyBvciByZW1vdmUgaXQgZnJvbSB0aGUgbG9jYWwgY29uZmlnLmApO1xuICAgICAgICB9XG4gICAgfSlcbiAgICAgICAgLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGUpKTtcbiAgICAvLyBBZGQgdG8gbGlzdCB0byB0cmFjayBzdGF0ZSBvZiBhbGwgZHluYW1pYyBjb25maWcgcHJvbWlzZXMuXG4gICAgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdC5wdXNoKGR5bmFtaWNDb25maWdQcm9taXNlKTtcbiAgICBjb25zdCBmaWRQcm9taXNlID0gdmFsaWRhdGVJbmRleGVkREIoKS50aGVuKGVudklzVmFsaWQgPT4ge1xuICAgICAgICBpZiAoZW52SXNWYWxpZCkge1xuICAgICAgICAgICAgcmV0dXJuIGluc3RhbGxhdGlvbnMuZ2V0SWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBbZHluYW1pY0NvbmZpZywgZmlkXSA9IGF3YWl0IFByb21pc2UuYWxsKFtcbiAgICAgICAgZHluYW1pY0NvbmZpZ1Byb21pc2UsXG4gICAgICAgIGZpZFByb21pc2VcbiAgICBdKTtcbiAgICAvLyBEZXRlY3QgaWYgdXNlciBoYXMgYWxyZWFkeSBwdXQgdGhlIGd0YWcgPHNjcmlwdD4gdGFnIG9uIHRoaXMgcGFnZSB3aXRoIHRoZSBwYXNzZWQgaW5cbiAgICAvLyBkYXRhIGxheWVyIG5hbWUuXG4gICAgaWYgKCFmaW5kR3RhZ1NjcmlwdE9uUGFnZShkYXRhTGF5ZXJOYW1lKSkge1xuICAgICAgICBpbnNlcnRTY3JpcHRUYWcoZGF0YUxheWVyTmFtZSwgZHluYW1pY0NvbmZpZy5tZWFzdXJlbWVudElkKTtcbiAgICB9XG4gICAgLy8gRGV0ZWN0cyBpZiB0aGVyZSBhcmUgY29uc2VudCBzZXR0aW5ncyB0aGF0IG5lZWQgdG8gYmUgY29uZmlndXJlZC5cbiAgICBpZiAoZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXQpIHtcbiAgICAgICAgZ3RhZ0NvcmUoXCJjb25zZW50XCIgLyogR3RhZ0NvbW1hbmQuQ09OU0VOVCAqLywgJ2RlZmF1bHQnLCBkZWZhdWx0Q29uc2VudFNldHRpbmdzRm9ySW5pdCk7XG4gICAgICAgIF9zZXRDb25zZW50RGVmYXVsdEZvckluaXQodW5kZWZpbmVkKTtcbiAgICB9XG4gICAgLy8gVGhpcyBjb21tYW5kIGluaXRpYWxpemVzIGd0YWcuanMgYW5kIG9ubHkgbmVlZHMgdG8gYmUgY2FsbGVkIG9uY2UgZm9yIHRoZSBlbnRpcmUgd2ViIGFwcCxcbiAgICAvLyBidXQgc2luY2UgaXQgaXMgaWRlbXBvdGVudCwgd2UgY2FuIGNhbGwgaXQgbXVsdGlwbGUgdGltZXMuXG4gICAgLy8gV2Uga2VlcCBpdCB0b2dldGhlciB3aXRoIG90aGVyIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBiZXR0ZXIgY29kZSBzdHJ1Y3R1cmUuXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBndGFnQ29yZSgnanMnLCBuZXcgRGF0ZSgpKTtcbiAgICAvLyBVc2VyIGNvbmZpZyBhZGRlZCBmaXJzdC4gV2UgZG9uJ3Qgd2FudCB1c2VycyB0byBhY2NpZGVudGFsbHkgb3ZlcndyaXRlXG4gICAgLy8gYmFzZSBGaXJlYmFzZSBjb25maWcgcHJvcGVydGllcy5cbiAgICBjb25zdCBjb25maWdQcm9wZXJ0aWVzID0gKF9hID0gb3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmNvbmZpZykgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDoge307XG4gICAgLy8gZ3VhcmQgYWdhaW5zdCBkZXZlbG9wZXJzIGFjY2lkZW50YWxseSBzZXR0aW5nIHByb3BlcnRpZXMgd2l0aCBwcmVmaXggYGZpcmViYXNlX2BcbiAgICBjb25maWdQcm9wZXJ0aWVzW09SSUdJTl9LRVldID0gJ2ZpcmViYXNlJztcbiAgICBjb25maWdQcm9wZXJ0aWVzLnVwZGF0ZSA9IHRydWU7XG4gICAgaWYgKGZpZCAhPSBudWxsKSB7XG4gICAgICAgIGNvbmZpZ1Byb3BlcnRpZXNbR0FfRklEX0tFWV0gPSBmaWQ7XG4gICAgfVxuICAgIC8vIEl0IHNob3VsZCBiZSB0aGUgZmlyc3QgY29uZmlnIGNvbW1hbmQgY2FsbGVkIG9uIHRoaXMgR0EtSURcbiAgICAvLyBJbml0aWFsaXplIHRoaXMgR0EtSUQgYW5kIHNldCBGSUQgb24gaXQgdXNpbmcgdGhlIGd0YWcgY29uZmlnIEFQSS5cbiAgICAvLyBOb3RlOiBUaGlzIHdpbGwgdHJpZ2dlciBhIHBhZ2VfdmlldyBldmVudCB1bmxlc3MgJ3NlbmRfcGFnZV92aWV3JyBpcyBzZXQgdG8gZmFsc2UgaW5cbiAgICAvLyBgY29uZmlnUHJvcGVydGllc2AuXG4gICAgZ3RhZ0NvcmUoXCJjb25maWdcIiAvKiBHdGFnQ29tbWFuZC5DT05GSUcgKi8sIGR5bmFtaWNDb25maWcubWVhc3VyZW1lbnRJZCwgY29uZmlnUHJvcGVydGllcyk7XG4gICAgLy8gRGV0ZWN0cyBpZiB0aGVyZSBpcyBkYXRhIHRoYXQgd2lsbCBiZSBzZXQgb24gZXZlcnkgZXZlbnQgbG9nZ2VkIGZyb20gdGhlIFNESy5cbiAgICBpZiAoZGVmYXVsdEV2ZW50UGFyYW1ldGVyc0ZvckluaXQpIHtcbiAgICAgICAgZ3RhZ0NvcmUoXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIGRlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KTtcbiAgICAgICAgX3NldERlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0KHVuZGVmaW5lZCk7XG4gICAgfVxuICAgIHJldHVybiBkeW5hbWljQ29uZmlnLm1lYXN1cmVtZW50SWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIEFuYWx5dGljcyBTZXJ2aWNlIGNsYXNzLlxuICovXG5jbGFzcyBBbmFseXRpY3NTZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihhcHApIHtcbiAgICAgICAgdGhpcy5hcHAgPSBhcHA7XG4gICAgfVxuICAgIF9kZWxldGUoKSB7XG4gICAgICAgIGRlbGV0ZSBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW3RoaXMuYXBwLm9wdGlvbnMuYXBwSWRdO1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgfVxufVxuLyoqXG4gKiBNYXBzIGFwcElkIHRvIGZ1bGwgaW5pdGlhbGl6YXRpb24gcHJvbWlzZS4gV3JhcHBlZCBndGFnIGNhbGxzIG11c3Qgd2FpdCBvblxuICogYWxsIG9yIHNvbWUgb2YgdGhlc2UsIGRlcGVuZGluZyBvbiB0aGUgY2FsbCdzIGBzZW5kX3RvYCBwYXJhbSBhbmQgdGhlIHN0YXR1c1xuICogb2YgdGhlIGR5bmFtaWMgY29uZmlnIGZldGNoZXMgKHNlZSBiZWxvdykuXG4gKi9cbmxldCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwID0ge307XG4vKipcbiAqIExpc3Qgb2YgZHluYW1pYyBjb25maWcgZmV0Y2ggcHJvbWlzZXMuIEluIGNlcnRhaW4gY2FzZXMsIHdyYXBwZWQgZ3RhZyBjYWxsc1xuICogd2FpdCBvbiBhbGwgdGhlc2UgdG8gYmUgY29tcGxldGUgaW4gb3JkZXIgdG8gZGV0ZXJtaW5lIGlmIGl0IGNhbiBzZWxlY3RpdmVseVxuICogd2FpdCBmb3Igb25seSBjZXJ0YWluIGluaXRpYWxpemF0aW9uIChGSUQpIHByb21pc2VzIG9yIGlmIGl0IG11c3Qgd2FpdCBmb3IgYWxsLlxuICovXG5sZXQgZHluYW1pY0NvbmZpZ1Byb21pc2VzTGlzdCA9IFtdO1xuLyoqXG4gKiBNYXBzIGZldGNoZWQgbWVhc3VyZW1lbnRJZHMgdG8gYXBwSWQuIFBvcHVsYXRlZCB3aGVuIHRoZSBhcHAncyBkeW5hbWljIGNvbmZpZ1xuICogZmV0Y2ggY29tcGxldGVzLiBJZiBhbHJlYWR5IHBvcHVsYXRlZCwgZ3RhZyBjb25maWcgY2FsbHMgY2FuIHVzZSB0aGlzIHRvXG4gKiBzZWxlY3RpdmVseSB3YWl0IGZvciBvbmx5IHRoaXMgYXBwJ3MgaW5pdGlhbGl6YXRpb24gcHJvbWlzZSAoRklEKSBpbnN0ZWFkIG9mIGFsbFxuICogaW5pdGlhbGl6YXRpb24gcHJvbWlzZXMuXG4gKi9cbmNvbnN0IG1lYXN1cmVtZW50SWRUb0FwcElkID0ge307XG4vKipcbiAqIE5hbWUgZm9yIHdpbmRvdyBnbG9iYWwgZGF0YSBsYXllciBhcnJheSB1c2VkIGJ5IEdBOiBkZWZhdWx0cyB0byAnZGF0YUxheWVyJy5cbiAqL1xubGV0IGRhdGFMYXllck5hbWUgPSAnZGF0YUxheWVyJztcbi8qKlxuICogTmFtZSBmb3Igd2luZG93IGdsb2JhbCBndGFnIGZ1bmN0aW9uIHVzZWQgYnkgR0E6IGRlZmF1bHRzIHRvICdndGFnJy5cbiAqL1xubGV0IGd0YWdOYW1lID0gJ2d0YWcnO1xuLyoqXG4gKiBSZXByb2R1Y3Rpb24gb2Ygc3RhbmRhcmQgZ3RhZyBmdW5jdGlvbiBvciByZWZlcmVuY2UgdG8gZXhpc3RpbmdcbiAqIGd0YWcgZnVuY3Rpb24gb24gd2luZG93IG9iamVjdC5cbiAqL1xubGV0IGd0YWdDb3JlRnVuY3Rpb247XG4vKipcbiAqIFdyYXBwZXIgYXJvdW5kIGd0YWcgZnVuY3Rpb24gdGhhdCBlbnN1cmVzIEZJRCBpcyBzZW50IHdpdGggYWxsXG4gKiByZWxldmFudCBldmVudCBhbmQgY29uZmlnIGNhbGxzLlxuICovXG5sZXQgd3JhcHBlZEd0YWdGdW5jdGlvbjtcbi8qKlxuICogRmxhZyB0byBlbnN1cmUgcGFnZSBpbml0aWFsaXphdGlvbiBzdGVwcyAoY3JlYXRpb24gb3Igd3JhcHBpbmcgb2ZcbiAqIGRhdGFMYXllciBhbmQgZ3RhZyBzY3JpcHQpIGFyZSBvbmx5IHJ1biBvbmNlIHBlciBwYWdlIGxvYWQuXG4gKi9cbmxldCBnbG9iYWxJbml0RG9uZSA9IGZhbHNlO1xuLyoqXG4gKiBDb25maWd1cmVzIEZpcmViYXNlIEFuYWx5dGljcyB0byB1c2UgY3VzdG9tIGBndGFnYCBvciBgZGF0YUxheWVyYCBuYW1lcy5cbiAqIEludGVuZGVkIHRvIGJlIHVzZWQgaWYgYGd0YWcuanNgIHNjcmlwdCBoYXMgYmVlbiBpbnN0YWxsZWQgb25cbiAqIHRoaXMgcGFnZSBpbmRlcGVuZGVudGx5IG9mIEZpcmViYXNlIEFuYWx5dGljcywgYW5kIGlzIHVzaW5nIG5vbi1kZWZhdWx0XG4gKiBuYW1lcyBmb3IgZWl0aGVyIHRoZSBgZ3RhZ2AgZnVuY3Rpb24gb3IgZm9yIGBkYXRhTGF5ZXJgLlxuICogTXVzdCBiZSBjYWxsZWQgYmVmb3JlIGNhbGxpbmcgYGdldEFuYWx5dGljcygpYCBvciBpdCB3b24ndFxuICogaGF2ZSBhbnkgZWZmZWN0LlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gb3B0aW9ucyAtIEN1c3RvbSBndGFnIGFuZCBkYXRhTGF5ZXIgbmFtZXMuXG4gKi9cbmZ1bmN0aW9uIHNldHRpbmdzKG9wdGlvbnMpIHtcbiAgICBpZiAoZ2xvYmFsSW5pdERvbmUpIHtcbiAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhbHJlYWR5LWluaXRpYWxpemVkXCIgLyogQW5hbHl0aWNzRXJyb3IuQUxSRUFEWV9JTklUSUFMSVpFRCAqLyk7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmRhdGFMYXllck5hbWUpIHtcbiAgICAgICAgZGF0YUxheWVyTmFtZSA9IG9wdGlvbnMuZGF0YUxheWVyTmFtZTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuZ3RhZ05hbWUpIHtcbiAgICAgICAgZ3RhZ05hbWUgPSBvcHRpb25zLmd0YWdOYW1lO1xuICAgIH1cbn1cbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIG5vIGVudmlyb25tZW50IG1pc21hdGNoIGlzIGZvdW5kLlxuICogSWYgZW52aXJvbm1lbnQgbWlzbWF0Y2hlcyBhcmUgZm91bmQsIHRocm93cyBhbiBJTlZBTElEX0FOQUxZVElDU19DT05URVhUXG4gKiBlcnJvciB0aGF0IGFsc28gbGlzdHMgZGV0YWlscyBmb3IgZWFjaCBtaXNtYXRjaCBmb3VuZC5cbiAqL1xuZnVuY3Rpb24gd2Fybk9uQnJvd3NlckNvbnRleHRNaXNtYXRjaCgpIHtcbiAgICBjb25zdCBtaXNtYXRjaGVkRW52TWVzc2FnZXMgPSBbXTtcbiAgICBpZiAoaXNCcm93c2VyRXh0ZW5zaW9uKCkpIHtcbiAgICAgICAgbWlzbWF0Y2hlZEVudk1lc3NhZ2VzLnB1c2goJ1RoaXMgaXMgYSBicm93c2VyIGV4dGVuc2lvbiBlbnZpcm9ubWVudC4nKTtcbiAgICB9XG4gICAgaWYgKCFhcmVDb29raWVzRW5hYmxlZCgpKSB7XG4gICAgICAgIG1pc21hdGNoZWRFbnZNZXNzYWdlcy5wdXNoKCdDb29raWVzIGFyZSBub3QgYXZhaWxhYmxlLicpO1xuICAgIH1cbiAgICBpZiAobWlzbWF0Y2hlZEVudk1lc3NhZ2VzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY29uc3QgZGV0YWlscyA9IG1pc21hdGNoZWRFbnZNZXNzYWdlc1xuICAgICAgICAgICAgLm1hcCgobWVzc2FnZSwgaW5kZXgpID0+IGAoJHtpbmRleCArIDF9KSAke21lc3NhZ2V9YClcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgIGNvbnN0IGVyciA9IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW52YWxpZC1hbmFseXRpY3MtY29udGV4dFwiIC8qIEFuYWx5dGljc0Vycm9yLklOVkFMSURfQU5BTFlUSUNTX0NPTlRFWFQgKi8sIHtcbiAgICAgICAgICAgIGVycm9ySW5mbzogZGV0YWlsc1xuICAgICAgICB9KTtcbiAgICAgICAgbG9nZ2VyLndhcm4oZXJyLm1lc3NhZ2UpO1xuICAgIH1cbn1cbi8qKlxuICogQW5hbHl0aWNzIGluc3RhbmNlIGZhY3RvcnkuXG4gKiBAaW50ZXJuYWxcbiAqL1xuZnVuY3Rpb24gZmFjdG9yeShhcHAsIGluc3RhbGxhdGlvbnMsIG9wdGlvbnMpIHtcbiAgICB3YXJuT25Ccm93c2VyQ29udGV4dE1pc21hdGNoKCk7XG4gICAgY29uc3QgYXBwSWQgPSBhcHAub3B0aW9ucy5hcHBJZDtcbiAgICBpZiAoIWFwcElkKSB7XG4gICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwibm8tYXBwLWlkXCIgLyogQW5hbHl0aWNzRXJyb3IuTk9fQVBQX0lEICovKTtcbiAgICB9XG4gICAgaWYgKCFhcHAub3B0aW9ucy5hcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwcC5vcHRpb25zLm1lYXN1cmVtZW50SWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKGBUaGUgXCJhcGlLZXlcIiBmaWVsZCBpcyBlbXB0eSBpbiB0aGUgbG9jYWwgRmlyZWJhc2UgY29uZmlnLiBUaGlzIGlzIG5lZWRlZCB0byBmZXRjaCB0aGUgbGF0ZXN0YCArXG4gICAgICAgICAgICAgICAgYCBtZWFzdXJlbWVudCBJRCBmb3IgdGhpcyBGaXJlYmFzZSBhcHAuIEZhbGxpbmcgYmFjayB0byB0aGUgbWVhc3VyZW1lbnQgSUQgJHthcHAub3B0aW9ucy5tZWFzdXJlbWVudElkfWAgK1xuICAgICAgICAgICAgICAgIGAgcHJvdmlkZWQgaW4gdGhlIFwibWVhc3VyZW1lbnRJZFwiIGZpZWxkIGluIHRoZSBsb2NhbCBGaXJlYmFzZSBjb25maWcuYCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vLWFwaS1rZXlcIiAvKiBBbmFseXRpY3NFcnJvci5OT19BUElfS0VZICovKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFthcHBJZF0gIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImFscmVhZHktZXhpc3RzXCIgLyogQW5hbHl0aWNzRXJyb3IuQUxSRUFEWV9FWElTVFMgKi8sIHtcbiAgICAgICAgICAgIGlkOiBhcHBJZFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKCFnbG9iYWxJbml0RG9uZSkge1xuICAgICAgICAvLyBTdGVwcyBoZXJlIHNob3VsZCBvbmx5IGJlIGRvbmUgb25jZSBwZXIgcGFnZTogY3JlYXRpb24gb3Igd3JhcHBpbmdcbiAgICAgICAgLy8gb2YgZGF0YUxheWVyIGFuZCBnbG9iYWwgZ3RhZyBmdW5jdGlvbi5cbiAgICAgICAgZ2V0T3JDcmVhdGVEYXRhTGF5ZXIoZGF0YUxheWVyTmFtZSk7XG4gICAgICAgIGNvbnN0IHsgd3JhcHBlZEd0YWcsIGd0YWdDb3JlIH0gPSB3cmFwT3JDcmVhdGVHdGFnKGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXAsIGR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QsIG1lYXN1cmVtZW50SWRUb0FwcElkLCBkYXRhTGF5ZXJOYW1lLCBndGFnTmFtZSk7XG4gICAgICAgIHdyYXBwZWRHdGFnRnVuY3Rpb24gPSB3cmFwcGVkR3RhZztcbiAgICAgICAgZ3RhZ0NvcmVGdW5jdGlvbiA9IGd0YWdDb3JlO1xuICAgICAgICBnbG9iYWxJbml0RG9uZSA9IHRydWU7XG4gICAgfVxuICAgIC8vIEFzeW5jIGJ1dCBub24tYmxvY2tpbmcuXG4gICAgLy8gVGhpcyBtYXAgcmVmbGVjdHMgdGhlIGNvbXBsZXRpb24gc3RhdGUgb2YgYWxsIHByb21pc2VzIGZvciBlYWNoIGFwcElkLlxuICAgIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYXBwSWRdID0gX2luaXRpYWxpemVBbmFseXRpY3MoYXBwLCBkeW5hbWljQ29uZmlnUHJvbWlzZXNMaXN0LCBtZWFzdXJlbWVudElkVG9BcHBJZCwgaW5zdGFsbGF0aW9ucywgZ3RhZ0NvcmVGdW5jdGlvbiwgZGF0YUxheWVyTmFtZSwgb3B0aW9ucyk7XG4gICAgY29uc3QgYW5hbHl0aWNzSW5zdGFuY2UgPSBuZXcgQW5hbHl0aWNzU2VydmljZShhcHApO1xuICAgIHJldHVybiBhbmFseXRpY3NJbnN0YW5jZTtcbn1cblxuLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueSAqL1xuLyoqXG4gKiBSZXR1cm5zIGFuIHtAbGluayBBbmFseXRpY3N9IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXBwLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGdldEFuYWx5dGljcyhhcHAgPSBnZXRBcHAoKSkge1xuICAgIGFwcCA9IGdldE1vZHVsYXJJbnN0YW5jZShhcHApO1xuICAgIC8vIERlcGVuZGVuY2llc1xuICAgIGNvbnN0IGFuYWx5dGljc1Byb3ZpZGVyID0gX2dldFByb3ZpZGVyKGFwcCwgQU5BTFlUSUNTX1RZUEUpO1xuICAgIGlmIChhbmFseXRpY3NQcm92aWRlci5pc0luaXRpYWxpemVkKCkpIHtcbiAgICAgICAgcmV0dXJuIGFuYWx5dGljc1Byb3ZpZGVyLmdldEltbWVkaWF0ZSgpO1xuICAgIH1cbiAgICByZXR1cm4gaW5pdGlhbGl6ZUFuYWx5dGljcyhhcHApO1xufVxuLyoqXG4gKiBSZXR1cm5zIGFuIHtAbGluayBBbmFseXRpY3N9IGluc3RhbmNlIGZvciB0aGUgZ2l2ZW4gYXBwLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSB0byB1c2UuXG4gKi9cbmZ1bmN0aW9uIGluaXRpYWxpemVBbmFseXRpY3MoYXBwLCBvcHRpb25zID0ge30pIHtcbiAgICAvLyBEZXBlbmRlbmNpZXNcbiAgICBjb25zdCBhbmFseXRpY3NQcm92aWRlciA9IF9nZXRQcm92aWRlcihhcHAsIEFOQUxZVElDU19UWVBFKTtcbiAgICBpZiAoYW5hbHl0aWNzUHJvdmlkZXIuaXNJbml0aWFsaXplZCgpKSB7XG4gICAgICAgIGNvbnN0IGV4aXN0aW5nSW5zdGFuY2UgPSBhbmFseXRpY3NQcm92aWRlci5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgaWYgKGRlZXBFcXVhbChvcHRpb25zLCBhbmFseXRpY3NQcm92aWRlci5nZXRPcHRpb25zKCkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdJbnN0YW5jZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiYWxyZWFkeS1pbml0aWFsaXplZFwiIC8qIEFuYWx5dGljc0Vycm9yLkFMUkVBRFlfSU5JVElBTElaRUQgKi8pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGFuYWx5dGljc0luc3RhbmNlID0gYW5hbHl0aWNzUHJvdmlkZXIuaW5pdGlhbGl6ZSh7IG9wdGlvbnMgfSk7XG4gICAgcmV0dXJuIGFuYWx5dGljc0luc3RhbmNlO1xufVxuLyoqXG4gKiBUaGlzIGlzIGEgcHVibGljIHN0YXRpYyBtZXRob2QgcHJvdmlkZWQgdG8gdXNlcnMgdGhhdCB3cmFwcyBmb3VyIGRpZmZlcmVudCBjaGVja3M6XG4gKlxuICogMS4gQ2hlY2sgaWYgaXQncyBub3QgYSBicm93c2VyIGV4dGVuc2lvbiBlbnZpcm9ubWVudC5cbiAqIDIuIENoZWNrIGlmIGNvb2tpZXMgYXJlIGVuYWJsZWQgaW4gY3VycmVudCBicm93c2VyLlxuICogMy4gQ2hlY2sgaWYgSW5kZXhlZERCIGlzIHN1cHBvcnRlZCBieSB0aGUgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAqIDQuIENoZWNrIGlmIHRoZSBjdXJyZW50IGJyb3dzZXIgY29udGV4dCBpcyB2YWxpZCBmb3IgdXNpbmcgYEluZGV4ZWREQi5vcGVuKClgLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgIGlmIChpc0Jyb3dzZXJFeHRlbnNpb24oKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghYXJlQ29va2llc0VuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICghaXNJbmRleGVkREJBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGlzREJPcGVuYWJsZSA9IGF3YWl0IHZhbGlkYXRlSW5kZXhlZERCT3BlbmFibGUoKTtcbiAgICAgICAgcmV0dXJuIGlzREJPcGVuYWJsZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqIFVzZSBndGFnIGBjb25maWdgIGNvbW1hbmQgdG8gc2V0IGBzY3JlZW5fbmFtZWAuXG4gKlxuICogQHB1YmxpY1xuICpcbiAqIEBkZXByZWNhdGVkIFVzZSB7QGxpbmsgbG9nRXZlbnR9IHdpdGggYGV2ZW50TmFtZWAgYXMgJ3NjcmVlbl92aWV3JyBhbmQgYWRkIHJlbGV2YW50IGBldmVudFBhcmFtc2AuXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZmlyZWJhc2UuZ29vZ2xlLmNvbS9kb2NzL2FuYWx5dGljcy9zY3JlZW52aWV3cyB8IFRyYWNrIFNjcmVlbnZpZXdzfS5cbiAqXG4gKiBAcGFyYW0gYW5hbHl0aWNzSW5zdGFuY2UgLSBUaGUge0BsaW5rIEFuYWx5dGljc30gaW5zdGFuY2UuXG4gKiBAcGFyYW0gc2NyZWVuTmFtZSAtIFNjcmVlbiBuYW1lIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0Q3VycmVudFNjcmVlbihhbmFseXRpY3NJbnN0YW5jZSwgc2NyZWVuTmFtZSwgb3B0aW9ucykge1xuICAgIGFuYWx5dGljc0luc3RhbmNlID0gZ2V0TW9kdWxhckluc3RhbmNlKGFuYWx5dGljc0luc3RhbmNlKTtcbiAgICBzZXRDdXJyZW50U2NyZWVuJDEod3JhcHBlZEd0YWdGdW5jdGlvbiwgaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcFthbmFseXRpY3NJbnN0YW5jZS5hcHAub3B0aW9ucy5hcHBJZF0sIHNjcmVlbk5hbWUsIG9wdGlvbnMpLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGUpKTtcbn1cbi8qKlxuICogUmV0cmlldmVzIGEgdW5pcXVlIEdvb2dsZSBBbmFseXRpY3MgaWRlbnRpZmllciBmb3IgdGhlIHdlYiBjbGllbnQuXG4gKiBTZWUge0BsaW5rIGh0dHBzOi8vZGV2ZWxvcGVycy5nb29nbGUuY29tL2FuYWx5dGljcy9kZXZndWlkZXMvY29sbGVjdGlvbi9nYTQvcmVmZXJlbmNlL2NvbmZpZyNjbGllbnRfaWQgfCBjbGllbnRfaWR9LlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gYXBwIC0gVGhlIHtAbGluayBAZmlyZWJhc2UvYXBwI0ZpcmViYXNlQXBwfSB0byB1c2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEdvb2dsZUFuYWx5dGljc0NsaWVudElkKGFuYWx5dGljc0luc3RhbmNlKSB7XG4gICAgYW5hbHl0aWNzSW5zdGFuY2UgPSBnZXRNb2R1bGFySW5zdGFuY2UoYW5hbHl0aWNzSW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnRlcm5hbEdldEdvb2dsZUFuYWx5dGljc0NsaWVudElkKHdyYXBwZWRHdGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYW5hbHl0aWNzSW5zdGFuY2UuYXBwLm9wdGlvbnMuYXBwSWRdKTtcbn1cbi8qKlxuICogVXNlIGd0YWcgYGNvbmZpZ2AgY29tbWFuZCB0byBzZXQgYHVzZXJfaWRgLlxuICpcbiAqIEBwdWJsaWNcbiAqXG4gKiBAcGFyYW0gYW5hbHl0aWNzSW5zdGFuY2UgLSBUaGUge0BsaW5rIEFuYWx5dGljc30gaW5zdGFuY2UuXG4gKiBAcGFyYW0gaWQgLSBVc2VyIElEIHRvIHNldC5cbiAqL1xuZnVuY3Rpb24gc2V0VXNlcklkKGFuYWx5dGljc0luc3RhbmNlLCBpZCwgb3B0aW9ucykge1xuICAgIGFuYWx5dGljc0luc3RhbmNlID0gZ2V0TW9kdWxhckluc3RhbmNlKGFuYWx5dGljc0luc3RhbmNlKTtcbiAgICBzZXRVc2VySWQkMSh3cmFwcGVkR3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSwgaWQsIG9wdGlvbnMpLmNhdGNoKGUgPT4gbG9nZ2VyLmVycm9yKGUpKTtcbn1cbi8qKlxuICogVXNlIGd0YWcgYGNvbmZpZ2AgY29tbWFuZCB0byBzZXQgYWxsIHBhcmFtcyBzcGVjaWZpZWQuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBzZXRVc2VyUHJvcGVydGllcyhhbmFseXRpY3NJbnN0YW5jZSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGFuYWx5dGljc0luc3RhbmNlID0gZ2V0TW9kdWxhckluc3RhbmNlKGFuYWx5dGljc0luc3RhbmNlKTtcbiAgICBzZXRVc2VyUHJvcGVydGllcyQxKHdyYXBwZWRHdGFnRnVuY3Rpb24sIGluaXRpYWxpemF0aW9uUHJvbWlzZXNNYXBbYW5hbHl0aWNzSW5zdGFuY2UuYXBwLm9wdGlvbnMuYXBwSWRdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKS5jYXRjaChlID0+IGxvZ2dlci5lcnJvcihlKSk7XG59XG4vKipcbiAqIFNldHMgd2hldGhlciBHb29nbGUgQW5hbHl0aWNzIGNvbGxlY3Rpb24gaXMgZW5hYmxlZCBmb3IgdGhpcyBhcHAgb24gdGhpcyBkZXZpY2UuXG4gKiBTZXRzIGdsb2JhbCBgd2luZG93WydnYS1kaXNhYmxlLWFuYWx5dGljc0lkJ10gPSB0cnVlO2BcbiAqXG4gKiBAcHVibGljXG4gKlxuICogQHBhcmFtIGFuYWx5dGljc0luc3RhbmNlIC0gVGhlIHtAbGluayBBbmFseXRpY3N9IGluc3RhbmNlLlxuICogQHBhcmFtIGVuYWJsZWQgLSBJZiB0cnVlLCBlbmFibGVzIGNvbGxlY3Rpb24sIGlmIGZhbHNlLCBkaXNhYmxlcyBpdC5cbiAqL1xuZnVuY3Rpb24gc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQoYW5hbHl0aWNzSW5zdGFuY2UsIGVuYWJsZWQpIHtcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XG4gICAgc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQkMShpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSwgZW5hYmxlZCkuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoZSkpO1xufVxuLyoqXG4gKiBBZGRzIGRhdGEgdGhhdCB3aWxsIGJlIHNldCBvbiBldmVyeSBldmVudCBsb2dnZWQgZnJvbSB0aGUgU0RLLCBpbmNsdWRpbmcgYXV0b21hdGljIG9uZXMuXG4gKiBXaXRoIGd0YWcncyBcInNldFwiIGNvbW1hbmQsIHRoZSB2YWx1ZXMgcGFzc2VkIHBlcnNpc3Qgb24gdGhlIGN1cnJlbnQgcGFnZSBhbmQgYXJlIHBhc3NlZCB3aXRoXG4gKiBhbGwgc3Vic2VxdWVudCBldmVudHMuXG4gKiBAcHVibGljXG4gKiBAcGFyYW0gY3VzdG9tUGFyYW1zIC0gQW55IGN1c3RvbSBwYXJhbXMgdGhlIHVzZXIgbWF5IHBhc3MgdG8gZ3RhZy5qcy5cbiAqL1xuZnVuY3Rpb24gc2V0RGVmYXVsdEV2ZW50UGFyYW1ldGVycyhjdXN0b21QYXJhbXMpIHtcbiAgICAvLyBDaGVjayBpZiByZWZlcmVuY2UgdG8gZXhpc3RpbmcgZ3RhZyBmdW5jdGlvbiBvbiB3aW5kb3cgb2JqZWN0IGV4aXN0c1xuICAgIGlmICh3cmFwcGVkR3RhZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHdyYXBwZWRHdGFnRnVuY3Rpb24oXCJzZXRcIiAvKiBHdGFnQ29tbWFuZC5TRVQgKi8sIGN1c3RvbVBhcmFtcyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfc2V0RGVmYXVsdEV2ZW50UGFyYW1ldGVyc0ZvckluaXQoY3VzdG9tUGFyYW1zKTtcbiAgICB9XG59XG4vKipcbiAqIFNlbmRzIGEgR29vZ2xlIEFuYWx5dGljcyBldmVudCB3aXRoIGdpdmVuIGBldmVudFBhcmFtc2AuIFRoaXMgbWV0aG9kXG4gKiBhdXRvbWF0aWNhbGx5IGFzc29jaWF0ZXMgdGhpcyBsb2dnZWQgZXZlbnQgd2l0aCB0aGlzIEZpcmViYXNlIHdlYlxuICogYXBwIGluc3RhbmNlIG9uIHRoaXMgZGV2aWNlLlxuICogTGlzdCBvZiBvZmZpY2lhbCBldmVudCBwYXJhbWV0ZXJzIGNhbiBiZSBmb3VuZCBpbiB0aGUgZ3RhZy5qc1xuICogcmVmZXJlbmNlIGRvY3VtZW50YXRpb246XG4gKiB7QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vZ3RhZ2pzL3JlZmVyZW5jZS9nYTQtZXZlbnRzXG4gKiB8IHRoZSBHQTQgcmVmZXJlbmNlIGRvY3VtZW50YXRpb259LlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gbG9nRXZlbnQoYW5hbHl0aWNzSW5zdGFuY2UsIGV2ZW50TmFtZSwgZXZlbnRQYXJhbXMsIG9wdGlvbnMpIHtcbiAgICBhbmFseXRpY3NJbnN0YW5jZSA9IGdldE1vZHVsYXJJbnN0YW5jZShhbmFseXRpY3NJbnN0YW5jZSk7XG4gICAgbG9nRXZlbnQkMSh3cmFwcGVkR3RhZ0Z1bmN0aW9uLCBpbml0aWFsaXphdGlvblByb21pc2VzTWFwW2FuYWx5dGljc0luc3RhbmNlLmFwcC5vcHRpb25zLmFwcElkXSwgZXZlbnROYW1lLCBldmVudFBhcmFtcywgb3B0aW9ucykuY2F0Y2goZSA9PiBsb2dnZXIuZXJyb3IoZSkpO1xufVxuLyoqXG4gKiBTZXRzIHRoZSBhcHBsaWNhYmxlIGVuZCB1c2VyIGNvbnNlbnQgc3RhdGUgZm9yIHRoaXMgd2ViIGFwcCBhY3Jvc3MgYWxsIGd0YWcgcmVmZXJlbmNlcyBvbmNlXG4gKiBGaXJlYmFzZSBBbmFseXRpY3MgaXMgaW5pdGlhbGl6ZWQuXG4gKlxuICogVXNlIHRoZSB7QGxpbmsgQ29uc2VudFNldHRpbmdzfSB0byBzcGVjaWZ5IGluZGl2aWR1YWwgY29uc2VudCB0eXBlIHZhbHVlcy4gQnkgZGVmYXVsdCBjb25zZW50XG4gKiB0eXBlcyBhcmUgc2V0IHRvIFwiZ3JhbnRlZFwiLlxuICogQHB1YmxpY1xuICogQHBhcmFtIGNvbnNlbnRTZXR0aW5ncyAtIE1hcHMgdGhlIGFwcGxpY2FibGUgZW5kIHVzZXIgY29uc2VudCBzdGF0ZSBmb3IgZ3RhZy5qcy5cbiAqL1xuZnVuY3Rpb24gc2V0Q29uc2VudChjb25zZW50U2V0dGluZ3MpIHtcbiAgICAvLyBDaGVjayBpZiByZWZlcmVuY2UgdG8gZXhpc3RpbmcgZ3RhZyBmdW5jdGlvbiBvbiB3aW5kb3cgb2JqZWN0IGV4aXN0c1xuICAgIGlmICh3cmFwcGVkR3RhZ0Z1bmN0aW9uKSB7XG4gICAgICAgIHdyYXBwZWRHdGFnRnVuY3Rpb24oXCJjb25zZW50XCIgLyogR3RhZ0NvbW1hbmQuQ09OU0VOVCAqLywgJ3VwZGF0ZScsIGNvbnNlbnRTZXR0aW5ncyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfc2V0Q29uc2VudERlZmF1bHRGb3JJbml0KGNvbnNlbnRTZXR0aW5ncyk7XG4gICAgfVxufVxuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvYW5hbHl0aWNzXCI7XG5jb25zdCB2ZXJzaW9uID0gXCIwLjEwLjEyXCI7XG5cbi8qKlxuICogVGhlIEZpcmViYXNlIEFuYWx5dGljcyBXZWIgU0RLLlxuICogVGhpcyBTREsgZG9lcyBub3Qgd29yayBpbiBhIE5vZGUuanMgZW52aXJvbm1lbnQuXG4gKlxuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyQW5hbHl0aWNzKCkge1xuICAgIF9yZWdpc3RlckNvbXBvbmVudChuZXcgQ29tcG9uZW50KEFOQUxZVElDU19UWVBFLCAoY29udGFpbmVyLCB7IG9wdGlvbnM6IGFuYWx5dGljc09wdGlvbnMgfSkgPT4ge1xuICAgICAgICAvLyBnZXRJbW1lZGlhdGUgZm9yIEZpcmViYXNlQXBwIHdpbGwgYWx3YXlzIHN1Y2NlZWRcbiAgICAgICAgY29uc3QgYXBwID0gY29udGFpbmVyLmdldFByb3ZpZGVyKCdhcHAnKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgY29uc3QgaW5zdGFsbGF0aW9ucyA9IGNvbnRhaW5lclxuICAgICAgICAgICAgLmdldFByb3ZpZGVyKCdpbnN0YWxsYXRpb25zLWludGVybmFsJylcbiAgICAgICAgICAgIC5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgcmV0dXJuIGZhY3RvcnkoYXBwLCBpbnN0YWxsYXRpb25zLCBhbmFseXRpY3NPcHRpb25zKTtcbiAgICB9LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoJ2FuYWx5dGljcy1pbnRlcm5hbCcsIGludGVybmFsRmFjdG9yeSwgXCJQUklWQVRFXCIgLyogQ29tcG9uZW50VHlwZS5QUklWQVRFICovKSk7XG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24pO1xuICAgIC8vIEJVSUxEX1RBUkdFVCB3aWxsIGJlIHJlcGxhY2VkIGJ5IHZhbHVlcyBsaWtlIGVzbTIwMTcsIGNqczIwMTcsIGV0YyBkdXJpbmcgdGhlIGNvbXBpbGF0aW9uXG4gICAgcmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XG4gICAgZnVuY3Rpb24gaW50ZXJuYWxGYWN0b3J5KGNvbnRhaW5lcikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgYW5hbHl0aWNzID0gY29udGFpbmVyLmdldFByb3ZpZGVyKEFOQUxZVElDU19UWVBFKS5nZXRJbW1lZGlhdGUoKTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbG9nRXZlbnQ6IChldmVudE5hbWUsIGV2ZW50UGFyYW1zLCBvcHRpb25zKSA9PiBsb2dFdmVudChhbmFseXRpY3MsIGV2ZW50TmFtZSwgZXZlbnRQYXJhbXMsIG9wdGlvbnMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImludGVyb3AtY29tcG9uZW50LXJlZy1mYWlsZWRcIiAvKiBBbmFseXRpY3NFcnJvci5JTlRFUk9QX0NPTVBPTkVOVF9SRUdfRkFJTEVEICovLCB7XG4gICAgICAgICAgICAgICAgcmVhc29uOiBlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cbnJlZ2lzdGVyQW5hbHl0aWNzKCk7XG5cbmV4cG9ydCB7IGdldEFuYWx5dGljcywgZ2V0R29vZ2xlQW5hbHl0aWNzQ2xpZW50SWQsIGluaXRpYWxpemVBbmFseXRpY3MsIGlzU3VwcG9ydGVkLCBsb2dFdmVudCwgc2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQsIHNldENvbnNlbnQsIHNldEN1cnJlbnRTY3JlZW4sIHNldERlZmF1bHRFdmVudFBhcmFtZXRlcnMsIHNldFVzZXJJZCwgc2V0VXNlclByb3BlcnRpZXMsIHNldHRpbmdzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20yMDE3LmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9nZXRQcm92aWRlciIsImdldEFwcCIsIl9yZWdpc3RlckNvbXBvbmVudCIsInJlZ2lzdGVyVmVyc2lvbiIsIkxvZ2dlciIsIkVycm9yRmFjdG9yeSIsImNhbGN1bGF0ZUJhY2tvZmZNaWxsaXMiLCJGaXJlYmFzZUVycm9yIiwiaXNJbmRleGVkREJBdmFpbGFibGUiLCJ2YWxpZGF0ZUluZGV4ZWREQk9wZW5hYmxlIiwiaXNCcm93c2VyRXh0ZW5zaW9uIiwiYXJlQ29va2llc0VuYWJsZWQiLCJnZXRNb2R1bGFySW5zdGFuY2UiLCJkZWVwRXF1YWwiLCJDb21wb25lbnQiLCJBTkFMWVRJQ1NfVFlQRSIsIkdBX0ZJRF9LRVkiLCJPUklHSU5fS0VZIiwiRkVUQ0hfVElNRU9VVF9NSUxMSVMiLCJEWU5BTUlDX0NPTkZJR19VUkwiLCJHVEFHX1VSTCIsImxvZ2dlciIsIkVSUk9SUyIsIkVSUk9SX0ZBQ1RPUlkiLCJjcmVhdGVHdGFnVHJ1c3RlZFR5cGVzU2NyaXB0VVJMIiwidXJsIiwic3RhcnRzV2l0aCIsImVyciIsImNyZWF0ZSIsImd0YWdVUkwiLCJ3YXJuIiwibWVzc2FnZSIsInByb21pc2VBbGxTZXR0bGVkIiwicHJvbWlzZXMiLCJQcm9taXNlIiwiYWxsIiwibWFwIiwicHJvbWlzZSIsImNhdGNoIiwiZSIsImNyZWF0ZVRydXN0ZWRUeXBlc1BvbGljeSIsInBvbGljeU5hbWUiLCJwb2xpY3lPcHRpb25zIiwidHJ1c3RlZFR5cGVzUG9saWN5Iiwid2luZG93IiwidHJ1c3RlZFR5cGVzIiwiY3JlYXRlUG9saWN5IiwiaW5zZXJ0U2NyaXB0VGFnIiwiZGF0YUxheWVyTmFtZSIsIm1lYXN1cmVtZW50SWQiLCJjcmVhdGVTY3JpcHRVUkwiLCJzY3JpcHQiLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJndGFnU2NyaXB0VVJMIiwic3JjIiwiYXN5bmMiLCJoZWFkIiwiYXBwZW5kQ2hpbGQiLCJnZXRPckNyZWF0ZURhdGFMYXllciIsImRhdGFMYXllciIsIkFycmF5IiwiaXNBcnJheSIsImd0YWdPbkNvbmZpZyIsImd0YWdDb3JlIiwiaW5pdGlhbGl6YXRpb25Qcm9taXNlc01hcCIsImR5bmFtaWNDb25maWdQcm9taXNlc0xpc3QiLCJtZWFzdXJlbWVudElkVG9BcHBJZCIsImd0YWdQYXJhbXMiLCJjb3JyZXNwb25kaW5nQXBwSWQiLCJkeW5hbWljQ29uZmlnUmVzdWx0cyIsImZvdW5kQ29uZmlnIiwiZmluZCIsImNvbmZpZyIsImFwcElkIiwiZXJyb3IiLCJndGFnT25FdmVudCIsImluaXRpYWxpemF0aW9uUHJvbWlzZXNUb1dhaXRGb3IiLCJnYVNlbmRUb0xpc3QiLCJzZW5kVG9JZCIsImluaXRpYWxpemF0aW9uUHJvbWlzZSIsInB1c2giLCJsZW5ndGgiLCJPYmplY3QiLCJ2YWx1ZXMiLCJ3cmFwR3RhZyIsImd0YWdXcmFwcGVyIiwiY29tbWFuZCIsImFyZ3MiLCJjb25zZW50QWN0aW9uIiwiZmllbGROYW1lIiwiY2FsbGJhY2siLCJjdXN0b21QYXJhbXMiLCJ3cmFwT3JDcmVhdGVHdGFnIiwiZ3RhZ0Z1bmN0aW9uTmFtZSIsIl9hcmdzIiwiYXJndW1lbnRzIiwid3JhcHBlZEd0YWciLCJmaW5kR3RhZ1NjcmlwdE9uUGFnZSIsInNjcmlwdFRhZ3MiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInRhZyIsImluY2x1ZGVzIiwiTE9OR19SRVRSWV9GQUNUT1IiLCJCQVNFX0lOVEVSVkFMX01JTExJUyIsIlJldHJ5RGF0YSIsImdldFRocm90dGxlTWV0YWRhdGEiLCJ0aHJvdHRsZU1ldGFkYXRhIiwic2V0VGhyb3R0bGVNZXRhZGF0YSIsIm1ldGFkYXRhIiwiZGVsZXRlVGhyb3R0bGVNZXRhZGF0YSIsImNvbnN0cnVjdG9yIiwiaW50ZXJ2YWxNaWxsaXMiLCJkZWZhdWx0UmV0cnlEYXRhIiwiZ2V0SGVhZGVycyIsImFwaUtleSIsIkhlYWRlcnMiLCJBY2NlcHQiLCJmZXRjaER5bmFtaWNDb25maWciLCJhcHBGaWVsZHMiLCJfYSIsInJlcXVlc3QiLCJtZXRob2QiLCJoZWFkZXJzIiwiYXBwVXJsIiwicmVwbGFjZSIsInJlc3BvbnNlIiwiZmV0Y2giLCJzdGF0dXMiLCJlcnJvck1lc3NhZ2UiLCJqc29uUmVzcG9uc2UiLCJqc29uIiwiX2lnbm9yZWQiLCJodHRwU3RhdHVzIiwicmVzcG9uc2VNZXNzYWdlIiwiZmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5IiwiYXBwIiwicmV0cnlEYXRhIiwidGltZW91dE1pbGxpcyIsIm9wdGlvbnMiLCJiYWNrb2ZmQ291bnQiLCJ0aHJvdHRsZUVuZFRpbWVNaWxsaXMiLCJEYXRlIiwibm93Iiwic2lnbmFsIiwiQW5hbHl0aWNzQWJvcnRTaWduYWwiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJ1bmRlZmluZWQiLCJhdHRlbXB0RmV0Y2hEeW5hbWljQ29uZmlnV2l0aFJldHJ5Iiwic2V0QWJvcnRhYmxlVGltZW91dCIsImlzUmV0cmlhYmxlRXJyb3IiLCJiYWNrb2ZmTWlsbGlzIiwiTnVtYmVyIiwiY3VzdG9tRGF0YSIsImRlYnVnIiwicmVzb2x2ZSIsInJlamVjdCIsIk1hdGgiLCJtYXgiLCJ0aW1lb3V0IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNsZWFyVGltZW91dCIsImxpc3RlbmVyIiwibGlzdGVuZXJzIiwiZm9yRWFjaCIsImRlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0IiwibG9nRXZlbnQkMSIsImd0YWdGdW5jdGlvbiIsImV2ZW50TmFtZSIsImV2ZW50UGFyYW1zIiwiZ2xvYmFsIiwicGFyYW1zIiwiYXNzaWduIiwic2V0Q3VycmVudFNjcmVlbiQxIiwic2NyZWVuTmFtZSIsInVwZGF0ZSIsInNldFVzZXJJZCQxIiwiaWQiLCJzZXRVc2VyUHJvcGVydGllcyQxIiwicHJvcGVydGllcyIsImZsYXRQcm9wZXJ0aWVzIiwia2V5Iiwia2V5cyIsImludGVybmFsR2V0R29vZ2xlQW5hbHl0aWNzQ2xpZW50SWQiLCJjbGllbnRJZCIsInNldEFuYWx5dGljc0NvbGxlY3Rpb25FbmFibGVkJDEiLCJlbmFibGVkIiwiZGVmYXVsdENvbnNlbnRTZXR0aW5nc0ZvckluaXQiLCJfc2V0Q29uc2VudERlZmF1bHRGb3JJbml0IiwiY29uc2VudFNldHRpbmdzIiwiX3NldERlZmF1bHRFdmVudFBhcmFtZXRlcnNGb3JJbml0IiwidmFsaWRhdGVJbmRleGVkREIiLCJlcnJvckluZm8iLCJ0b1N0cmluZyIsIl9pbml0aWFsaXplQW5hbHl0aWNzIiwiaW5zdGFsbGF0aW9ucyIsImR5bmFtaWNDb25maWdQcm9taXNlIiwidGhlbiIsImZpZFByb21pc2UiLCJlbnZJc1ZhbGlkIiwiZ2V0SWQiLCJkeW5hbWljQ29uZmlnIiwiZmlkIiwiY29uZmlnUHJvcGVydGllcyIsIkFuYWx5dGljc1NlcnZpY2UiLCJfZGVsZXRlIiwiZ3RhZ05hbWUiLCJndGFnQ29yZUZ1bmN0aW9uIiwid3JhcHBlZEd0YWdGdW5jdGlvbiIsImdsb2JhbEluaXREb25lIiwic2V0dGluZ3MiLCJ3YXJuT25Ccm93c2VyQ29udGV4dE1pc21hdGNoIiwibWlzbWF0Y2hlZEVudk1lc3NhZ2VzIiwiZGV0YWlscyIsImluZGV4Iiwiam9pbiIsImZhY3RvcnkiLCJhbmFseXRpY3NJbnN0YW5jZSIsImdldEFuYWx5dGljcyIsImFuYWx5dGljc1Byb3ZpZGVyIiwiaXNJbml0aWFsaXplZCIsImdldEltbWVkaWF0ZSIsImluaXRpYWxpemVBbmFseXRpY3MiLCJleGlzdGluZ0luc3RhbmNlIiwiZ2V0T3B0aW9ucyIsImluaXRpYWxpemUiLCJpc1N1cHBvcnRlZCIsImlzREJPcGVuYWJsZSIsInNldEN1cnJlbnRTY3JlZW4iLCJnZXRHb29nbGVBbmFseXRpY3NDbGllbnRJZCIsInNldFVzZXJJZCIsInNldFVzZXJQcm9wZXJ0aWVzIiwic2V0QW5hbHl0aWNzQ29sbGVjdGlvbkVuYWJsZWQiLCJzZXREZWZhdWx0RXZlbnRQYXJhbWV0ZXJzIiwibG9nRXZlbnQiLCJzZXRDb25zZW50IiwibmFtZSIsInZlcnNpb24iLCJyZWdpc3RlckFuYWx5dGljcyIsImNvbnRhaW5lciIsImFuYWx5dGljc09wdGlvbnMiLCJnZXRQcm92aWRlciIsImludGVybmFsRmFjdG9yeSIsImFuYWx5dGljcyIsInJlYXNvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js":
/*!************************************************************************!*\
  !*** ./node_modules/@firebase/installations/dist/esm/index.esm2017.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   deleteInstallations: function() { return /* binding */ deleteInstallations; },\n/* harmony export */   getId: function() { return /* binding */ getId; },\n/* harmony export */   getInstallations: function() { return /* binding */ getInstallations; },\n/* harmony export */   getToken: function() { return /* binding */ getToken; },\n/* harmony export */   onIdChange: function() { return /* binding */ onIdChange; }\n/* harmony export */ });\n/* harmony import */ var _firebase_app__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/app */ \"(app-pages-browser)/./node_modules/@firebase/app/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_component__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @firebase/component */ \"(app-pages-browser)/./node_modules/@firebase/component/dist/esm/index.esm2017.js\");\n/* harmony import */ var _firebase_util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @firebase/util */ \"(app-pages-browser)/./node_modules/@firebase/util/dist/index.esm2017.js\");\n/* harmony import */ var idb__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! idb */ \"(app-pages-browser)/./node_modules/idb/build/index.js\");\n\n\n\n\nconst name = \"@firebase/installations\";\nconst version = \"0.6.13\";\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const PENDING_TIMEOUT_MS = 10000;\nconst PACKAGE_VERSION = \"w:\".concat(version);\nconst INTERNAL_AUTH_VERSION = \"FIS_v2\";\nconst INSTALLATIONS_API_URL = \"https://firebaseinstallations.googleapis.com/v1\";\nconst TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1000; // One hour\nconst SERVICE = \"installations\";\nconst SERVICE_NAME = \"Installations\";\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const ERROR_DESCRIPTION_MAP = {\n    [\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */ ]: 'Missing App configuration value: \"{$valueName}\"',\n    [\"not-registered\" /* ErrorCode.NOT_REGISTERED */ ]: \"Firebase Installation is not registered.\",\n    [\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */ ]: \"Firebase Installation not found.\",\n    [\"request-failed\" /* ErrorCode.REQUEST_FAILED */ ]: '{$requestName} request failed with error \"{$serverCode} {$serverStatus}: {$serverMessage}\"',\n    [\"app-offline\" /* ErrorCode.APP_OFFLINE */ ]: \"Could not process request. Application offline.\",\n    [\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */ ]: \"Can't delete installation while there is a pending registration request.\"\n};\nconst ERROR_FACTORY = new _firebase_util__WEBPACK_IMPORTED_MODULE_2__.ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);\n/** Returns true if error is a FirebaseError that is based on an error from the server. */ function isServerError(error) {\n    return error instanceof _firebase_util__WEBPACK_IMPORTED_MODULE_2__.FirebaseError && error.code.includes(\"request-failed\" /* ErrorCode.REQUEST_FAILED */ );\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function getInstallationsEndpoint(param) {\n    let { projectId } = param;\n    return \"\".concat(INSTALLATIONS_API_URL, \"/projects/\").concat(projectId, \"/installations\");\n}\nfunction extractAuthTokenInfoFromResponse(response) {\n    return {\n        token: response.token,\n        requestStatus: 2 /* RequestStatus.COMPLETED */ ,\n        expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),\n        creationTime: Date.now()\n    };\n}\nasync function getErrorFromResponse(requestName, response) {\n    const responseJson = await response.json();\n    const errorData = responseJson.error;\n    return ERROR_FACTORY.create(\"request-failed\" /* ErrorCode.REQUEST_FAILED */ , {\n        requestName,\n        serverCode: errorData.code,\n        serverMessage: errorData.message,\n        serverStatus: errorData.status\n    });\n}\nfunction getHeaders(param) {\n    let { apiKey } = param;\n    return new Headers({\n        \"Content-Type\": \"application/json\",\n        Accept: \"application/json\",\n        \"x-goog-api-key\": apiKey\n    });\n}\nfunction getHeadersWithAuth(appConfig, param) {\n    let { refreshToken } = param;\n    const headers = getHeaders(appConfig);\n    headers.append(\"Authorization\", getAuthorizationHeader(refreshToken));\n    return headers;\n}\n/**\n * Calls the passed in fetch wrapper and returns the response.\n * If the returned response has a status of 5xx, re-runs the function once and\n * returns the response.\n */ async function retryIfServerError(fn) {\n    const result = await fn();\n    if (result.status >= 500 && result.status < 600) {\n        // Internal Server Error. Retry request.\n        return fn();\n    }\n    return result;\n}\nfunction getExpiresInFromResponseExpiresIn(responseExpiresIn) {\n    // This works because the server will never respond with fractions of a second.\n    return Number(responseExpiresIn.replace(\"s\", \"000\"));\n}\nfunction getAuthorizationHeader(refreshToken) {\n    return \"\".concat(INTERNAL_AUTH_VERSION, \" \").concat(refreshToken);\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ async function createInstallationRequest(param, param1) {\n    let { appConfig, heartbeatServiceProvider } = param, { fid } = param1;\n    const endpoint = getInstallationsEndpoint(appConfig);\n    const headers = getHeaders(appConfig);\n    // If heartbeat service exists, add the heartbeat string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers.append(\"x-firebase-client\", heartbeatsHeader);\n        }\n    }\n    const body = {\n        fid,\n        authVersion: INTERNAL_AUTH_VERSION,\n        appId: appConfig.appId,\n        sdkVersion: PACKAGE_VERSION\n    };\n    const request = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n    };\n    const response = await retryIfServerError(()=>fetch(endpoint, request));\n    if (response.ok) {\n        const responseValue = await response.json();\n        const registeredInstallationEntry = {\n            fid: responseValue.fid || fid,\n            registrationStatus: 2 /* RequestStatus.COMPLETED */ ,\n            refreshToken: responseValue.refreshToken,\n            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)\n        };\n        return registeredInstallationEntry;\n    } else {\n        throw await getErrorFromResponse(\"Create Installation\", response);\n    }\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /** Returns a promise that resolves after given time passes. */ function sleep(ms) {\n    return new Promise((resolve)=>{\n        setTimeout(resolve, ms);\n    });\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function bufferToBase64UrlSafe(array) {\n    const b64 = btoa(String.fromCharCode(...array));\n    return b64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\");\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const VALID_FID_PATTERN = /^[cdef][\\w-]{21}$/;\nconst INVALID_FID = \"\";\n/**\n * Generates a new FID using random values from Web Crypto API.\n * Returns an empty string if FID generation fails for any reason.\n */ function generateFid() {\n    try {\n        // A valid FID has exactly 22 base64 characters, which is 132 bits, or 16.5\n        // bytes. our implementation generates a 17 byte array instead.\n        const fidByteArray = new Uint8Array(17);\n        const crypto = self.crypto || self.msCrypto;\n        crypto.getRandomValues(fidByteArray);\n        // Replace the first 4 random bits with the constant FID header of 0b0111.\n        fidByteArray[0] = 112 + fidByteArray[0] % 16;\n        const fid = encode(fidByteArray);\n        return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;\n    } catch (_a) {\n        // FID generation errored\n        return INVALID_FID;\n    }\n}\n/** Converts a FID Uint8Array to a base64 string representation. */ function encode(fidByteArray) {\n    const b64String = bufferToBase64UrlSafe(fidByteArray);\n    // Remove the 23rd character that was added because of the extra 4 bits at the\n    // end of our 17 byte array, and the '=' padding.\n    return b64String.substr(0, 22);\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /** Returns a string key that can be used to identify the app. */ function getKey(appConfig) {\n    return \"\".concat(appConfig.appName, \"!\").concat(appConfig.appId);\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const fidChangeCallbacks = new Map();\n/**\n * Calls the onIdChange callbacks with the new FID value, and broadcasts the\n * change to other tabs.\n */ function fidChanged(appConfig, fid) {\n    const key = getKey(appConfig);\n    callFidChangeCallbacks(key, fid);\n    broadcastFidChange(key, fid);\n}\nfunction addCallback(appConfig, callback) {\n    // Open the broadcast channel if it's not already open,\n    // to be able to listen to change events from other tabs.\n    getBroadcastChannel();\n    const key = getKey(appConfig);\n    let callbackSet = fidChangeCallbacks.get(key);\n    if (!callbackSet) {\n        callbackSet = new Set();\n        fidChangeCallbacks.set(key, callbackSet);\n    }\n    callbackSet.add(callback);\n}\nfunction removeCallback(appConfig, callback) {\n    const key = getKey(appConfig);\n    const callbackSet = fidChangeCallbacks.get(key);\n    if (!callbackSet) {\n        return;\n    }\n    callbackSet.delete(callback);\n    if (callbackSet.size === 0) {\n        fidChangeCallbacks.delete(key);\n    }\n    // Close broadcast channel if there are no more callbacks.\n    closeBroadcastChannel();\n}\nfunction callFidChangeCallbacks(key, fid) {\n    const callbacks = fidChangeCallbacks.get(key);\n    if (!callbacks) {\n        return;\n    }\n    for (const callback of callbacks){\n        callback(fid);\n    }\n}\nfunction broadcastFidChange(key, fid) {\n    const channel = getBroadcastChannel();\n    if (channel) {\n        channel.postMessage({\n            key,\n            fid\n        });\n    }\n    closeBroadcastChannel();\n}\nlet broadcastChannel = null;\n/** Opens and returns a BroadcastChannel if it is supported by the browser. */ function getBroadcastChannel() {\n    if (!broadcastChannel && \"BroadcastChannel\" in self) {\n        broadcastChannel = new BroadcastChannel(\"[Firebase] FID Change\");\n        broadcastChannel.onmessage = (e)=>{\n            callFidChangeCallbacks(e.data.key, e.data.fid);\n        };\n    }\n    return broadcastChannel;\n}\nfunction closeBroadcastChannel() {\n    if (fidChangeCallbacks.size === 0 && broadcastChannel) {\n        broadcastChannel.close();\n        broadcastChannel = null;\n    }\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const DATABASE_NAME = \"firebase-installations-database\";\nconst DATABASE_VERSION = 1;\nconst OBJECT_STORE_NAME = \"firebase-installations-store\";\nlet dbPromise = null;\nfunction getDbPromise() {\n    if (!dbPromise) {\n        dbPromise = (0,idb__WEBPACK_IMPORTED_MODULE_3__.openDB)(DATABASE_NAME, DATABASE_VERSION, {\n            upgrade: (db, oldVersion)=>{\n                // We don't use 'break' in this switch statement, the fall-through\n                // behavior is what we want, because if there are multiple versions between\n                // the old version and the current version, we want ALL the migrations\n                // that correspond to those versions to run, not only the last one.\n                // eslint-disable-next-line default-case\n                switch(oldVersion){\n                    case 0:\n                        db.createObjectStore(OBJECT_STORE_NAME);\n                }\n            }\n        });\n    }\n    return dbPromise;\n}\n/** Assigns or overwrites the record for the given key with the given value. */ async function set(appConfig, value) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    const objectStore = tx.objectStore(OBJECT_STORE_NAME);\n    const oldValue = await objectStore.get(key);\n    await objectStore.put(value, key);\n    await tx.done;\n    if (!oldValue || oldValue.fid !== value.fid) {\n        fidChanged(appConfig, value.fid);\n    }\n    return value;\n}\n/** Removes record(s) from the objectStore that match the given key. */ async function remove(appConfig) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    await tx.objectStore(OBJECT_STORE_NAME).delete(key);\n    await tx.done;\n}\n/**\n * Atomically updates a record with the result of updateFn, which gets\n * called with the current value. If newValue is undefined, the record is\n * deleted instead.\n * @return Updated value\n */ async function update(appConfig, updateFn) {\n    const key = getKey(appConfig);\n    const db = await getDbPromise();\n    const tx = db.transaction(OBJECT_STORE_NAME, \"readwrite\");\n    const store = tx.objectStore(OBJECT_STORE_NAME);\n    const oldValue = await store.get(key);\n    const newValue = updateFn(oldValue);\n    if (newValue === undefined) {\n        await store.delete(key);\n    } else {\n        await store.put(newValue, key);\n    }\n    await tx.done;\n    if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {\n        fidChanged(appConfig, newValue.fid);\n    }\n    return newValue;\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Updates and returns the InstallationEntry from the database.\n * Also triggers a registration request if it is necessary and possible.\n */ async function getInstallationEntry(installations) {\n    let registrationPromise;\n    const installationEntry = await update(installations.appConfig, (oldEntry)=>{\n        const installationEntry = updateOrCreateInstallationEntry(oldEntry);\n        const entryWithPromise = triggerRegistrationIfNecessary(installations, installationEntry);\n        registrationPromise = entryWithPromise.registrationPromise;\n        return entryWithPromise.installationEntry;\n    });\n    if (installationEntry.fid === INVALID_FID) {\n        // FID generation failed. Waiting for the FID from the server.\n        return {\n            installationEntry: await registrationPromise\n        };\n    }\n    return {\n        installationEntry,\n        registrationPromise\n    };\n}\n/**\n * Creates a new Installation Entry if one does not exist.\n * Also clears timed out pending requests.\n */ function updateOrCreateInstallationEntry(oldEntry) {\n    const entry = oldEntry || {\n        fid: generateFid(),\n        registrationStatus: 0 /* RequestStatus.NOT_STARTED */ \n    };\n    return clearTimedOutRequest(entry);\n}\n/**\n * If the Firebase Installation is not registered yet, this will trigger the\n * registration and return an InProgressInstallationEntry.\n *\n * If registrationPromise does not exist, the installationEntry is guaranteed\n * to be registered.\n */ function triggerRegistrationIfNecessary(installations, installationEntry) {\n    if (installationEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n        if (!navigator.onLine) {\n            // Registration required but app is offline.\n            const registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */ ));\n            return {\n                installationEntry,\n                registrationPromise: registrationPromiseWithError\n            };\n        }\n        // Try registering. Change status to IN_PROGRESS.\n        const inProgressEntry = {\n            fid: installationEntry.fid,\n            registrationStatus: 1 /* RequestStatus.IN_PROGRESS */ ,\n            registrationTime: Date.now()\n        };\n        const registrationPromise = registerInstallation(installations, inProgressEntry);\n        return {\n            installationEntry: inProgressEntry,\n            registrationPromise\n        };\n    } else if (installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ ) {\n        return {\n            installationEntry,\n            registrationPromise: waitUntilFidRegistration(installations)\n        };\n    } else {\n        return {\n            installationEntry\n        };\n    }\n}\n/** This will be executed only once for each new Firebase Installation. */ async function registerInstallation(installations, installationEntry) {\n    try {\n        const registeredInstallationEntry = await createInstallationRequest(installations, installationEntry);\n        return set(installations.appConfig, registeredInstallationEntry);\n    } catch (e) {\n        if (isServerError(e) && e.customData.serverCode === 409) {\n            // Server returned a \"FID cannot be used\" error.\n            // Generate a new ID next time.\n            await remove(installations.appConfig);\n        } else {\n            // Registration failed. Set FID as not registered.\n            await set(installations.appConfig, {\n                fid: installationEntry.fid,\n                registrationStatus: 0 /* RequestStatus.NOT_STARTED */ \n            });\n        }\n        throw e;\n    }\n}\n/** Call if FID registration is pending in another request. */ async function waitUntilFidRegistration(installations) {\n    // Unfortunately, there is no way of reliably observing when a value in\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n    // so we need to poll.\n    let entry = await updateInstallationRequest(installations.appConfig);\n    while(entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ ){\n        // createInstallation request still in progress.\n        await sleep(100);\n        entry = await updateInstallationRequest(installations.appConfig);\n    }\n    if (entry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n        // The request timed out or failed in a different call. Try again.\n        const { installationEntry, registrationPromise } = await getInstallationEntry(installations);\n        if (registrationPromise) {\n            return registrationPromise;\n        } else {\n            // if there is no registrationPromise, entry is registered.\n            return installationEntry;\n        }\n    }\n    return entry;\n}\n/**\n * Called only if there is a CreateInstallation request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * CreateInstallation request.\n *\n * Returns the updated InstallationEntry.\n */ function updateInstallationRequest(appConfig) {\n    return update(appConfig, (oldEntry)=>{\n        if (!oldEntry) {\n            throw ERROR_FACTORY.create(\"installation-not-found\" /* ErrorCode.INSTALLATION_NOT_FOUND */ );\n        }\n        return clearTimedOutRequest(oldEntry);\n    });\n}\nfunction clearTimedOutRequest(entry) {\n    if (hasInstallationRequestTimedOut(entry)) {\n        return {\n            fid: entry.fid,\n            registrationStatus: 0 /* RequestStatus.NOT_STARTED */ \n        };\n    }\n    return entry;\n}\nfunction hasInstallationRequestTimedOut(installationEntry) {\n    return installationEntry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */  && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ async function generateAuthTokenRequest(param, installationEntry) {\n    let { appConfig, heartbeatServiceProvider } = param;\n    const endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\n    // If heartbeat service exists, add the heartbeat string to the header.\n    const heartbeatService = heartbeatServiceProvider.getImmediate({\n        optional: true\n    });\n    if (heartbeatService) {\n        const heartbeatsHeader = await heartbeatService.getHeartbeatsHeader();\n        if (heartbeatsHeader) {\n            headers.append(\"x-firebase-client\", heartbeatsHeader);\n        }\n    }\n    const body = {\n        installation: {\n            sdkVersion: PACKAGE_VERSION,\n            appId: appConfig.appId\n        }\n    };\n    const request = {\n        method: \"POST\",\n        headers,\n        body: JSON.stringify(body)\n    };\n    const response = await retryIfServerError(()=>fetch(endpoint, request));\n    if (response.ok) {\n        const responseValue = await response.json();\n        const completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);\n        return completedAuthToken;\n    } else {\n        throw await getErrorFromResponse(\"Generate Auth Token\", response);\n    }\n}\nfunction getGenerateAuthTokenEndpoint(appConfig, param) {\n    let { fid } = param;\n    return \"\".concat(getInstallationsEndpoint(appConfig), \"/\").concat(fid, \"/authTokens:generate\");\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Returns a valid authentication token for the installation. Generates a new\n * token if one doesn't exist, is expired or about to expire.\n *\n * Should only be called if the Firebase Installation is registered.\n */ async function refreshAuthToken(installations) {\n    let forceRefresh = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    let tokenPromise;\n    const entry = await update(installations.appConfig, (oldEntry)=>{\n        if (!isEntryRegistered(oldEntry)) {\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */ );\n        }\n        const oldAuthToken = oldEntry.authToken;\n        if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {\n            // There is a valid token in the DB.\n            return oldEntry;\n        } else if (oldAuthToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ ) {\n            // There already is a token request in progress.\n            tokenPromise = waitUntilAuthTokenRequest(installations, forceRefresh);\n            return oldEntry;\n        } else {\n            // No token or token expired.\n            if (!navigator.onLine) {\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */ );\n            }\n            const inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);\n            tokenPromise = fetchAuthTokenFromServer(installations, inProgressEntry);\n            return inProgressEntry;\n        }\n    });\n    const authToken = tokenPromise ? await tokenPromise : entry.authToken;\n    return authToken;\n}\n/**\n * Call only if FID is registered and Auth Token request is in progress.\n *\n * Waits until the current pending request finishes. If the request times out,\n * tries once in this thread as well.\n */ async function waitUntilAuthTokenRequest(installations, forceRefresh) {\n    // Unfortunately, there is no way of reliably observing when a value in\n    // IndexedDB changes (yet, see https://github.com/WICG/indexed-db-observers),\n    // so we need to poll.\n    let entry = await updateAuthTokenRequest(installations.appConfig);\n    while(entry.authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */ ){\n        // generateAuthToken still in progress.\n        await sleep(100);\n        entry = await updateAuthTokenRequest(installations.appConfig);\n    }\n    const authToken = entry.authToken;\n    if (authToken.requestStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n        // The request timed out or failed in a different call. Try again.\n        return refreshAuthToken(installations, forceRefresh);\n    } else {\n        return authToken;\n    }\n}\n/**\n * Called only if there is a GenerateAuthToken request in progress.\n *\n * Updates the InstallationEntry in the DB based on the status of the\n * GenerateAuthToken request.\n *\n * Returns the updated InstallationEntry.\n */ function updateAuthTokenRequest(appConfig) {\n    return update(appConfig, (oldEntry)=>{\n        if (!isEntryRegistered(oldEntry)) {\n            throw ERROR_FACTORY.create(\"not-registered\" /* ErrorCode.NOT_REGISTERED */ );\n        }\n        const oldAuthToken = oldEntry.authToken;\n        if (hasAuthTokenRequestTimedOut(oldAuthToken)) {\n            return Object.assign(Object.assign({}, oldEntry), {\n                authToken: {\n                    requestStatus: 0 /* RequestStatus.NOT_STARTED */ \n                }\n            });\n        }\n        return oldEntry;\n    });\n}\nasync function fetchAuthTokenFromServer(installations, installationEntry) {\n    try {\n        const authToken = await generateAuthTokenRequest(installations, installationEntry);\n        const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), {\n            authToken\n        });\n        await set(installations.appConfig, updatedInstallationEntry);\n        return authToken;\n    } catch (e) {\n        if (isServerError(e) && (e.customData.serverCode === 401 || e.customData.serverCode === 404)) {\n            // Server returned a \"FID not found\" or a \"Invalid authentication\" error.\n            // Generate a new ID next time.\n            await remove(installations.appConfig);\n        } else {\n            const updatedInstallationEntry = Object.assign(Object.assign({}, installationEntry), {\n                authToken: {\n                    requestStatus: 0 /* RequestStatus.NOT_STARTED */ \n                }\n            });\n            await set(installations.appConfig, updatedInstallationEntry);\n        }\n        throw e;\n    }\n}\nfunction isEntryRegistered(installationEntry) {\n    return installationEntry !== undefined && installationEntry.registrationStatus === 2 /* RequestStatus.COMPLETED */ ;\n}\nfunction isAuthTokenValid(authToken) {\n    return authToken.requestStatus === 2 /* RequestStatus.COMPLETED */  && !isAuthTokenExpired(authToken);\n}\nfunction isAuthTokenExpired(authToken) {\n    const now = Date.now();\n    return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;\n}\n/** Returns an updated InstallationEntry with an InProgressAuthToken. */ function makeAuthTokenRequestInProgressEntry(oldEntry) {\n    const inProgressAuthToken = {\n        requestStatus: 1 /* RequestStatus.IN_PROGRESS */ ,\n        requestTime: Date.now()\n    };\n    return Object.assign(Object.assign({}, oldEntry), {\n        authToken: inProgressAuthToken\n    });\n}\nfunction hasAuthTokenRequestTimedOut(authToken) {\n    return authToken.requestStatus === 1 /* RequestStatus.IN_PROGRESS */  && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Creates a Firebase Installation if there isn't one for the app and\n * returns the Installation ID.\n * @param installations - The `Installations` instance.\n *\n * @public\n */ async function getId(installations) {\n    const installationsImpl = installations;\n    const { installationEntry, registrationPromise } = await getInstallationEntry(installationsImpl);\n    if (registrationPromise) {\n        registrationPromise.catch(console.error);\n    } else {\n        // If the installation is already registered, update the authentication\n        // token if needed.\n        refreshAuthToken(installationsImpl).catch(console.error);\n    }\n    return installationEntry.fid;\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Returns a Firebase Installations auth token, identifying the current\n * Firebase Installation.\n * @param installations - The `Installations` instance.\n * @param forceRefresh - Force refresh regardless of token expiration.\n *\n * @public\n */ async function getToken(installations) {\n    let forceRefresh = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    const installationsImpl = installations;\n    await completeInstallationRegistration(installationsImpl);\n    // At this point we either have a Registered Installation in the DB, or we've\n    // already thrown an error.\n    const authToken = await refreshAuthToken(installationsImpl, forceRefresh);\n    return authToken.token;\n}\nasync function completeInstallationRegistration(installations) {\n    const { registrationPromise } = await getInstallationEntry(installations);\n    if (registrationPromise) {\n        // A createInstallation request is in progress. Wait until it finishes.\n        await registrationPromise;\n    }\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ async function deleteInstallationRequest(appConfig, installationEntry) {\n    const endpoint = getDeleteEndpoint(appConfig, installationEntry);\n    const headers = getHeadersWithAuth(appConfig, installationEntry);\n    const request = {\n        method: \"DELETE\",\n        headers\n    };\n    const response = await retryIfServerError(()=>fetch(endpoint, request));\n    if (!response.ok) {\n        throw await getErrorFromResponse(\"Delete Installation\", response);\n    }\n}\nfunction getDeleteEndpoint(appConfig, param) {\n    let { fid } = param;\n    return \"\".concat(getInstallationsEndpoint(appConfig), \"/\").concat(fid);\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Deletes the Firebase Installation and all associated data.\n * @param installations - The `Installations` instance.\n *\n * @public\n */ async function deleteInstallations(installations) {\n    const { appConfig } = installations;\n    const entry = await update(appConfig, (oldEntry)=>{\n        if (oldEntry && oldEntry.registrationStatus === 0 /* RequestStatus.NOT_STARTED */ ) {\n            // Delete the unregistered entry without sending a deleteInstallation request.\n            return undefined;\n        }\n        return oldEntry;\n    });\n    if (entry) {\n        if (entry.registrationStatus === 1 /* RequestStatus.IN_PROGRESS */ ) {\n            // Can't delete while trying to register.\n            throw ERROR_FACTORY.create(\"delete-pending-registration\" /* ErrorCode.DELETE_PENDING_REGISTRATION */ );\n        } else if (entry.registrationStatus === 2 /* RequestStatus.COMPLETED */ ) {\n            if (!navigator.onLine) {\n                throw ERROR_FACTORY.create(\"app-offline\" /* ErrorCode.APP_OFFLINE */ );\n            } else {\n                await deleteInstallationRequest(appConfig, entry);\n                await remove(appConfig);\n            }\n        }\n    }\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Sets a new callback that will get called when Installation ID changes.\n * Returns an unsubscribe function that will remove the callback when called.\n * @param installations - The `Installations` instance.\n * @param callback - The callback function that is invoked when FID changes.\n * @returns A function that can be called to unsubscribe.\n *\n * @public\n */ function onIdChange(installations, callback) {\n    const { appConfig } = installations;\n    addCallback(appConfig, callback);\n    return ()=>{\n        removeCallback(appConfig, callback);\n    };\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ /**\n * Returns an instance of {@link Installations} associated with the given\n * {@link @firebase/app#FirebaseApp} instance.\n * @param app - The {@link @firebase/app#FirebaseApp} instance.\n *\n * @public\n */ function getInstallations() {\n    let app = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.getApp)();\n    const installationsImpl = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"installations\").getImmediate();\n    return installationsImpl;\n}\n/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ function extractAppConfig(app) {\n    if (!app || !app.options) {\n        throw getMissingValueError(\"App Configuration\");\n    }\n    if (!app.name) {\n        throw getMissingValueError(\"App Name\");\n    }\n    // Required app config keys\n    const configKeys = [\n        \"projectId\",\n        \"apiKey\",\n        \"appId\"\n    ];\n    for (const keyName of configKeys){\n        if (!app.options[keyName]) {\n            throw getMissingValueError(keyName);\n        }\n    }\n    return {\n        appName: app.name,\n        projectId: app.options.projectId,\n        apiKey: app.options.apiKey,\n        appId: app.options.appId\n    };\n}\nfunction getMissingValueError(valueName) {\n    return ERROR_FACTORY.create(\"missing-app-config-values\" /* ErrorCode.MISSING_APP_CONFIG_VALUES */ , {\n        valueName\n    });\n}\n/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *   http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */ const INSTALLATIONS_NAME = \"installations\";\nconst INSTALLATIONS_NAME_INTERNAL = \"installations-internal\";\nconst publicFactory = (container)=>{\n    const app = container.getProvider(\"app\").getImmediate();\n    // Throws if app isn't configured properly.\n    const appConfig = extractAppConfig(app);\n    const heartbeatServiceProvider = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, \"heartbeat\");\n    const installationsImpl = {\n        app,\n        appConfig,\n        heartbeatServiceProvider,\n        _delete: ()=>Promise.resolve()\n    };\n    return installationsImpl;\n};\nconst internalFactory = (container)=>{\n    const app = container.getProvider(\"app\").getImmediate();\n    // Internal FIS instance relies on public FIS instance.\n    const installations = (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._getProvider)(app, INSTALLATIONS_NAME).getImmediate();\n    const installationsInternal = {\n        getId: ()=>getId(installations),\n        getToken: (forceRefresh)=>getToken(installations, forceRefresh)\n    };\n    return installationsInternal;\n};\nfunction registerInstallations() {\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME, publicFactory, \"PUBLIC\" /* ComponentType.PUBLIC */ ));\n    (0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__._registerComponent)(new _firebase_component__WEBPACK_IMPORTED_MODULE_1__.Component(INSTALLATIONS_NAME_INTERNAL, internalFactory, \"PRIVATE\" /* ComponentType.PRIVATE */ ));\n}\n/**\n * The Firebase Installations Web SDK.\n * This SDK does not work in a Node.js environment.\n *\n * @packageDocumentation\n */ registerInstallations();\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version);\n// BUILD_TARGET will be replaced by values like esm2017, cjs2017, etc during the compilation\n(0,_firebase_app__WEBPACK_IMPORTED_MODULE_0__.registerVersion)(name, version, \"esm2017\");\n //# sourceMappingURL=index.esm2017.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AZmlyZWJhc2UvaW5zdGFsbGF0aW9ucy9kaXN0L2VzbS9pbmRleC5lc20yMDE3LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUEwRjtBQUMxQztBQUNhO0FBQ2hDO0FBRTdCLE1BQU1RLE9BQU87QUFDYixNQUFNQyxVQUFVO0FBRWhCOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELE1BQU1DLHFCQUFxQjtBQUMzQixNQUFNQyxrQkFBa0IsS0FBYSxPQUFSRjtBQUM3QixNQUFNRyx3QkFBd0I7QUFDOUIsTUFBTUMsd0JBQXdCO0FBQzlCLE1BQU1DLDBCQUEwQixLQUFLLEtBQUssTUFBTSxXQUFXO0FBQzNELE1BQU1DLFVBQVU7QUFDaEIsTUFBTUMsZUFBZTtBQUVyQjs7Ozs7Ozs7Ozs7Ozs7O0NBZUMsR0FDRCxNQUFNQyx3QkFBd0I7SUFDMUIsQ0FBQyw0QkFBNEIsdUNBQXVDLElBQUcsRUFBRTtJQUN6RSxDQUFDLGlCQUFpQiw0QkFBNEIsSUFBRyxFQUFFO0lBQ25ELENBQUMseUJBQXlCLG9DQUFvQyxJQUFHLEVBQUU7SUFDbkUsQ0FBQyxpQkFBaUIsNEJBQTRCLElBQUcsRUFBRTtJQUNuRCxDQUFDLGNBQWMseUJBQXlCLElBQUcsRUFBRTtJQUM3QyxDQUFDLDhCQUE4Qix5Q0FBeUMsSUFBRyxFQUFFO0FBQ2pGO0FBQ0EsTUFBTUMsZ0JBQWdCLElBQUliLHdEQUFZQSxDQUFDVSxTQUFTQyxjQUFjQztBQUM5RCx3RkFBd0YsR0FDeEYsU0FBU0UsY0FBY0MsS0FBSztJQUN4QixPQUFRQSxpQkFBaUJkLHlEQUFhQSxJQUNsQ2MsTUFBTUMsSUFBSSxDQUFDQyxRQUFRLENBQUMsaUJBQWlCLDRCQUE0QjtBQUN6RTtBQUVBOzs7Ozs7Ozs7Ozs7Ozs7Q0FlQyxHQUNELFNBQVNDLHlCQUF5QixLQUFhO1FBQWIsRUFBRUMsU0FBUyxFQUFFLEdBQWI7SUFDOUIsT0FBTyxHQUFxQ0EsT0FBbENYLHVCQUFzQixj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SUFDQSxPQUFPb0g7QUFDWDtBQUNBLE1BQU11QixrQkFBa0IsQ0FBQ0g7SUFDckIsTUFBTVYsTUFBTVUsVUFBVUMsV0FBVyxDQUFDLE9BQU85SixZQUFZO0lBQ3JELHVEQUF1RDtJQUN2RCxNQUFNK0YsZ0JBQWdCakssMkRBQVlBLENBQUNxTixLQUFLTyxvQkFBb0IxSixZQUFZO0lBQ3hFLE1BQU1pSyx3QkFBd0I7UUFDMUJ6QixPQUFPLElBQU1BLE1BQU16QztRQUNuQjZDLFVBQVUsQ0FBQ3BCLGVBQWlCb0IsU0FBUzdDLGVBQWV5QjtJQUN4RDtJQUNBLE9BQU95QztBQUNYO0FBQ0EsU0FBU0M7SUFDTGxPLGlFQUFrQkEsQ0FBQyxJQUFJRSwwREFBU0EsQ0FBQ3dOLG9CQUFvQkUsZUFBZSxTQUFTLHdCQUF3QjtJQUNyRzVOLGlFQUFrQkEsQ0FBQyxJQUFJRSwwREFBU0EsQ0FBQ3lOLDZCQUE2QkssaUJBQWlCLFVBQVUseUJBQXlCO0FBQ3RIO0FBRUE7Ozs7O0NBS0MsR0FDREU7QUFDQWpPLDhEQUFlQSxDQUFDSyxNQUFNQztBQUN0Qiw0RkFBNEY7QUFDNUZOLDhEQUFlQSxDQUFDSyxNQUFNQyxTQUFTO0FBRStDLENBQzlFLHlDQUF5QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGZpcmViYXNlL2luc3RhbGxhdGlvbnMvZGlzdC9lc20vaW5kZXguZXNtMjAxNy5qcz8zNzRmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IF9nZXRQcm92aWRlciwgZ2V0QXBwLCBfcmVnaXN0ZXJDb21wb25lbnQsIHJlZ2lzdGVyVmVyc2lvbiB9IGZyb20gJ0BmaXJlYmFzZS9hcHAnO1xuaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGZpcmViYXNlL2NvbXBvbmVudCc7XG5pbXBvcnQgeyBFcnJvckZhY3RvcnksIEZpcmViYXNlRXJyb3IgfSBmcm9tICdAZmlyZWJhc2UvdXRpbCc7XG5pbXBvcnQgeyBvcGVuREIgfSBmcm9tICdpZGInO1xuXG5jb25zdCBuYW1lID0gXCJAZmlyZWJhc2UvaW5zdGFsbGF0aW9uc1wiO1xuY29uc3QgdmVyc2lvbiA9IFwiMC42LjEzXCI7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBQRU5ESU5HX1RJTUVPVVRfTVMgPSAxMDAwMDtcbmNvbnN0IFBBQ0tBR0VfVkVSU0lPTiA9IGB3OiR7dmVyc2lvbn1gO1xuY29uc3QgSU5URVJOQUxfQVVUSF9WRVJTSU9OID0gJ0ZJU192Mic7XG5jb25zdCBJTlNUQUxMQVRJT05TX0FQSV9VUkwgPSAnaHR0cHM6Ly9maXJlYmFzZWluc3RhbGxhdGlvbnMuZ29vZ2xlYXBpcy5jb20vdjEnO1xuY29uc3QgVE9LRU5fRVhQSVJBVElPTl9CVUZGRVIgPSA2MCAqIDYwICogMTAwMDsgLy8gT25lIGhvdXJcbmNvbnN0IFNFUlZJQ0UgPSAnaW5zdGFsbGF0aW9ucyc7XG5jb25zdCBTRVJWSUNFX05BTUUgPSAnSW5zdGFsbGF0aW9ucyc7XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBFUlJPUl9ERVNDUklQVElPTl9NQVAgPSB7XG4gICAgW1wibWlzc2luZy1hcHAtY29uZmlnLXZhbHVlc1wiIC8qIEVycm9yQ29kZS5NSVNTSU5HX0FQUF9DT05GSUdfVkFMVUVTICovXTogJ01pc3NpbmcgQXBwIGNvbmZpZ3VyYXRpb24gdmFsdWU6IFwieyR2YWx1ZU5hbWV9XCInLFxuICAgIFtcIm5vdC1yZWdpc3RlcmVkXCIgLyogRXJyb3JDb2RlLk5PVF9SRUdJU1RFUkVEICovXTogJ0ZpcmViYXNlIEluc3RhbGxhdGlvbiBpcyBub3QgcmVnaXN0ZXJlZC4nLFxuICAgIFtcImluc3RhbGxhdGlvbi1ub3QtZm91bmRcIiAvKiBFcnJvckNvZGUuSU5TVEFMTEFUSU9OX05PVF9GT1VORCAqL106ICdGaXJlYmFzZSBJbnN0YWxsYXRpb24gbm90IGZvdW5kLicsXG4gICAgW1wicmVxdWVzdC1mYWlsZWRcIiAvKiBFcnJvckNvZGUuUkVRVUVTVF9GQUlMRUQgKi9dOiAneyRyZXF1ZXN0TmFtZX0gcmVxdWVzdCBmYWlsZWQgd2l0aCBlcnJvciBcInskc2VydmVyQ29kZX0geyRzZXJ2ZXJTdGF0dXN9OiB7JHNlcnZlck1lc3NhZ2V9XCInLFxuICAgIFtcImFwcC1vZmZsaW5lXCIgLyogRXJyb3JDb2RlLkFQUF9PRkZMSU5FICovXTogJ0NvdWxkIG5vdCBwcm9jZXNzIHJlcXVlc3QuIEFwcGxpY2F0aW9uIG9mZmxpbmUuJyxcbiAgICBbXCJkZWxldGUtcGVuZGluZy1yZWdpc3RyYXRpb25cIiAvKiBFcnJvckNvZGUuREVMRVRFX1BFTkRJTkdfUkVHSVNUUkFUSU9OICovXTogXCJDYW4ndCBkZWxldGUgaW5zdGFsbGF0aW9uIHdoaWxlIHRoZXJlIGlzIGEgcGVuZGluZyByZWdpc3RyYXRpb24gcmVxdWVzdC5cIlxufTtcbmNvbnN0IEVSUk9SX0ZBQ1RPUlkgPSBuZXcgRXJyb3JGYWN0b3J5KFNFUlZJQ0UsIFNFUlZJQ0VfTkFNRSwgRVJST1JfREVTQ1JJUFRJT05fTUFQKTtcbi8qKiBSZXR1cm5zIHRydWUgaWYgZXJyb3IgaXMgYSBGaXJlYmFzZUVycm9yIHRoYXQgaXMgYmFzZWQgb24gYW4gZXJyb3IgZnJvbSB0aGUgc2VydmVyLiAqL1xuZnVuY3Rpb24gaXNTZXJ2ZXJFcnJvcihlcnJvcikge1xuICAgIHJldHVybiAoZXJyb3IgaW5zdGFuY2VvZiBGaXJlYmFzZUVycm9yICYmXG4gICAgICAgIGVycm9yLmNvZGUuaW5jbHVkZXMoXCJyZXF1ZXN0LWZhaWxlZFwiIC8qIEVycm9yQ29kZS5SRVFVRVNUX0ZBSUxFRCAqLykpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuZnVuY3Rpb24gZ2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50KHsgcHJvamVjdElkIH0pIHtcbiAgICByZXR1cm4gYCR7SU5TVEFMTEFUSU9OU19BUElfVVJMfS9wcm9qZWN0cy8ke3Byb2plY3RJZH0vaW5zdGFsbGF0aW9uc2A7XG59XG5mdW5jdGlvbiBleHRyYWN0QXV0aFRva2VuSW5mb0Zyb21SZXNwb25zZShyZXNwb25zZSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHRva2VuOiByZXNwb25zZS50b2tlbixcbiAgICAgICAgcmVxdWVzdFN0YXR1czogMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLyxcbiAgICAgICAgZXhwaXJlc0luOiBnZXRFeHBpcmVzSW5Gcm9tUmVzcG9uc2VFeHBpcmVzSW4ocmVzcG9uc2UuZXhwaXJlc0luKSxcbiAgICAgICAgY3JlYXRpb25UaW1lOiBEYXRlLm5vdygpXG4gICAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGdldEVycm9yRnJvbVJlc3BvbnNlKHJlcXVlc3ROYW1lLCByZXNwb25zZSkge1xuICAgIGNvbnN0IHJlc3BvbnNlSnNvbiA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICBjb25zdCBlcnJvckRhdGEgPSByZXNwb25zZUpzb24uZXJyb3I7XG4gICAgcmV0dXJuIEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwicmVxdWVzdC1mYWlsZWRcIiAvKiBFcnJvckNvZGUuUkVRVUVTVF9GQUlMRUQgKi8sIHtcbiAgICAgICAgcmVxdWVzdE5hbWUsXG4gICAgICAgIHNlcnZlckNvZGU6IGVycm9yRGF0YS5jb2RlLFxuICAgICAgICBzZXJ2ZXJNZXNzYWdlOiBlcnJvckRhdGEubWVzc2FnZSxcbiAgICAgICAgc2VydmVyU3RhdHVzOiBlcnJvckRhdGEuc3RhdHVzXG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzKHsgYXBpS2V5IH0pIHtcbiAgICByZXR1cm4gbmV3IEhlYWRlcnMoe1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgJ3gtZ29vZy1hcGkta2V5JzogYXBpS2V5XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXJzV2l0aEF1dGgoYXBwQ29uZmlnLCB7IHJlZnJlc2hUb2tlbiB9KSB7XG4gICAgY29uc3QgaGVhZGVycyA9IGdldEhlYWRlcnMoYXBwQ29uZmlnKTtcbiAgICBoZWFkZXJzLmFwcGVuZCgnQXV0aG9yaXphdGlvbicsIGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVmcmVzaFRva2VuKSk7XG4gICAgcmV0dXJuIGhlYWRlcnM7XG59XG4vKipcbiAqIENhbGxzIHRoZSBwYXNzZWQgaW4gZmV0Y2ggd3JhcHBlciBhbmQgcmV0dXJucyB0aGUgcmVzcG9uc2UuXG4gKiBJZiB0aGUgcmV0dXJuZWQgcmVzcG9uc2UgaGFzIGEgc3RhdHVzIG9mIDV4eCwgcmUtcnVucyB0aGUgZnVuY3Rpb24gb25jZSBhbmRcbiAqIHJldHVybnMgdGhlIHJlc3BvbnNlLlxuICovXG5hc3luYyBmdW5jdGlvbiByZXRyeUlmU2VydmVyRXJyb3IoZm4pIHtcbiAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbigpO1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID49IDUwMCAmJiByZXN1bHQuc3RhdHVzIDwgNjAwKSB7XG4gICAgICAgIC8vIEludGVybmFsIFNlcnZlciBFcnJvci4gUmV0cnkgcmVxdWVzdC5cbiAgICAgICAgcmV0dXJuIGZuKCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBnZXRFeHBpcmVzSW5Gcm9tUmVzcG9uc2VFeHBpcmVzSW4ocmVzcG9uc2VFeHBpcmVzSW4pIHtcbiAgICAvLyBUaGlzIHdvcmtzIGJlY2F1c2UgdGhlIHNlcnZlciB3aWxsIG5ldmVyIHJlc3BvbmQgd2l0aCBmcmFjdGlvbnMgb2YgYSBzZWNvbmQuXG4gICAgcmV0dXJuIE51bWJlcihyZXNwb25zZUV4cGlyZXNJbi5yZXBsYWNlKCdzJywgJzAwMCcpKTtcbn1cbmZ1bmN0aW9uIGdldEF1dGhvcml6YXRpb25IZWFkZXIocmVmcmVzaFRva2VuKSB7XG4gICAgcmV0dXJuIGAke0lOVEVSTkFMX0FVVEhfVkVSU0lPTn0gJHtyZWZyZXNoVG9rZW59YDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZUluc3RhbGxhdGlvblJlcXVlc3QoeyBhcHBDb25maWcsIGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlciB9LCB7IGZpZCB9KSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKTtcbiAgICBjb25zdCBoZWFkZXJzID0gZ2V0SGVhZGVycyhhcHBDb25maWcpO1xuICAgIC8vIElmIGhlYXJ0YmVhdCBzZXJ2aWNlIGV4aXN0cywgYWRkIHRoZSBoZWFydGJlYXQgc3RyaW5nIHRvIHRoZSBoZWFkZXIuXG4gICAgY29uc3QgaGVhcnRiZWF0U2VydmljZSA9IGhlYXJ0YmVhdFNlcnZpY2VQcm92aWRlci5nZXRJbW1lZGlhdGUoe1xuICAgICAgICBvcHRpb25hbDogdHJ1ZVxuICAgIH0pO1xuICAgIGlmIChoZWFydGJlYXRTZXJ2aWNlKSB7XG4gICAgICAgIGNvbnN0IGhlYXJ0YmVhdHNIZWFkZXIgPSBhd2FpdCBoZWFydGJlYXRTZXJ2aWNlLmdldEhlYXJ0YmVhdHNIZWFkZXIoKTtcbiAgICAgICAgaWYgKGhlYXJ0YmVhdHNIZWFkZXIpIHtcbiAgICAgICAgICAgIGhlYWRlcnMuYXBwZW5kKCd4LWZpcmViYXNlLWNsaWVudCcsIGhlYXJ0YmVhdHNIZWFkZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGJvZHkgPSB7XG4gICAgICAgIGZpZCxcbiAgICAgICAgYXV0aFZlcnNpb246IElOVEVSTkFMX0FVVEhfVkVSU0lPTixcbiAgICAgICAgYXBwSWQ6IGFwcENvbmZpZy5hcHBJZCxcbiAgICAgICAgc2RrVmVyc2lvbjogUEFDS0FHRV9WRVJTSU9OXG4gICAgfTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgICAgaGVhZGVycyxcbiAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSlcbiAgICB9O1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgcmV0cnlJZlNlcnZlckVycm9yKCgpID0+IGZldGNoKGVuZHBvaW50LCByZXF1ZXN0KSk7XG4gICAgaWYgKHJlc3BvbnNlLm9rKSB7XG4gICAgICAgIGNvbnN0IHJlc3BvbnNlVmFsdWUgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeSA9IHtcbiAgICAgICAgICAgIGZpZDogcmVzcG9uc2VWYWx1ZS5maWQgfHwgZmlkLFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uU3RhdHVzOiAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovLFxuICAgICAgICAgICAgcmVmcmVzaFRva2VuOiByZXNwb25zZVZhbHVlLnJlZnJlc2hUb2tlbixcbiAgICAgICAgICAgIGF1dGhUb2tlbjogZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2VWYWx1ZS5hdXRoVG9rZW4pXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBhd2FpdCBnZXRFcnJvckZyb21SZXNwb25zZSgnQ3JlYXRlIEluc3RhbGxhdGlvbicsIHJlc3BvbnNlKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKiogUmV0dXJucyBhIHByb21pc2UgdGhhdCByZXNvbHZlcyBhZnRlciBnaXZlbiB0aW1lIHBhc3Nlcy4gKi9cbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTtcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGJ1ZmZlclRvQmFzZTY0VXJsU2FmZShhcnJheSkge1xuICAgIGNvbnN0IGI2NCA9IGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5hcnJheSkpO1xuICAgIHJldHVybiBiNjQucmVwbGFjZSgvXFwrL2csICctJykucmVwbGFjZSgvXFwvL2csICdfJyk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBWQUxJRF9GSURfUEFUVEVSTiA9IC9eW2NkZWZdW1xcdy1dezIxfSQvO1xuY29uc3QgSU5WQUxJRF9GSUQgPSAnJztcbi8qKlxuICogR2VuZXJhdGVzIGEgbmV3IEZJRCB1c2luZyByYW5kb20gdmFsdWVzIGZyb20gV2ViIENyeXB0byBBUEkuXG4gKiBSZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiBGSUQgZ2VuZXJhdGlvbiBmYWlscyBmb3IgYW55IHJlYXNvbi5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVGaWQoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gQSB2YWxpZCBGSUQgaGFzIGV4YWN0bHkgMjIgYmFzZTY0IGNoYXJhY3RlcnMsIHdoaWNoIGlzIDEzMiBiaXRzLCBvciAxNi41XG4gICAgICAgIC8vIGJ5dGVzLiBvdXIgaW1wbGVtZW50YXRpb24gZ2VuZXJhdGVzIGEgMTcgYnl0ZSBhcnJheSBpbnN0ZWFkLlxuICAgICAgICBjb25zdCBmaWRCeXRlQXJyYXkgPSBuZXcgVWludDhBcnJheSgxNyk7XG4gICAgICAgIGNvbnN0IGNyeXB0byA9IHNlbGYuY3J5cHRvIHx8IHNlbGYubXNDcnlwdG87XG4gICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoZmlkQnl0ZUFycmF5KTtcbiAgICAgICAgLy8gUmVwbGFjZSB0aGUgZmlyc3QgNCByYW5kb20gYml0cyB3aXRoIHRoZSBjb25zdGFudCBGSUQgaGVhZGVyIG9mIDBiMDExMS5cbiAgICAgICAgZmlkQnl0ZUFycmF5WzBdID0gMGIwMTExMDAwMCArIChmaWRCeXRlQXJyYXlbMF0gJSAwYjAwMDEwMDAwKTtcbiAgICAgICAgY29uc3QgZmlkID0gZW5jb2RlKGZpZEJ5dGVBcnJheSk7XG4gICAgICAgIHJldHVybiBWQUxJRF9GSURfUEFUVEVSTi50ZXN0KGZpZCkgPyBmaWQgOiBJTlZBTElEX0ZJRDtcbiAgICB9XG4gICAgY2F0Y2ggKF9hKSB7XG4gICAgICAgIC8vIEZJRCBnZW5lcmF0aW9uIGVycm9yZWRcbiAgICAgICAgcmV0dXJuIElOVkFMSURfRklEO1xuICAgIH1cbn1cbi8qKiBDb252ZXJ0cyBhIEZJRCBVaW50OEFycmF5IHRvIGEgYmFzZTY0IHN0cmluZyByZXByZXNlbnRhdGlvbi4gKi9cbmZ1bmN0aW9uIGVuY29kZShmaWRCeXRlQXJyYXkpIHtcbiAgICBjb25zdCBiNjRTdHJpbmcgPSBidWZmZXJUb0Jhc2U2NFVybFNhZmUoZmlkQnl0ZUFycmF5KTtcbiAgICAvLyBSZW1vdmUgdGhlIDIzcmQgY2hhcmFjdGVyIHRoYXQgd2FzIGFkZGVkIGJlY2F1c2Ugb2YgdGhlIGV4dHJhIDQgYml0cyBhdCB0aGVcbiAgICAvLyBlbmQgb2Ygb3VyIDE3IGJ5dGUgYXJyYXksIGFuZCB0aGUgJz0nIHBhZGRpbmcuXG4gICAgcmV0dXJuIGI2NFN0cmluZy5zdWJzdHIoMCwgMjIpO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqIFJldHVybnMgYSBzdHJpbmcga2V5IHRoYXQgY2FuIGJlIHVzZWQgdG8gaWRlbnRpZnkgdGhlIGFwcC4gKi9cbmZ1bmN0aW9uIGdldEtleShhcHBDb25maWcpIHtcbiAgICByZXR1cm4gYCR7YXBwQ29uZmlnLmFwcE5hbWV9ISR7YXBwQ29uZmlnLmFwcElkfWA7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBmaWRDaGFuZ2VDYWxsYmFja3MgPSBuZXcgTWFwKCk7XG4vKipcbiAqIENhbGxzIHRoZSBvbklkQ2hhbmdlIGNhbGxiYWNrcyB3aXRoIHRoZSBuZXcgRklEIHZhbHVlLCBhbmQgYnJvYWRjYXN0cyB0aGVcbiAqIGNoYW5nZSB0byBvdGhlciB0YWJzLlxuICovXG5mdW5jdGlvbiBmaWRDaGFuZ2VkKGFwcENvbmZpZywgZmlkKSB7XG4gICAgY29uc3Qga2V5ID0gZ2V0S2V5KGFwcENvbmZpZyk7XG4gICAgY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhrZXksIGZpZCk7XG4gICAgYnJvYWRjYXN0RmlkQ2hhbmdlKGtleSwgZmlkKTtcbn1cbmZ1bmN0aW9uIGFkZENhbGxiYWNrKGFwcENvbmZpZywgY2FsbGJhY2spIHtcbiAgICAvLyBPcGVuIHRoZSBicm9hZGNhc3QgY2hhbm5lbCBpZiBpdCdzIG5vdCBhbHJlYWR5IG9wZW4sXG4gICAgLy8gdG8gYmUgYWJsZSB0byBsaXN0ZW4gdG8gY2hhbmdlIGV2ZW50cyBmcm9tIG90aGVyIHRhYnMuXG4gICAgZ2V0QnJvYWRjYXN0Q2hhbm5lbCgpO1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGxldCBjYWxsYmFja1NldCA9IGZpZENoYW5nZUNhbGxiYWNrcy5nZXQoa2V5KTtcbiAgICBpZiAoIWNhbGxiYWNrU2V0KSB7XG4gICAgICAgIGNhbGxiYWNrU2V0ID0gbmV3IFNldCgpO1xuICAgICAgICBmaWRDaGFuZ2VDYWxsYmFja3Muc2V0KGtleSwgY2FsbGJhY2tTZXQpO1xuICAgIH1cbiAgICBjYWxsYmFja1NldC5hZGQoY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gcmVtb3ZlQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGNvbnN0IGNhbGxiYWNrU2V0ID0gZmlkQ2hhbmdlQ2FsbGJhY2tzLmdldChrZXkpO1xuICAgIGlmICghY2FsbGJhY2tTZXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYWxsYmFja1NldC5kZWxldGUoY2FsbGJhY2spO1xuICAgIGlmIChjYWxsYmFja1NldC5zaXplID09PSAwKSB7XG4gICAgICAgIGZpZENoYW5nZUNhbGxiYWNrcy5kZWxldGUoa2V5KTtcbiAgICB9XG4gICAgLy8gQ2xvc2UgYnJvYWRjYXN0IGNoYW5uZWwgaWYgdGhlcmUgYXJlIG5vIG1vcmUgY2FsbGJhY2tzLlxuICAgIGNsb3NlQnJvYWRjYXN0Q2hhbm5lbCgpO1xufVxuZnVuY3Rpb24gY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhrZXksIGZpZCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGZpZENoYW5nZUNhbGxiYWNrcy5nZXQoa2V5KTtcbiAgICBpZiAoIWNhbGxiYWNrcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgY2FsbGJhY2tzKSB7XG4gICAgICAgIGNhbGxiYWNrKGZpZCk7XG4gICAgfVxufVxuZnVuY3Rpb24gYnJvYWRjYXN0RmlkQ2hhbmdlKGtleSwgZmlkKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IGdldEJyb2FkY2FzdENoYW5uZWwoKTtcbiAgICBpZiAoY2hhbm5lbCkge1xuICAgICAgICBjaGFubmVsLnBvc3RNZXNzYWdlKHsga2V5LCBmaWQgfSk7XG4gICAgfVxuICAgIGNsb3NlQnJvYWRjYXN0Q2hhbm5lbCgpO1xufVxubGV0IGJyb2FkY2FzdENoYW5uZWwgPSBudWxsO1xuLyoqIE9wZW5zIGFuZCByZXR1cm5zIGEgQnJvYWRjYXN0Q2hhbm5lbCBpZiBpdCBpcyBzdXBwb3J0ZWQgYnkgdGhlIGJyb3dzZXIuICovXG5mdW5jdGlvbiBnZXRCcm9hZGNhc3RDaGFubmVsKCkge1xuICAgIGlmICghYnJvYWRjYXN0Q2hhbm5lbCAmJiAnQnJvYWRjYXN0Q2hhbm5lbCcgaW4gc2VsZikge1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsID0gbmV3IEJyb2FkY2FzdENoYW5uZWwoJ1tGaXJlYmFzZV0gRklEIENoYW5nZScpO1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsLm9ubWVzc2FnZSA9IGUgPT4ge1xuICAgICAgICAgICAgY2FsbEZpZENoYW5nZUNhbGxiYWNrcyhlLmRhdGEua2V5LCBlLmRhdGEuZmlkKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGJyb2FkY2FzdENoYW5uZWw7XG59XG5mdW5jdGlvbiBjbG9zZUJyb2FkY2FzdENoYW5uZWwoKSB7XG4gICAgaWYgKGZpZENoYW5nZUNhbGxiYWNrcy5zaXplID09PSAwICYmIGJyb2FkY2FzdENoYW5uZWwpIHtcbiAgICAgICAgYnJvYWRjYXN0Q2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICBicm9hZGNhc3RDaGFubmVsID0gbnVsbDtcbiAgICB9XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBEQVRBQkFTRV9OQU1FID0gJ2ZpcmViYXNlLWluc3RhbGxhdGlvbnMtZGF0YWJhc2UnO1xuY29uc3QgREFUQUJBU0VfVkVSU0lPTiA9IDE7XG5jb25zdCBPQkpFQ1RfU1RPUkVfTkFNRSA9ICdmaXJlYmFzZS1pbnN0YWxsYXRpb25zLXN0b3JlJztcbmxldCBkYlByb21pc2UgPSBudWxsO1xuZnVuY3Rpb24gZ2V0RGJQcm9taXNlKCkge1xuICAgIGlmICghZGJQcm9taXNlKSB7XG4gICAgICAgIGRiUHJvbWlzZSA9IG9wZW5EQihEQVRBQkFTRV9OQU1FLCBEQVRBQkFTRV9WRVJTSU9OLCB7XG4gICAgICAgICAgICB1cGdyYWRlOiAoZGIsIG9sZFZlcnNpb24pID0+IHtcbiAgICAgICAgICAgICAgICAvLyBXZSBkb24ndCB1c2UgJ2JyZWFrJyBpbiB0aGlzIHN3aXRjaCBzdGF0ZW1lbnQsIHRoZSBmYWxsLXRocm91Z2hcbiAgICAgICAgICAgICAgICAvLyBiZWhhdmlvciBpcyB3aGF0IHdlIHdhbnQsIGJlY2F1c2UgaWYgdGhlcmUgYXJlIG11bHRpcGxlIHZlcnNpb25zIGJldHdlZW5cbiAgICAgICAgICAgICAgICAvLyB0aGUgb2xkIHZlcnNpb24gYW5kIHRoZSBjdXJyZW50IHZlcnNpb24sIHdlIHdhbnQgQUxMIHRoZSBtaWdyYXRpb25zXG4gICAgICAgICAgICAgICAgLy8gdGhhdCBjb3JyZXNwb25kIHRvIHRob3NlIHZlcnNpb25zIHRvIHJ1biwgbm90IG9ubHkgdGhlIGxhc3Qgb25lLlxuICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBkZWZhdWx0LWNhc2VcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9sZFZlcnNpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgZGIuY3JlYXRlT2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBkYlByb21pc2U7XG59XG4vKiogQXNzaWducyBvciBvdmVyd3JpdGVzIHRoZSByZWNvcmQgZm9yIHRoZSBnaXZlbiBrZXkgd2l0aCB0aGUgZ2l2ZW4gdmFsdWUuICovXG5hc3luYyBmdW5jdGlvbiBzZXQoYXBwQ29uZmlnLCB2YWx1ZSkge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgIGNvbnN0IG9iamVjdFN0b3JlID0gdHgub2JqZWN0U3RvcmUoT0JKRUNUX1NUT1JFX05BTUUpO1xuICAgIGNvbnN0IG9sZFZhbHVlID0gKGF3YWl0IG9iamVjdFN0b3JlLmdldChrZXkpKTtcbiAgICBhd2FpdCBvYmplY3RTdG9yZS5wdXQodmFsdWUsIGtleSk7XG4gICAgYXdhaXQgdHguZG9uZTtcbiAgICBpZiAoIW9sZFZhbHVlIHx8IG9sZFZhbHVlLmZpZCAhPT0gdmFsdWUuZmlkKSB7XG4gICAgICAgIGZpZENoYW5nZWQoYXBwQ29uZmlnLCB2YWx1ZS5maWQpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4vKiogUmVtb3ZlcyByZWNvcmQocykgZnJvbSB0aGUgb2JqZWN0U3RvcmUgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4ga2V5LiAqL1xuYXN5bmMgZnVuY3Rpb24gcmVtb3ZlKGFwcENvbmZpZykge1xuICAgIGNvbnN0IGtleSA9IGdldEtleShhcHBDb25maWcpO1xuICAgIGNvbnN0IGRiID0gYXdhaXQgZ2V0RGJQcm9taXNlKCk7XG4gICAgY29uc3QgdHggPSBkYi50cmFuc2FjdGlvbihPQkpFQ1RfU1RPUkVfTkFNRSwgJ3JlYWR3cml0ZScpO1xuICAgIGF3YWl0IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKS5kZWxldGUoa2V5KTtcbiAgICBhd2FpdCB0eC5kb25lO1xufVxuLyoqXG4gKiBBdG9taWNhbGx5IHVwZGF0ZXMgYSByZWNvcmQgd2l0aCB0aGUgcmVzdWx0IG9mIHVwZGF0ZUZuLCB3aGljaCBnZXRzXG4gKiBjYWxsZWQgd2l0aCB0aGUgY3VycmVudCB2YWx1ZS4gSWYgbmV3VmFsdWUgaXMgdW5kZWZpbmVkLCB0aGUgcmVjb3JkIGlzXG4gKiBkZWxldGVkIGluc3RlYWQuXG4gKiBAcmV0dXJuIFVwZGF0ZWQgdmFsdWVcbiAqL1xuYXN5bmMgZnVuY3Rpb24gdXBkYXRlKGFwcENvbmZpZywgdXBkYXRlRm4pIHtcbiAgICBjb25zdCBrZXkgPSBnZXRLZXkoYXBwQ29uZmlnKTtcbiAgICBjb25zdCBkYiA9IGF3YWl0IGdldERiUHJvbWlzZSgpO1xuICAgIGNvbnN0IHR4ID0gZGIudHJhbnNhY3Rpb24oT0JKRUNUX1NUT1JFX05BTUUsICdyZWFkd3JpdGUnKTtcbiAgICBjb25zdCBzdG9yZSA9IHR4Lm9iamVjdFN0b3JlKE9CSkVDVF9TVE9SRV9OQU1FKTtcbiAgICBjb25zdCBvbGRWYWx1ZSA9IChhd2FpdCBzdG9yZS5nZXQoa2V5KSk7XG4gICAgY29uc3QgbmV3VmFsdWUgPSB1cGRhdGVGbihvbGRWYWx1ZSk7XG4gICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgYXdhaXQgc3RvcmUuZGVsZXRlKGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBhd2FpdCBzdG9yZS5wdXQobmV3VmFsdWUsIGtleSk7XG4gICAgfVxuICAgIGF3YWl0IHR4LmRvbmU7XG4gICAgaWYgKG5ld1ZhbHVlICYmICghb2xkVmFsdWUgfHwgb2xkVmFsdWUuZmlkICE9PSBuZXdWYWx1ZS5maWQpKSB7XG4gICAgICAgIGZpZENoYW5nZWQoYXBwQ29uZmlnLCBuZXdWYWx1ZS5maWQpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3VmFsdWU7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFVwZGF0ZXMgYW5kIHJldHVybnMgdGhlIEluc3RhbGxhdGlvbkVudHJ5IGZyb20gdGhlIGRhdGFiYXNlLlxuICogQWxzbyB0cmlnZ2VycyBhIHJlZ2lzdHJhdGlvbiByZXF1ZXN0IGlmIGl0IGlzIG5lY2Vzc2FyeSBhbmQgcG9zc2libGUuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdldEluc3RhbGxhdGlvbkVudHJ5KGluc3RhbGxhdGlvbnMpIHtcbiAgICBsZXQgcmVnaXN0cmF0aW9uUHJvbWlzZTtcbiAgICBjb25zdCBpbnN0YWxsYXRpb25FbnRyeSA9IGF3YWl0IHVwZGF0ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xuICAgICAgICBjb25zdCBpbnN0YWxsYXRpb25FbnRyeSA9IHVwZGF0ZU9yQ3JlYXRlSW5zdGFsbGF0aW9uRW50cnkob2xkRW50cnkpO1xuICAgICAgICBjb25zdCBlbnRyeVdpdGhQcm9taXNlID0gdHJpZ2dlclJlZ2lzdHJhdGlvbklmTmVjZXNzYXJ5KGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KTtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IGVudHJ5V2l0aFByb21pc2UucmVnaXN0cmF0aW9uUHJvbWlzZTtcbiAgICAgICAgcmV0dXJuIGVudHJ5V2l0aFByb21pc2UuaW5zdGFsbGF0aW9uRW50cnk7XG4gICAgfSk7XG4gICAgaWYgKGluc3RhbGxhdGlvbkVudHJ5LmZpZCA9PT0gSU5WQUxJRF9GSUQpIHtcbiAgICAgICAgLy8gRklEIGdlbmVyYXRpb24gZmFpbGVkLiBXYWl0aW5nIGZvciB0aGUgRklEIGZyb20gdGhlIHNlcnZlci5cbiAgICAgICAgcmV0dXJuIHsgaW5zdGFsbGF0aW9uRW50cnk6IGF3YWl0IHJlZ2lzdHJhdGlvblByb21pc2UgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5zdGFsbGF0aW9uRW50cnksXG4gICAgICAgIHJlZ2lzdHJhdGlvblByb21pc2VcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IEluc3RhbGxhdGlvbiBFbnRyeSBpZiBvbmUgZG9lcyBub3QgZXhpc3QuXG4gKiBBbHNvIGNsZWFycyB0aW1lZCBvdXQgcGVuZGluZyByZXF1ZXN0cy5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlT3JDcmVhdGVJbnN0YWxsYXRpb25FbnRyeShvbGRFbnRyeSkge1xuICAgIGNvbnN0IGVudHJ5ID0gb2xkRW50cnkgfHwge1xuICAgICAgICBmaWQ6IGdlbmVyYXRlRmlkKCksXG4gICAgICAgIHJlZ2lzdHJhdGlvblN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovXG4gICAgfTtcbiAgICByZXR1cm4gY2xlYXJUaW1lZE91dFJlcXVlc3QoZW50cnkpO1xufVxuLyoqXG4gKiBJZiB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlzIG5vdCByZWdpc3RlcmVkIHlldCwgdGhpcyB3aWxsIHRyaWdnZXIgdGhlXG4gKiByZWdpc3RyYXRpb24gYW5kIHJldHVybiBhbiBJblByb2dyZXNzSW5zdGFsbGF0aW9uRW50cnkuXG4gKlxuICogSWYgcmVnaXN0cmF0aW9uUHJvbWlzZSBkb2VzIG5vdCBleGlzdCwgdGhlIGluc3RhbGxhdGlvbkVudHJ5IGlzIGd1YXJhbnRlZWRcbiAqIHRvIGJlIHJlZ2lzdGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRyaWdnZXJSZWdpc3RyYXRpb25JZk5lY2Vzc2FyeShpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIGlmIChpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqLykge1xuICAgICAgICBpZiAoIW5hdmlnYXRvci5vbkxpbmUpIHtcbiAgICAgICAgICAgIC8vIFJlZ2lzdHJhdGlvbiByZXF1aXJlZCBidXQgYXBwIGlzIG9mZmxpbmUuXG4gICAgICAgICAgICBjb25zdCByZWdpc3RyYXRpb25Qcm9taXNlV2l0aEVycm9yID0gUHJvbWlzZS5yZWplY3QoRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLykpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBpbnN0YWxsYXRpb25FbnRyeSxcbiAgICAgICAgICAgICAgICByZWdpc3RyYXRpb25Qcm9taXNlOiByZWdpc3RyYXRpb25Qcm9taXNlV2l0aEVycm9yXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFRyeSByZWdpc3RlcmluZy4gQ2hhbmdlIHN0YXR1cyB0byBJTl9QUk9HUkVTUy5cbiAgICAgICAgY29uc3QgaW5Qcm9ncmVzc0VudHJ5ID0ge1xuICAgICAgICAgICAgZmlkOiBpbnN0YWxsYXRpb25FbnRyeS5maWQsXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLyxcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvblRpbWU6IERhdGUubm93KClcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVnaXN0cmF0aW9uUHJvbWlzZSA9IHJlZ2lzdGVySW5zdGFsbGF0aW9uKGluc3RhbGxhdGlvbnMsIGluUHJvZ3Jlc3NFbnRyeSk7XG4gICAgICAgIHJldHVybiB7IGluc3RhbGxhdGlvbkVudHJ5OiBpblByb2dyZXNzRW50cnksIHJlZ2lzdHJhdGlvblByb21pc2UgfTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaW5zdGFsbGF0aW9uRW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LFxuICAgICAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZTogd2FpdFVudGlsRmlkUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4geyBpbnN0YWxsYXRpb25FbnRyeSB9O1xuICAgIH1cbn1cbi8qKiBUaGlzIHdpbGwgYmUgZXhlY3V0ZWQgb25seSBvbmNlIGZvciBlYWNoIG5ldyBGaXJlYmFzZSBJbnN0YWxsYXRpb24uICovXG5hc3luYyBmdW5jdGlvbiByZWdpc3Rlckluc3RhbGxhdGlvbihpbnN0YWxsYXRpb25zLCBpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeSA9IGF3YWl0IGNyZWF0ZUluc3RhbGxhdGlvblJlcXVlc3QoaW5zdGFsbGF0aW9ucywgaW5zdGFsbGF0aW9uRW50cnkpO1xuICAgICAgICByZXR1cm4gc2V0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCByZWdpc3RlcmVkSW5zdGFsbGF0aW9uRW50cnkpO1xuICAgIH1cbiAgICBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoaXNTZXJ2ZXJFcnJvcihlKSAmJiBlLmN1c3RvbURhdGEuc2VydmVyQ29kZSA9PT0gNDA5KSB7XG4gICAgICAgICAgICAvLyBTZXJ2ZXIgcmV0dXJuZWQgYSBcIkZJRCBjYW5ub3QgYmUgdXNlZFwiIGVycm9yLlxuICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBuZXcgSUQgbmV4dCB0aW1lLlxuICAgICAgICAgICAgYXdhaXQgcmVtb3ZlKGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIFJlZ2lzdHJhdGlvbiBmYWlsZWQuIFNldCBGSUQgYXMgbm90IHJlZ2lzdGVyZWQuXG4gICAgICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHtcbiAgICAgICAgICAgICAgICBmaWQ6IGluc3RhbGxhdGlvbkVudHJ5LmZpZCxcbiAgICAgICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqL1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG4vKiogQ2FsbCBpZiBGSUQgcmVnaXN0cmF0aW9uIGlzIHBlbmRpbmcgaW4gYW5vdGhlciByZXF1ZXN0LiAqL1xuYXN5bmMgZnVuY3Rpb24gd2FpdFVudGlsRmlkUmVnaXN0cmF0aW9uKGluc3RhbGxhdGlvbnMpIHtcbiAgICAvLyBVbmZvcnR1bmF0ZWx5LCB0aGVyZSBpcyBubyB3YXkgb2YgcmVsaWFibHkgb2JzZXJ2aW5nIHdoZW4gYSB2YWx1ZSBpblxuICAgIC8vIEluZGV4ZWREQiBjaGFuZ2VzICh5ZXQsIHNlZSBodHRwczovL2dpdGh1Yi5jb20vV0lDRy9pbmRleGVkLWRiLW9ic2VydmVycyksXG4gICAgLy8gc28gd2UgbmVlZCB0byBwb2xsLlxuICAgIGxldCBlbnRyeSA9IGF3YWl0IHVwZGF0ZUluc3RhbGxhdGlvblJlcXVlc3QoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcpO1xuICAgIHdoaWxlIChlbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xuICAgICAgICAvLyBjcmVhdGVJbnN0YWxsYXRpb24gcmVxdWVzdCBzdGlsbCBpbiBwcm9ncmVzcy5cbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgZW50cnkgPSBhd2FpdCB1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICB9XG4gICAgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IHRpbWVkIG91dCBvciBmYWlsZWQgaW4gYSBkaWZmZXJlbnQgY2FsbC4gVHJ5IGFnYWluLlxuICAgICAgICBjb25zdCB7IGluc3RhbGxhdGlvbkVudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zKTtcbiAgICAgICAgaWYgKHJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiByZWdpc3RyYXRpb25Qcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gaWYgdGhlcmUgaXMgbm8gcmVnaXN0cmF0aW9uUHJvbWlzZSwgZW50cnkgaXMgcmVnaXN0ZXJlZC5cbiAgICAgICAgICAgIHJldHVybiBpbnN0YWxsYXRpb25FbnRyeTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59XG4vKipcbiAqIENhbGxlZCBvbmx5IGlmIHRoZXJlIGlzIGEgQ3JlYXRlSW5zdGFsbGF0aW9uIHJlcXVlc3QgaW4gcHJvZ3Jlc3MuXG4gKlxuICogVXBkYXRlcyB0aGUgSW5zdGFsbGF0aW9uRW50cnkgaW4gdGhlIERCIGJhc2VkIG9uIHRoZSBzdGF0dXMgb2YgdGhlXG4gKiBDcmVhdGVJbnN0YWxsYXRpb24gcmVxdWVzdC5cbiAqXG4gKiBSZXR1cm5zIHRoZSB1cGRhdGVkIEluc3RhbGxhdGlvbkVudHJ5LlxuICovXG5mdW5jdGlvbiB1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZykge1xuICAgIHJldHVybiB1cGRhdGUoYXBwQ29uZmlnLCBvbGRFbnRyeSA9PiB7XG4gICAgICAgIGlmICghb2xkRW50cnkpIHtcbiAgICAgICAgICAgIHRocm93IEVSUk9SX0ZBQ1RPUlkuY3JlYXRlKFwiaW5zdGFsbGF0aW9uLW5vdC1mb3VuZFwiIC8qIEVycm9yQ29kZS5JTlNUQUxMQVRJT05fTk9UX0ZPVU5EICovKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lZE91dFJlcXVlc3Qob2xkRW50cnkpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gY2xlYXJUaW1lZE91dFJlcXVlc3QoZW50cnkpIHtcbiAgICBpZiAoaGFzSW5zdGFsbGF0aW9uUmVxdWVzdFRpbWVkT3V0KGVudHJ5KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZmlkOiBlbnRyeS5maWQsXG4gICAgICAgICAgICByZWdpc3RyYXRpb25TdGF0dXM6IDAgLyogUmVxdWVzdFN0YXR1cy5OT1RfU1RBUlRFRCAqL1xuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG59XG5mdW5jdGlvbiBoYXNJbnN0YWxsYXRpb25SZXF1ZXN0VGltZWRPdXQoaW5zdGFsbGF0aW9uRW50cnkpIHtcbiAgICByZXR1cm4gKGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovICYmXG4gICAgICAgIGluc3RhbGxhdGlvbkVudHJ5LnJlZ2lzdHJhdGlvblRpbWUgKyBQRU5ESU5HX1RJTUVPVVRfTVMgPCBEYXRlLm5vdygpKTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlQXV0aFRva2VuUmVxdWVzdCh7IGFwcENvbmZpZywgaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyIH0sIGluc3RhbGxhdGlvbkVudHJ5KSB7XG4gICAgY29uc3QgZW5kcG9pbnQgPSBnZXRHZW5lcmF0ZUF1dGhUb2tlbkVuZHBvaW50KGFwcENvbmZpZywgaW5zdGFsbGF0aW9uRW50cnkpO1xuICAgIGNvbnN0IGhlYWRlcnMgPSBnZXRIZWFkZXJzV2l0aEF1dGgoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgLy8gSWYgaGVhcnRiZWF0IHNlcnZpY2UgZXhpc3RzLCBhZGQgdGhlIGhlYXJ0YmVhdCBzdHJpbmcgdG8gdGhlIGhlYWRlci5cbiAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlID0gaGVhcnRiZWF0U2VydmljZVByb3ZpZGVyLmdldEltbWVkaWF0ZSh7XG4gICAgICAgIG9wdGlvbmFsOiB0cnVlXG4gICAgfSk7XG4gICAgaWYgKGhlYXJ0YmVhdFNlcnZpY2UpIHtcbiAgICAgICAgY29uc3QgaGVhcnRiZWF0c0hlYWRlciA9IGF3YWl0IGhlYXJ0YmVhdFNlcnZpY2UuZ2V0SGVhcnRiZWF0c0hlYWRlcigpO1xuICAgICAgICBpZiAoaGVhcnRiZWF0c0hlYWRlcikge1xuICAgICAgICAgICAgaGVhZGVycy5hcHBlbmQoJ3gtZmlyZWJhc2UtY2xpZW50JywgaGVhcnRiZWF0c0hlYWRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYm9keSA9IHtcbiAgICAgICAgaW5zdGFsbGF0aW9uOiB7XG4gICAgICAgICAgICBzZGtWZXJzaW9uOiBQQUNLQUdFX1ZFUlNJT04sXG4gICAgICAgICAgICBhcHBJZDogYXBwQ29uZmlnLmFwcElkXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgICBoZWFkZXJzLFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KVxuICAgIH07XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCByZXRyeUlmU2VydmVyRXJyb3IoKCkgPT4gZmV0Y2goZW5kcG9pbnQsIHJlcXVlc3QpKTtcbiAgICBpZiAocmVzcG9uc2Uub2spIHtcbiAgICAgICAgY29uc3QgcmVzcG9uc2VWYWx1ZSA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgY29uc3QgY29tcGxldGVkQXV0aFRva2VuID0gZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UocmVzcG9uc2VWYWx1ZSk7XG4gICAgICAgIHJldHVybiBjb21wbGV0ZWRBdXRoVG9rZW47XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBhd2FpdCBnZXRFcnJvckZyb21SZXNwb25zZSgnR2VuZXJhdGUgQXV0aCBUb2tlbicsIHJlc3BvbnNlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRHZW5lcmF0ZUF1dGhUb2tlbkVuZHBvaW50KGFwcENvbmZpZywgeyBmaWQgfSkge1xuICAgIHJldHVybiBgJHtnZXRJbnN0YWxsYXRpb25zRW5kcG9pbnQoYXBwQ29uZmlnKX0vJHtmaWR9L2F1dGhUb2tlbnM6Z2VuZXJhdGVgO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBSZXR1cm5zIGEgdmFsaWQgYXV0aGVudGljYXRpb24gdG9rZW4gZm9yIHRoZSBpbnN0YWxsYXRpb24uIEdlbmVyYXRlcyBhIG5ld1xuICogdG9rZW4gaWYgb25lIGRvZXNuJ3QgZXhpc3QsIGlzIGV4cGlyZWQgb3IgYWJvdXQgdG8gZXhwaXJlLlxuICpcbiAqIFNob3VsZCBvbmx5IGJlIGNhbGxlZCBpZiB0aGUgRmlyZWJhc2UgSW5zdGFsbGF0aW9uIGlzIHJlZ2lzdGVyZWQuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHJlZnJlc2hBdXRoVG9rZW4oaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgICBsZXQgdG9rZW5Qcm9taXNlO1xuICAgIGNvbnN0IGVudHJ5ID0gYXdhaXQgdXBkYXRlKGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnLCBvbGRFbnRyeSA9PiB7XG4gICAgICAgIGlmICghaXNFbnRyeVJlZ2lzdGVyZWQob2xkRW50cnkpKSB7XG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcIm5vdC1yZWdpc3RlcmVkXCIgLyogRXJyb3JDb2RlLk5PVF9SRUdJU1RFUkVEICovKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvbGRBdXRoVG9rZW4gPSBvbGRFbnRyeS5hdXRoVG9rZW47XG4gICAgICAgIGlmICghZm9yY2VSZWZyZXNoICYmIGlzQXV0aFRva2VuVmFsaWQob2xkQXV0aFRva2VuKSkge1xuICAgICAgICAgICAgLy8gVGhlcmUgaXMgYSB2YWxpZCB0b2tlbiBpbiB0aGUgREIuXG4gICAgICAgICAgICByZXR1cm4gb2xkRW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2xkQXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xuICAgICAgICAgICAgLy8gVGhlcmUgYWxyZWFkeSBpcyBhIHRva2VuIHJlcXVlc3QgaW4gcHJvZ3Jlc3MuXG4gICAgICAgICAgICB0b2tlblByb21pc2UgPSB3YWl0VW50aWxBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGZvcmNlUmVmcmVzaCk7XG4gICAgICAgICAgICByZXR1cm4gb2xkRW50cnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBObyB0b2tlbiBvciB0b2tlbiBleHBpcmVkLlxuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBpblByb2dyZXNzRW50cnkgPSBtYWtlQXV0aFRva2VuUmVxdWVzdEluUHJvZ3Jlc3NFbnRyeShvbGRFbnRyeSk7XG4gICAgICAgICAgICB0b2tlblByb21pc2UgPSBmZXRjaEF1dGhUb2tlbkZyb21TZXJ2ZXIoaW5zdGFsbGF0aW9ucywgaW5Qcm9ncmVzc0VudHJ5KTtcbiAgICAgICAgICAgIHJldHVybiBpblByb2dyZXNzRW50cnk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBhdXRoVG9rZW4gPSB0b2tlblByb21pc2VcbiAgICAgICAgPyBhd2FpdCB0b2tlblByb21pc2VcbiAgICAgICAgOiBlbnRyeS5hdXRoVG9rZW47XG4gICAgcmV0dXJuIGF1dGhUb2tlbjtcbn1cbi8qKlxuICogQ2FsbCBvbmx5IGlmIEZJRCBpcyByZWdpc3RlcmVkIGFuZCBBdXRoIFRva2VuIHJlcXVlc3QgaXMgaW4gcHJvZ3Jlc3MuXG4gKlxuICogV2FpdHMgdW50aWwgdGhlIGN1cnJlbnQgcGVuZGluZyByZXF1ZXN0IGZpbmlzaGVzLiBJZiB0aGUgcmVxdWVzdCB0aW1lcyBvdXQsXG4gKiB0cmllcyBvbmNlIGluIHRoaXMgdGhyZWFkIGFzIHdlbGwuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIHdhaXRVbnRpbEF1dGhUb2tlblJlcXVlc3QoaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoKSB7XG4gICAgLy8gVW5mb3J0dW5hdGVseSwgdGhlcmUgaXMgbm8gd2F5IG9mIHJlbGlhYmx5IG9ic2VydmluZyB3aGVuIGEgdmFsdWUgaW5cbiAgICAvLyBJbmRleGVkREIgY2hhbmdlcyAoeWV0LCBzZWUgaHR0cHM6Ly9naXRodWIuY29tL1dJQ0cvaW5kZXhlZC1kYi1vYnNlcnZlcnMpLFxuICAgIC8vIHNvIHdlIG5lZWQgdG8gcG9sbC5cbiAgICBsZXQgZW50cnkgPSBhd2FpdCB1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICB3aGlsZSAoZW50cnkuYXV0aFRva2VuLnJlcXVlc3RTdGF0dXMgPT09IDEgLyogUmVxdWVzdFN0YXR1cy5JTl9QUk9HUkVTUyAqLykge1xuICAgICAgICAvLyBnZW5lcmF0ZUF1dGhUb2tlbiBzdGlsbCBpbiBwcm9ncmVzcy5cbiAgICAgICAgYXdhaXQgc2xlZXAoMTAwKTtcbiAgICAgICAgZW50cnkgPSBhd2FpdCB1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMuYXBwQ29uZmlnKTtcbiAgICB9XG4gICAgY29uc3QgYXV0aFRva2VuID0gZW50cnkuYXV0aFRva2VuO1xuICAgIGlmIChhdXRoVG9rZW4ucmVxdWVzdFN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XG4gICAgICAgIC8vIFRoZSByZXF1ZXN0IHRpbWVkIG91dCBvciBmYWlsZWQgaW4gYSBkaWZmZXJlbnQgY2FsbC4gVHJ5IGFnYWluLlxuICAgICAgICByZXR1cm4gcmVmcmVzaEF1dGhUb2tlbihpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2gpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGF1dGhUb2tlbjtcbiAgICB9XG59XG4vKipcbiAqIENhbGxlZCBvbmx5IGlmIHRoZXJlIGlzIGEgR2VuZXJhdGVBdXRoVG9rZW4gcmVxdWVzdCBpbiBwcm9ncmVzcy5cbiAqXG4gKiBVcGRhdGVzIHRoZSBJbnN0YWxsYXRpb25FbnRyeSBpbiB0aGUgREIgYmFzZWQgb24gdGhlIHN0YXR1cyBvZiB0aGVcbiAqIEdlbmVyYXRlQXV0aFRva2VuIHJlcXVlc3QuXG4gKlxuICogUmV0dXJucyB0aGUgdXBkYXRlZCBJbnN0YWxsYXRpb25FbnRyeS5cbiAqL1xuZnVuY3Rpb24gdXBkYXRlQXV0aFRva2VuUmVxdWVzdChhcHBDb25maWcpIHtcbiAgICByZXR1cm4gdXBkYXRlKGFwcENvbmZpZywgb2xkRW50cnkgPT4ge1xuICAgICAgICBpZiAoIWlzRW50cnlSZWdpc3RlcmVkKG9sZEVudHJ5KSkge1xuICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJub3QtcmVnaXN0ZXJlZFwiIC8qIEVycm9yQ29kZS5OT1RfUkVHSVNURVJFRCAqLyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2xkQXV0aFRva2VuID0gb2xkRW50cnkuYXV0aFRva2VuO1xuICAgICAgICBpZiAoaGFzQXV0aFRva2VuUmVxdWVzdFRpbWVkT3V0KG9sZEF1dGhUb2tlbikpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9sZEVudHJ5KSwgeyBhdXRoVG9rZW46IHsgcmVxdWVzdFN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovIH0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xuICAgIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24gZmV0Y2hBdXRoVG9rZW5Gcm9tU2VydmVyKGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgYXV0aFRva2VuID0gYXdhaXQgZ2VuZXJhdGVBdXRoVG9rZW5SZXF1ZXN0KGluc3RhbGxhdGlvbnMsIGluc3RhbGxhdGlvbkVudHJ5KTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBpbnN0YWxsYXRpb25FbnRyeSksIHsgYXV0aFRva2VuIH0pO1xuICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgICAgIHJldHVybiBhdXRoVG9rZW47XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIGlmIChpc1NlcnZlckVycm9yKGUpICYmXG4gICAgICAgICAgICAoZS5jdXN0b21EYXRhLnNlcnZlckNvZGUgPT09IDQwMSB8fCBlLmN1c3RvbURhdGEuc2VydmVyQ29kZSA9PT0gNDA0KSkge1xuICAgICAgICAgICAgLy8gU2VydmVyIHJldHVybmVkIGEgXCJGSUQgbm90IGZvdW5kXCIgb3IgYSBcIkludmFsaWQgYXV0aGVudGljYXRpb25cIiBlcnJvci5cbiAgICAgICAgICAgIC8vIEdlbmVyYXRlIGEgbmV3IElEIG5leHQgdGltZS5cbiAgICAgICAgICAgIGF3YWl0IHJlbW92ZShpbnN0YWxsYXRpb25zLmFwcENvbmZpZyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkSW5zdGFsbGF0aW9uRW50cnkgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGluc3RhbGxhdGlvbkVudHJ5KSwgeyBhdXRoVG9rZW46IHsgcmVxdWVzdFN0YXR1czogMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovIH0gfSk7XG4gICAgICAgICAgICBhd2FpdCBzZXQoaW5zdGFsbGF0aW9ucy5hcHBDb25maWcsIHVwZGF0ZWRJbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZTtcbiAgICB9XG59XG5mdW5jdGlvbiBpc0VudHJ5UmVnaXN0ZXJlZChpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIHJldHVybiAoaW5zdGFsbGF0aW9uRW50cnkgIT09IHVuZGVmaW5lZCAmJlxuICAgICAgICBpbnN0YWxsYXRpb25FbnRyeS5yZWdpc3RyYXRpb25TdGF0dXMgPT09IDIgLyogUmVxdWVzdFN0YXR1cy5DT01QTEVURUQgKi8pO1xufVxuZnVuY3Rpb24gaXNBdXRoVG9rZW5WYWxpZChhdXRoVG9rZW4pIHtcbiAgICByZXR1cm4gKGF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAyIC8qIFJlcXVlc3RTdGF0dXMuQ09NUExFVEVEICovICYmXG4gICAgICAgICFpc0F1dGhUb2tlbkV4cGlyZWQoYXV0aFRva2VuKSk7XG59XG5mdW5jdGlvbiBpc0F1dGhUb2tlbkV4cGlyZWQoYXV0aFRva2VuKSB7XG4gICAgY29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcbiAgICByZXR1cm4gKG5vdyA8IGF1dGhUb2tlbi5jcmVhdGlvblRpbWUgfHxcbiAgICAgICAgYXV0aFRva2VuLmNyZWF0aW9uVGltZSArIGF1dGhUb2tlbi5leHBpcmVzSW4gPCBub3cgKyBUT0tFTl9FWFBJUkFUSU9OX0JVRkZFUik7XG59XG4vKiogUmV0dXJucyBhbiB1cGRhdGVkIEluc3RhbGxhdGlvbkVudHJ5IHdpdGggYW4gSW5Qcm9ncmVzc0F1dGhUb2tlbi4gKi9cbmZ1bmN0aW9uIG1ha2VBdXRoVG9rZW5SZXF1ZXN0SW5Qcm9ncmVzc0VudHJ5KG9sZEVudHJ5KSB7XG4gICAgY29uc3QgaW5Qcm9ncmVzc0F1dGhUb2tlbiA9IHtcbiAgICAgICAgcmVxdWVzdFN0YXR1czogMSAvKiBSZXF1ZXN0U3RhdHVzLklOX1BST0dSRVNTICovLFxuICAgICAgICByZXF1ZXN0VGltZTogRGF0ZS5ub3coKVxuICAgIH07XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgb2xkRW50cnkpLCB7IGF1dGhUb2tlbjogaW5Qcm9ncmVzc0F1dGhUb2tlbiB9KTtcbn1cbmZ1bmN0aW9uIGhhc0F1dGhUb2tlblJlcXVlc3RUaW1lZE91dChhdXRoVG9rZW4pIHtcbiAgICByZXR1cm4gKGF1dGhUb2tlbi5yZXF1ZXN0U3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8gJiZcbiAgICAgICAgYXV0aFRva2VuLnJlcXVlc3RUaW1lICsgUEVORElOR19USU1FT1VUX01TIDwgRGF0ZS5ub3coKSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIENyZWF0ZXMgYSBGaXJlYmFzZSBJbnN0YWxsYXRpb24gaWYgdGhlcmUgaXNuJ3Qgb25lIGZvciB0aGUgYXBwIGFuZFxuICogcmV0dXJucyB0aGUgSW5zdGFsbGF0aW9uIElELlxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxuICpcbiAqIEBwdWJsaWNcbiAqL1xuYXN5bmMgZnVuY3Rpb24gZ2V0SWQoaW5zdGFsbGF0aW9ucykge1xuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gaW5zdGFsbGF0aW9ucztcbiAgICBjb25zdCB7IGluc3RhbGxhdGlvbkVudHJ5LCByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zSW1wbCk7XG4gICAgaWYgKHJlZ2lzdHJhdGlvblByb21pc2UpIHtcbiAgICAgICAgcmVnaXN0cmF0aW9uUHJvbWlzZS5jYXRjaChjb25zb2xlLmVycm9yKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIElmIHRoZSBpbnN0YWxsYXRpb24gaXMgYWxyZWFkeSByZWdpc3RlcmVkLCB1cGRhdGUgdGhlIGF1dGhlbnRpY2F0aW9uXG4gICAgICAgIC8vIHRva2VuIGlmIG5lZWRlZC5cbiAgICAgICAgcmVmcmVzaEF1dGhUb2tlbihpbnN0YWxsYXRpb25zSW1wbCkuY2F0Y2goY29uc29sZS5lcnJvcik7XG4gICAgfVxuICAgIHJldHVybiBpbnN0YWxsYXRpb25FbnRyeS5maWQ7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG4vKipcbiAqIFJldHVybnMgYSBGaXJlYmFzZSBJbnN0YWxsYXRpb25zIGF1dGggdG9rZW4sIGlkZW50aWZ5aW5nIHRoZSBjdXJyZW50XG4gKiBGaXJlYmFzZSBJbnN0YWxsYXRpb24uXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXG4gKiBAcGFyYW0gZm9yY2VSZWZyZXNoIC0gRm9yY2UgcmVmcmVzaCByZWdhcmRsZXNzIG9mIHRva2VuIGV4cGlyYXRpb24uXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBnZXRUb2tlbihpbnN0YWxsYXRpb25zLCBmb3JjZVJlZnJlc2ggPSBmYWxzZSkge1xuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbXBsID0gaW5zdGFsbGF0aW9ucztcbiAgICBhd2FpdCBjb21wbGV0ZUluc3RhbGxhdGlvblJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zSW1wbCk7XG4gICAgLy8gQXQgdGhpcyBwb2ludCB3ZSBlaXRoZXIgaGF2ZSBhIFJlZ2lzdGVyZWQgSW5zdGFsbGF0aW9uIGluIHRoZSBEQiwgb3Igd2UndmVcbiAgICAvLyBhbHJlYWR5IHRocm93biBhbiBlcnJvci5cbiAgICBjb25zdCBhdXRoVG9rZW4gPSBhd2FpdCByZWZyZXNoQXV0aFRva2VuKGluc3RhbGxhdGlvbnNJbXBsLCBmb3JjZVJlZnJlc2gpO1xuICAgIHJldHVybiBhdXRoVG9rZW4udG9rZW47XG59XG5hc3luYyBmdW5jdGlvbiBjb21wbGV0ZUluc3RhbGxhdGlvblJlZ2lzdHJhdGlvbihpbnN0YWxsYXRpb25zKSB7XG4gICAgY29uc3QgeyByZWdpc3RyYXRpb25Qcm9taXNlIH0gPSBhd2FpdCBnZXRJbnN0YWxsYXRpb25FbnRyeShpbnN0YWxsYXRpb25zKTtcbiAgICBpZiAocmVnaXN0cmF0aW9uUHJvbWlzZSkge1xuICAgICAgICAvLyBBIGNyZWF0ZUluc3RhbGxhdGlvbiByZXF1ZXN0IGlzIGluIHByb2dyZXNzLiBXYWl0IHVudGlsIGl0IGZpbmlzaGVzLlxuICAgICAgICBhd2FpdCByZWdpc3RyYXRpb25Qcm9taXNlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGRlbGV0ZUluc3RhbGxhdGlvblJlcXVlc3QoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSkge1xuICAgIGNvbnN0IGVuZHBvaW50ID0gZ2V0RGVsZXRlRW5kcG9pbnQoYXBwQ29uZmlnLCBpbnN0YWxsYXRpb25FbnRyeSk7XG4gICAgY29uc3QgaGVhZGVycyA9IGdldEhlYWRlcnNXaXRoQXV0aChhcHBDb25maWcsIGluc3RhbGxhdGlvbkVudHJ5KTtcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICBtZXRob2Q6ICdERUxFVEUnLFxuICAgICAgICBoZWFkZXJzXG4gICAgfTtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IHJldHJ5SWZTZXJ2ZXJFcnJvcigoKSA9PiBmZXRjaChlbmRwb2ludCwgcmVxdWVzdCkpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgICAgdGhyb3cgYXdhaXQgZ2V0RXJyb3JGcm9tUmVzcG9uc2UoJ0RlbGV0ZSBJbnN0YWxsYXRpb24nLCByZXNwb25zZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0RGVsZXRlRW5kcG9pbnQoYXBwQ29uZmlnLCB7IGZpZCB9KSB7XG4gICAgcmV0dXJuIGAke2dldEluc3RhbGxhdGlvbnNFbmRwb2ludChhcHBDb25maWcpfS8ke2ZpZH1gO1xufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBEZWxldGVzIHRoZSBGaXJlYmFzZSBJbnN0YWxsYXRpb24gYW5kIGFsbCBhc3NvY2lhdGVkIGRhdGEuXG4gKiBAcGFyYW0gaW5zdGFsbGF0aW9ucyAtIFRoZSBgSW5zdGFsbGF0aW9uc2AgaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5hc3luYyBmdW5jdGlvbiBkZWxldGVJbnN0YWxsYXRpb25zKGluc3RhbGxhdGlvbnMpIHtcbiAgICBjb25zdCB7IGFwcENvbmZpZyB9ID0gaW5zdGFsbGF0aW9ucztcbiAgICBjb25zdCBlbnRyeSA9IGF3YWl0IHVwZGF0ZShhcHBDb25maWcsIG9sZEVudHJ5ID0+IHtcbiAgICAgICAgaWYgKG9sZEVudHJ5ICYmIG9sZEVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMCAvKiBSZXF1ZXN0U3RhdHVzLk5PVF9TVEFSVEVEICovKSB7XG4gICAgICAgICAgICAvLyBEZWxldGUgdGhlIHVucmVnaXN0ZXJlZCBlbnRyeSB3aXRob3V0IHNlbmRpbmcgYSBkZWxldGVJbnN0YWxsYXRpb24gcmVxdWVzdC5cbiAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9sZEVudHJ5O1xuICAgIH0pO1xuICAgIGlmIChlbnRyeSkge1xuICAgICAgICBpZiAoZW50cnkucmVnaXN0cmF0aW9uU3RhdHVzID09PSAxIC8qIFJlcXVlc3RTdGF0dXMuSU5fUFJPR1JFU1MgKi8pIHtcbiAgICAgICAgICAgIC8vIENhbid0IGRlbGV0ZSB3aGlsZSB0cnlpbmcgdG8gcmVnaXN0ZXIuXG4gICAgICAgICAgICB0aHJvdyBFUlJPUl9GQUNUT1JZLmNyZWF0ZShcImRlbGV0ZS1wZW5kaW5nLXJlZ2lzdHJhdGlvblwiIC8qIEVycm9yQ29kZS5ERUxFVEVfUEVORElOR19SRUdJU1RSQVRJT04gKi8pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVudHJ5LnJlZ2lzdHJhdGlvblN0YXR1cyA9PT0gMiAvKiBSZXF1ZXN0U3RhdHVzLkNPTVBMRVRFRCAqLykge1xuICAgICAgICAgICAgaWYgKCFuYXZpZ2F0b3Iub25MaW5lKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJhcHAtb2ZmbGluZVwiIC8qIEVycm9yQ29kZS5BUFBfT0ZGTElORSAqLyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBkZWxldGVJbnN0YWxsYXRpb25SZXF1ZXN0KGFwcENvbmZpZywgZW50cnkpO1xuICAgICAgICAgICAgICAgIGF3YWl0IHJlbW92ZShhcHBDb25maWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuLyoqXG4gKiBTZXRzIGEgbmV3IGNhbGxiYWNrIHRoYXQgd2lsbCBnZXQgY2FsbGVkIHdoZW4gSW5zdGFsbGF0aW9uIElEIGNoYW5nZXMuXG4gKiBSZXR1cm5zIGFuIHVuc3Vic2NyaWJlIGZ1bmN0aW9uIHRoYXQgd2lsbCByZW1vdmUgdGhlIGNhbGxiYWNrIHdoZW4gY2FsbGVkLlxuICogQHBhcmFtIGluc3RhbGxhdGlvbnMgLSBUaGUgYEluc3RhbGxhdGlvbnNgIGluc3RhbmNlLlxuICogQHBhcmFtIGNhbGxiYWNrIC0gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHRoYXQgaXMgaW52b2tlZCB3aGVuIEZJRCBjaGFuZ2VzLlxuICogQHJldHVybnMgQSBmdW5jdGlvbiB0aGF0IGNhbiBiZSBjYWxsZWQgdG8gdW5zdWJzY3JpYmUuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBvbklkQ2hhbmdlKGluc3RhbGxhdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgY29uc3QgeyBhcHBDb25maWcgfSA9IGluc3RhbGxhdGlvbnM7XG4gICAgYWRkQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjayk7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgcmVtb3ZlQ2FsbGJhY2soYXBwQ29uZmlnLCBjYWxsYmFjayk7XG4gICAgfTtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbi8qKlxuICogUmV0dXJucyBhbiBpbnN0YW5jZSBvZiB7QGxpbmsgSW5zdGFsbGF0aW9uc30gYXNzb2NpYXRlZCB3aXRoIHRoZSBnaXZlblxuICoge0BsaW5rIEBmaXJlYmFzZS9hcHAjRmlyZWJhc2VBcHB9IGluc3RhbmNlLlxuICogQHBhcmFtIGFwcCAtIFRoZSB7QGxpbmsgQGZpcmViYXNlL2FwcCNGaXJlYmFzZUFwcH0gaW5zdGFuY2UuXG4gKlxuICogQHB1YmxpY1xuICovXG5mdW5jdGlvbiBnZXRJbnN0YWxsYXRpb25zKGFwcCA9IGdldEFwcCgpKSB7XG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ltcGwgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnaW5zdGFsbGF0aW9ucycpLmdldEltbWVkaWF0ZSgpO1xuICAgIHJldHVybiBpbnN0YWxsYXRpb25zSW1wbDtcbn1cblxuLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgR29vZ2xlIExMQ1xuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmZ1bmN0aW9uIGV4dHJhY3RBcHBDb25maWcoYXBwKSB7XG4gICAgaWYgKCFhcHAgfHwgIWFwcC5vcHRpb25zKSB7XG4gICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKCdBcHAgQ29uZmlndXJhdGlvbicpO1xuICAgIH1cbiAgICBpZiAoIWFwcC5uYW1lKSB7XG4gICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKCdBcHAgTmFtZScpO1xuICAgIH1cbiAgICAvLyBSZXF1aXJlZCBhcHAgY29uZmlnIGtleXNcbiAgICBjb25zdCBjb25maWdLZXlzID0gW1xuICAgICAgICAncHJvamVjdElkJyxcbiAgICAgICAgJ2FwaUtleScsXG4gICAgICAgICdhcHBJZCdcbiAgICBdO1xuICAgIGZvciAoY29uc3Qga2V5TmFtZSBvZiBjb25maWdLZXlzKSB7XG4gICAgICAgIGlmICghYXBwLm9wdGlvbnNba2V5TmFtZV0pIHtcbiAgICAgICAgICAgIHRocm93IGdldE1pc3NpbmdWYWx1ZUVycm9yKGtleU5hbWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGFwcE5hbWU6IGFwcC5uYW1lLFxuICAgICAgICBwcm9qZWN0SWQ6IGFwcC5vcHRpb25zLnByb2plY3RJZCxcbiAgICAgICAgYXBpS2V5OiBhcHAub3B0aW9ucy5hcGlLZXksXG4gICAgICAgIGFwcElkOiBhcHAub3B0aW9ucy5hcHBJZFxuICAgIH07XG59XG5mdW5jdGlvbiBnZXRNaXNzaW5nVmFsdWVFcnJvcih2YWx1ZU5hbWUpIHtcbiAgICByZXR1cm4gRVJST1JfRkFDVE9SWS5jcmVhdGUoXCJtaXNzaW5nLWFwcC1jb25maWctdmFsdWVzXCIgLyogRXJyb3JDb2RlLk1JU1NJTkdfQVBQX0NPTkZJR19WQUxVRVMgKi8sIHtcbiAgICAgICAgdmFsdWVOYW1lXG4gICAgfSk7XG59XG5cbi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDIwIEdvb2dsZSBMTENcbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5jb25zdCBJTlNUQUxMQVRJT05TX05BTUUgPSAnaW5zdGFsbGF0aW9ucyc7XG5jb25zdCBJTlNUQUxMQVRJT05TX05BTUVfSU5URVJOQUwgPSAnaW5zdGFsbGF0aW9ucy1pbnRlcm5hbCc7XG5jb25zdCBwdWJsaWNGYWN0b3J5ID0gKGNvbnRhaW5lcikgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgLy8gVGhyb3dzIGlmIGFwcCBpc24ndCBjb25maWd1cmVkIHByb3Blcmx5LlxuICAgIGNvbnN0IGFwcENvbmZpZyA9IGV4dHJhY3RBcHBDb25maWcoYXBwKTtcbiAgICBjb25zdCBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIgPSBfZ2V0UHJvdmlkZXIoYXBwLCAnaGVhcnRiZWF0Jyk7XG4gICAgY29uc3QgaW5zdGFsbGF0aW9uc0ltcGwgPSB7XG4gICAgICAgIGFwcCxcbiAgICAgICAgYXBwQ29uZmlnLFxuICAgICAgICBoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIsXG4gICAgICAgIF9kZWxldGU6ICgpID0+IFByb21pc2UucmVzb2x2ZSgpXG4gICAgfTtcbiAgICByZXR1cm4gaW5zdGFsbGF0aW9uc0ltcGw7XG59O1xuY29uc3QgaW50ZXJuYWxGYWN0b3J5ID0gKGNvbnRhaW5lcikgPT4ge1xuICAgIGNvbnN0IGFwcCA9IGNvbnRhaW5lci5nZXRQcm92aWRlcignYXBwJykuZ2V0SW1tZWRpYXRlKCk7XG4gICAgLy8gSW50ZXJuYWwgRklTIGluc3RhbmNlIHJlbGllcyBvbiBwdWJsaWMgRklTIGluc3RhbmNlLlxuICAgIGNvbnN0IGluc3RhbGxhdGlvbnMgPSBfZ2V0UHJvdmlkZXIoYXBwLCBJTlNUQUxMQVRJT05TX05BTUUpLmdldEltbWVkaWF0ZSgpO1xuICAgIGNvbnN0IGluc3RhbGxhdGlvbnNJbnRlcm5hbCA9IHtcbiAgICAgICAgZ2V0SWQ6ICgpID0+IGdldElkKGluc3RhbGxhdGlvbnMpLFxuICAgICAgICBnZXRUb2tlbjogKGZvcmNlUmVmcmVzaCkgPT4gZ2V0VG9rZW4oaW5zdGFsbGF0aW9ucywgZm9yY2VSZWZyZXNoKVxuICAgIH07XG4gICAgcmV0dXJuIGluc3RhbGxhdGlvbnNJbnRlcm5hbDtcbn07XG5mdW5jdGlvbiByZWdpc3Rlckluc3RhbGxhdGlvbnMoKSB7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoSU5TVEFMTEFUSU9OU19OQU1FLCBwdWJsaWNGYWN0b3J5LCBcIlBVQkxJQ1wiIC8qIENvbXBvbmVudFR5cGUuUFVCTElDICovKSk7XG4gICAgX3JlZ2lzdGVyQ29tcG9uZW50KG5ldyBDb21wb25lbnQoSU5TVEFMTEFUSU9OU19OQU1FX0lOVEVSTkFMLCBpbnRlcm5hbEZhY3RvcnksIFwiUFJJVkFURVwiIC8qIENvbXBvbmVudFR5cGUuUFJJVkFURSAqLykpO1xufVxuXG4vKipcbiAqIFRoZSBGaXJlYmFzZSBJbnN0YWxsYXRpb25zIFdlYiBTREsuXG4gKiBUaGlzIFNESyBkb2VzIG5vdCB3b3JrIGluIGEgTm9kZS5qcyBlbnZpcm9ubWVudC5cbiAqXG4gKiBAcGFja2FnZURvY3VtZW50YXRpb25cbiAqL1xucmVnaXN0ZXJJbnN0YWxsYXRpb25zKCk7XG5yZWdpc3RlclZlcnNpb24obmFtZSwgdmVyc2lvbik7XG4vLyBCVUlMRF9UQVJHRVQgd2lsbCBiZSByZXBsYWNlZCBieSB2YWx1ZXMgbGlrZSBlc20yMDE3LCBjanMyMDE3LCBldGMgZHVyaW5nIHRoZSBjb21waWxhdGlvblxucmVnaXN0ZXJWZXJzaW9uKG5hbWUsIHZlcnNpb24sICdlc20yMDE3Jyk7XG5cbmV4cG9ydCB7IGRlbGV0ZUluc3RhbGxhdGlvbnMsIGdldElkLCBnZXRJbnN0YWxsYXRpb25zLCBnZXRUb2tlbiwgb25JZENoYW5nZSB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtMjAxNy5qcy5tYXBcbiJdLCJuYW1lcyI6WyJfZ2V0UHJvdmlkZXIiLCJnZXRBcHAiLCJfcmVnaXN0ZXJDb21wb25lbnQiLCJyZWdpc3RlclZlcnNpb24iLCJDb21wb25lbnQiLCJFcnJvckZhY3RvcnkiLCJGaXJlYmFzZUVycm9yIiwib3BlbkRCIiwibmFtZSIsInZlcnNpb24iLCJQRU5ESU5HX1RJTUVPVVRfTVMiLCJQQUNLQUdFX1ZFUlNJT04iLCJJTlRFUk5BTF9BVVRIX1ZFUlNJT04iLCJJTlNUQUxMQVRJT05TX0FQSV9VUkwiLCJUT0tFTl9FWFBJUkFUSU9OX0JVRkZFUiIsIlNFUlZJQ0UiLCJTRVJWSUNFX05BTUUiLCJFUlJPUl9ERVNDUklQVElPTl9NQVAiLCJFUlJPUl9GQUNUT1JZIiwiaXNTZXJ2ZXJFcnJvciIsImVycm9yIiwiY29kZSIsImluY2x1ZGVzIiwiZ2V0SW5zdGFsbGF0aW9uc0VuZHBvaW50IiwicHJvamVjdElkIiwiZXh0cmFjdEF1dGhUb2tlbkluZm9Gcm9tUmVzcG9uc2UiLCJyZXNwb25zZSIsInRva2VuIiwicmVxdWVzdFN0YXR1cyIsImV4cGlyZXNJbiIsImdldEV4cGlyZXNJbkZyb21SZXNwb25zZUV4cGlyZXNJbiIsImNyZWF0aW9uVGltZSIsIkRhdGUiLCJub3ciLCJnZXRFcnJvckZyb21SZXNwb25zZSIsInJlcXVlc3ROYW1lIiwicmVzcG9uc2VKc29uIiwianNvbiIsImVycm9yRGF0YSIsImNyZWF0ZSIsInNlcnZlckNvZGUiLCJzZXJ2ZXJNZXNzYWdlIiwibWVzc2FnZSIsInNlcnZlclN0YXR1cyIsInN0YXR1cyIsImdldEhlYWRlcnMiLCJhcGlLZXkiLCJIZWFkZXJzIiwiQWNjZXB0IiwiZ2V0SGVhZGVyc1dpdGhBdXRoIiwiYXBwQ29uZmlnIiwicmVmcmVzaFRva2VuIiwiaGVhZGVycyIsImFwcGVuZCIsImdldEF1dGhvcml6YXRpb25IZWFkZXIiLCJyZXRyeUlmU2VydmVyRXJyb3IiLCJmbiIsInJlc3VsdCIsInJlc3BvbnNlRXhwaXJlc0luIiwiTnVtYmVyIiwicmVwbGFjZSIsImNyZWF0ZUluc3RhbGxhdGlvblJlcXVlc3QiLCJoZWFydGJlYXRTZXJ2aWNlUHJvdmlkZXIiLCJmaWQiLCJlbmRwb2ludCIsImhlYXJ0YmVhdFNlcnZpY2UiLCJnZXRJbW1lZGlhdGUiLCJvcHRpb25hbCIsImhlYXJ0YmVhdHNIZWFkZXIiLCJnZXRIZWFydGJlYXRzSGVhZGVyIiwiYm9keSIsImF1dGhWZXJzaW9uIiwiYXBwSWQiLCJzZGtWZXJzaW9uIiwicmVxdWVzdCIsIm1ldGhvZCIsIkpTT04iLCJzdHJpbmdpZnkiLCJmZXRjaCIsIm9rIiwicmVzcG9uc2VWYWx1ZSIsInJlZ2lzdGVyZWRJbnN0YWxsYXRpb25FbnRyeSIsInJlZ2lzdHJhdGlvblN0YXR1cyIsImF1dGhUb2tlbiIsInNsZWVwIiwibXMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJidWZmZXJUb0Jhc2U2NFVybFNhZmUiLCJhcnJheSIsImI2NCIsImJ0b2EiLCJTdHJpbmciLCJmcm9tQ2hhckNvZGUiLCJWQUxJRF9GSURfUEFUVEVSTiIsIklOVkFMSURfRklEIiwiZ2VuZXJhdGVGaWQiLCJmaWRCeXRlQXJyYXkiLCJVaW50OEFycmF5IiwiY3J5cHRvIiwic2VsZiIsIm1zQ3J5cHRvIiwiZ2V0UmFuZG9tVmFsdWVzIiwiZW5jb2RlIiwidGVzdCIsIl9hIiwiYjY0U3RyaW5nIiwic3Vic3RyIiwiZ2V0S2V5IiwiYXBwTmFtZSIsImZpZENoYW5nZUNhbGxiYWNrcyIsIk1hcCIsImZpZENoYW5nZWQiLCJrZXkiLCJjYWxsRmlkQ2hhbmdlQ2FsbGJhY2tzIiwiYnJvYWRjYXN0RmlkQ2hhbmdlIiwiYWRkQ2FsbGJhY2siLCJjYWxsYmFjayIsImdldEJyb2FkY2FzdENoYW5uZWwiLCJjYWxsYmFja1NldCIsImdldCIsIlNldCIsInNldCIsImFkZCIsInJlbW92ZUNhbGxiYWNrIiwiZGVsZXRlIiwic2l6ZSIsImNsb3NlQnJvYWRjYXN0Q2hhbm5lbCIsImNhbGxiYWNrcyIsImNoYW5uZWwiLCJwb3N0TWVzc2FnZSIsImJyb2FkY2FzdENoYW5uZWwiLCJCcm9hZGNhc3RDaGFubmVsIiwib25tZXNzYWdlIiwiZSIsImRhdGEiLCJjbG9zZSIsIkRBVEFCQVNFX05BTUUiLCJEQVRBQkFTRV9WRVJTSU9OIiwiT0JKRUNUX1NUT1JFX05BTUUiLCJkYlByb21pc2UiLCJnZXREYlByb21pc2UiLCJ1cGdyYWRlIiwiZGIiLCJvbGRWZXJzaW9uIiwiY3JlYXRlT2JqZWN0U3RvcmUiLCJ2YWx1ZSIsInR4IiwidHJhbnNhY3Rpb24iLCJvYmplY3RTdG9yZSIsIm9sZFZhbHVlIiwicHV0IiwiZG9uZSIsInJlbW92ZSIsInVwZGF0ZSIsInVwZGF0ZUZuIiwic3RvcmUiLCJuZXdWYWx1ZSIsInVuZGVmaW5lZCIsImdldEluc3RhbGxhdGlvbkVudHJ5IiwiaW5zdGFsbGF0aW9ucyIsInJlZ2lzdHJhdGlvblByb21pc2UiLCJpbnN0YWxsYXRpb25FbnRyeSIsIm9sZEVudHJ5IiwidXBkYXRlT3JDcmVhdGVJbnN0YWxsYXRpb25FbnRyeSIsImVudHJ5V2l0aFByb21pc2UiLCJ0cmlnZ2VyUmVnaXN0cmF0aW9uSWZOZWNlc3NhcnkiLCJlbnRyeSIsImNsZWFyVGltZWRPdXRSZXF1ZXN0IiwibmF2aWdhdG9yIiwib25MaW5lIiwicmVnaXN0cmF0aW9uUHJvbWlzZVdpdGhFcnJvciIsInJlamVjdCIsImluUHJvZ3Jlc3NFbnRyeSIsInJlZ2lzdHJhdGlvblRpbWUiLCJyZWdpc3Rlckluc3RhbGxhdGlvbiIsIndhaXRVbnRpbEZpZFJlZ2lzdHJhdGlvbiIsImN1c3RvbURhdGEiLCJ1cGRhdGVJbnN0YWxsYXRpb25SZXF1ZXN0IiwiaGFzSW5zdGFsbGF0aW9uUmVxdWVzdFRpbWVkT3V0IiwiZ2VuZXJhdGVBdXRoVG9rZW5SZXF1ZXN0IiwiZ2V0R2VuZXJhdGVBdXRoVG9rZW5FbmRwb2ludCIsImluc3RhbGxhdGlvbiIsImNvbXBsZXRlZEF1dGhUb2tlbiIsInJlZnJlc2hBdXRoVG9rZW4iLCJmb3JjZVJlZnJlc2giLCJ0b2tlblByb21pc2UiLCJpc0VudHJ5UmVnaXN0ZXJlZCIsIm9sZEF1dGhUb2tlbiIsImlzQXV0aFRva2VuVmFsaWQiLCJ3YWl0VW50aWxBdXRoVG9rZW5SZXF1ZXN0IiwibWFrZUF1dGhUb2tlblJlcXVlc3RJblByb2dyZXNzRW50cnkiLCJmZXRjaEF1dGhUb2tlbkZyb21TZXJ2ZXIiLCJ1cGRhdGVBdXRoVG9rZW5SZXF1ZXN0IiwiaGFzQXV0aFRva2VuUmVxdWVzdFRpbWVkT3V0IiwiT2JqZWN0IiwiYXNzaWduIiwidXBkYXRlZEluc3RhbGxhdGlvbkVudHJ5IiwiaXNBdXRoVG9rZW5FeHBpcmVkIiwiaW5Qcm9ncmVzc0F1dGhUb2tlbiIsInJlcXVlc3RUaW1lIiwiZ2V0SWQiLCJpbnN0YWxsYXRpb25zSW1wbCIsImNhdGNoIiwiY29uc29sZSIsImdldFRva2VuIiwiY29tcGxldGVJbnN0YWxsYXRpb25SZWdpc3RyYXRpb24iLCJkZWxldGVJbnN0YWxsYXRpb25SZXF1ZXN0IiwiZ2V0RGVsZXRlRW5kcG9pbnQiLCJkZWxldGVJbnN0YWxsYXRpb25zIiwib25JZENoYW5nZSIsImdldEluc3RhbGxhdGlvbnMiLCJhcHAiLCJleHRyYWN0QXBwQ29uZmlnIiwib3B0aW9ucyIsImdldE1pc3NpbmdWYWx1ZUVycm9yIiwiY29uZmlnS2V5cyIsImtleU5hbWUiLCJ2YWx1ZU5hbWUiLCJJTlNUQUxMQVRJT05TX05BTUUiLCJJTlNUQUxMQVRJT05TX05BTUVfSU5URVJOQUwiLCJwdWJsaWNGYWN0b3J5IiwiY29udGFpbmVyIiwiZ2V0UHJvdmlkZXIiLCJfZGVsZXRlIiwiaW50ZXJuYWxGYWN0b3J5IiwiaW5zdGFsbGF0aW9uc0ludGVybmFsIiwicmVnaXN0ZXJJbnN0YWxsYXRpb25zIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@firebase/installations/dist/esm/index.esm2017.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js":
/*!***************************************************************!*\
  !*** ./node_modules/firebase/analytics/dist/esm/index.esm.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getAnalytics: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.getAnalytics; },\n/* harmony export */   getGoogleAnalyticsClientId: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.getGoogleAnalyticsClientId; },\n/* harmony export */   initializeAnalytics: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.initializeAnalytics; },\n/* harmony export */   isSupported: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.isSupported; },\n/* harmony export */   logEvent: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.logEvent; },\n/* harmony export */   setAnalyticsCollectionEnabled: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setAnalyticsCollectionEnabled; },\n/* harmony export */   setConsent: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setConsent; },\n/* harmony export */   setCurrentScreen: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setCurrentScreen; },\n/* harmony export */   setDefaultEventParameters: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setDefaultEventParameters; },\n/* harmony export */   setUserId: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setUserId; },\n/* harmony export */   setUserProperties: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.setUserProperties; },\n/* harmony export */   settings: function() { return /* reexport safe */ _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__.settings; }\n/* harmony export */ });\n/* harmony import */ var _firebase_analytics__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @firebase/analytics */ \"(app-pages-browser)/./node_modules/@firebase/analytics/dist/esm/index.esm2017.js\");\n //# sourceMappingURL=index.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hbmFseXRpY3MvZGlzdC9lc20vaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBb0MsQ0FDcEMscUNBQXFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9maXJlYmFzZS9hbmFseXRpY3MvZGlzdC9lc20vaW5kZXguZXNtLmpzPzExY2IiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0ICogZnJvbSAnQGZpcmViYXNlL2FuYWx5dGljcyc7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lc20uanMubWFwXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/firebase/analytics/dist/esm/index.esm.js\n"));

/***/ })

});